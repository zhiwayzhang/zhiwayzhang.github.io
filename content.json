{"pages":[{"title":"About🐼","text":"Web开发者这只熊猫菜死了 技术栈Golang应该挺熟吧 Linux应该会开关机吧 Redis勉强用过吧 MySQL大概懂一点吧 分布式真的会吗 Learning and Sharing博客记录日常学习","link":"/about/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"},{"title":"Categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"51nod3143-切比雪夫距离与曼哈顿距离","text":"51nod3143 Descriptionn位战士即将奔赴战场，他们每个人都有一个攻击值ai和一个防御值bi，现在你想设计一种装备给这n位战士，如果这件装备的攻击值为A，防御值为B，那么对于第i位战士这件装备的不匹配度为$max(|A−a_i|,|B−b_i|)$A，B都是正整数，要让所有战士的不匹配度之和最小，求出最小的不匹配度之和$2\\le N \\le 100000$ Solution题意中很明显是切比雪夫距离，可以将其转换为曼哈顿距离对于点$(x,y)$,转换为$(\\frac{x+y}{2},\\frac{x-y}{2})$然后可以求出转换后横坐标和纵坐标的中位数，再以这个中位数为基准，将四周3*3的范围内的点都进行计算，去最小值。由于涉及除法，可能会发生精度丢失，可以将所有坐标都扩大二倍，最后让答案除以2同时要注意，这里的A，B都是整数，也就是说我们进行计算的点必须也是整数点，可以通过奇偶关系来判断。答案只用A，B为整数点转换过来的点进行计算。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;set&gt;#define debug cout&lt;&lt;0&lt;&lt;endl#define ll long longconst int MAXN = 1e5 + 10;const int MOD = 1e9 + 7;using namespace std;struct point{ ll a, b;} arr[MAXN];int dx[] = {0, 1, -1, 0, 0, 1, 1, -1, -1};int dy[] = {0, 0, 0, 1, -1, 1, -1, 1, -1};ll x[MAXN];ll y[MAXN];int main() { ios::sync_with_stdio(false); cin.tie(0); int N; cin &gt;&gt; N; int xx, yy; for (int i = 1; i &lt;= N; i++) { cin &gt;&gt; xx &gt;&gt; yy; x[i] = arr[i].a = (xx + yy); y[i] = arr[i].b = (xx - yy); } sort(x+1,x+N+1); sort(y+1,y+N+1); int A, B; ll ans = __LONG_LONG_MAX__; if (N&amp;1) { A = x[N/2+1]; B = y[N/2+1]; } else { A = x[N/2+1]; B = y[N/2+1]; } ll ans2 = 0; for (int i = 0; i &lt;= 8; i++) { int tx = A + dx[i]; int ty = B + dy[i]; if ((tx-ty)%2==1 || ((tx+ty))%2==1) continue; ll temp = 0; for (int j = 1; j &lt;= N; j++) { temp += abs(arr[j].a-tx) + abs(arr[j].b-ty); } ans = min(ans, temp); } cout &lt;&lt; ans/2; return 0;}","link":"/2020/10/11/51nod3143/"},{"title":"GCD-兔八哥与猎人","text":"Description兔八哥躲藏在树林旁边的果园里。果园有M × N棵树，组成一个M行N列的矩阵，水平或垂直相邻的两棵树的距离为1。兔八哥在一棵果树下。猎人背着猎枪走进了果园，他爬上一棵果树，准备杀死兔八哥。如果猎人与兔八哥之间没有其它的果树，猎人就可以看到兔八哥。现己知猎人和兔八哥的位置，编写程序判断兔子所在的位置是否安全.输入： 第一行为n，表示有n(n ≤ 100,000)组数据，每组数据的第一行为两个正整数ax和ay，表示猎人的位置，第二行为两个正整数bx和by，表示兔八哥的位置(1 ≤ ax, ay, bx, by ≤ 100,000,000)。输出： 共有n行，每行为“yes”或“no”表示兔八哥的位置是否安全。 Solution容易想到，兔八哥和猎人只要连线上无整数点即可，可以转化成$|a_x - b_x| 和 |a_y - b_y|$互质，即$gcd(|a_x - b_x|,|a_y - b_y|)=1$ Code12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;#define mem(a,b) memset(a,b,sizeof(a))typedef long long ll;typedef unsigned long long ull;using namespace std;inline int gcd(int a, int b) { return b == 0 ? a : gcd(b,a%b);}int main() { //freopen(&quot;test.txt&quot;, &quot;r&quot;, stdin); ios::sync_with_stdio(false); cin.tie(0); int N; cin &gt;&gt; N; while (N--) { int ax, ay, bx, by; cin &gt;&gt; ax &gt;&gt; ay; cin &gt;&gt; bx &gt;&gt; by; int xx = abs(ax - bx); int yy = abs(ay - by); if (gcd(xx,yy) != 1) { cout &lt;&lt; &quot;yes&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;no&quot; &lt;&lt; endl; } } return 0;}","link":"/2020/10/07/GCD/"},{"title":"余数求和-整除分块","text":"Description给出整数$$n,k$$,计算$$G(n,k)=\\sum\\limits_{i=1}^n=k \\ mod \\ i$$,$$1&lt;=n,k&lt;=1e9$$ Solution将k mod i展开可以得到$$k - i\\lfloor \\frac{k}{i} \\rfloor$$将求和式子展开可以得到$$ \\sum\\limits_{i=1}^n = nk-\\sum\\limits_{i=1}^n i * \\lfloor\\frac{k}{i} \\rfloor $$利用整除分块，可以发现，对于相同的$$\\lfloor\\frac{k}{i} \\rfloor$$，即每个区间$$l 到 r$$，每次只需要再对i求和即可即每次计算$$(r-l+1)*\\lfloor \\frac{k}{i} \\rfloor * (l+r)/2$$ Note在分块的时候误写为r=N/(N/i)导致调试耽误大量时间，而且交了四发才发现 1234567for (ll l = 1, r; l &lt;= N; l = r + 1) { if (l &gt; K) { break; } r = min(N, K/(K/l)); ans -= (r - l + 1)*(K/l)*(l + r)/2; } Code1234567891011121314151617181920212223242526272829303132333435363738//https://www.luogu.com.cn/problem/P2261#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;set&gt;#define mem(a,b) memset(a,b,sizeof(a))#define debug cout&lt;&lt;0&lt;&lt;endl#define ll long longconst int MAXN = 1e2 + 10;const int MOD = 1e9 + 7;using namespace std;ll ans = 0;void solve(ll N, ll K) { ans = N*K; for (ll l = 1, r; l &lt;= N; l = r + 1) { if (l &gt; K) { break; } r = min(N, K/(K/l)); ans -= (r - l + 1)*(K/l)*(l + r)/2; } cout &lt;&lt; ans;}int main() { ios::sync_with_stdio(false); cin.tie(0); ll N, K; cin &gt;&gt; N &gt;&gt; K; solve(N, K); return 0;}","link":"/2020/10/07/divide/"},{"title":"统计硬币-递推&#x2F;DP","text":"DescriptionHDU 2566假设一堆由1分、2分、5分组成的n个硬币总面值为m分，求一共有多少种可能的组合方式（某种面值的硬币可以数量可以为0）。 Solution坑题，没给数据范围，只能瞎猜，一发搜索挂掉发现无法去重，但是考虑到该问题满足从1开始分配并无后效性，可以直接递推（类似背包），三种物品可选任意次 Code1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;#define mem(a,b) memset(a,b,sizeof(a))typedef long long ll;typedef unsigned long long ull;using namespace std;int main() { //freopen(&quot;test.txt&quot;, &quot;r&quot;, stdin); ios::sync_with_stdio(false); int N, M; int ans; int dp[2000][2000]; int n[] = {1,2,5}; cin.tie(0); int T; cin &gt;&gt; T; while (T--) { cin &gt;&gt; N &gt;&gt; M; mem(dp,0); dp[0][0] = 1; for (int i = 0; i &lt; 3; ++i) { for (int j = 1; j &lt;= N; ++j) { for (int k = n[i]; k &lt;= M; ++k) { dp[j][k] += dp[j-1][k-n[i]]; } } } cout &lt;&lt; dp[N][M] &lt;&lt; endl; } return 0;}","link":"/2020/10/07/cntcoin/"},{"title":"小兔的棋盘 组合数学","text":"Description小兔的叔叔从外面旅游回来给她带来了一个礼物，小兔高兴地跑回自己的房间，拆开一看是一个棋盘，小兔有所失望。不过没过几天发现了棋盘的好玩之处。从起点$(0，0)$走到终点$(n,n)$的最短路径数是$C_{2n}^{n}$,现在小兔又想如果不穿越对角线(但可接触对角线上的格点)，这样的路径数有多少?小兔想了很长时间都没想出来，现在想请你帮助小兔解决这个问题，对于你来说应该不难吧! $n \\leq 35$ Solution由于规定不能超过对角线，可用分治的思想，只考虑沿对角线分隔开的三角形的情况，对于一个三角形中，求从$(0，0)$走到终点$(n,n)$的最短路径，观察发现无论怎么走，设到达某一点时向上走了$i$步，向右走了$j$步，都有$i \\leq j$这也能通过线性规划相关知识证明。不难发现只是一个类括号匹配问题，可用$Catalan$数求解，计算$C(n)$后即是在一个三角形中的解，答案是$$2C(n)$$ $$C(n) = \\sum_{i=0}^{n-1} C(i) \\cdot C(n-i-1)$$通项公式$$C(n)=\\frac{C_{2n}^{n}}{n+1}$$ 预处理$C(n)$即可 Code1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;queue&gt;typedef long long LL;using namespace std;LL C[100];int main() { C[0] = 1; C[1] = 1; for (int i = 2; i &lt;= 80; i++) { LL t = 0; for (int j = 0; j &lt; i; j++) t += C[j]*C[i - j - 1]; C[i] = t; } LL N; int cnt = 1; while (cin &gt;&gt; N) { if (N == -1) break; cout &lt;&lt; cnt++ &lt;&lt; &quot; &quot; &lt;&lt; N &lt;&lt; &quot; &quot; &lt;&lt; C[N]*2 &lt;&lt; endl; } return 0;}","link":"/2019/12/13/catalan/"},{"title":"DP? 素数筛+Lucas定理+费马小定理","text":"Description在杨辉三角中，从第一行第一列$(0,0)$开始，每次可选择向正下方走或向右下方走，走到第$n$行时不能超过第$n$行第$k$个元素，询问所经过路径的值的和的最小值$mod(p)$，一共有T组询问，$T \\leq 100000$， $0 \\leq k \\leq n \\leq 1e9$, 保证$p$是质数， 其中$p &lt; 1e4$ Solution名字虽然是DP，但是可以找出最优方案。优先考虑$k \\leq \\frac{n}{2}$的情况，先向下走$n-k$步到达$(n-k-1,0)$再一路沿着右下方走，直到到达底部，即有$$C_{n-k}^{0}+C_{n-k+1}^{1}+C_{n-k+2}^{2}+…+C_{n}^{k}=C_{n+1}^{k}$$通过变换$$C_{n-k}^{0} = C_{n-k+1}{0}$$再通过公式$$C_{n}^{m}=C_{n-1}^{m}+C_{n-1}^{m-1}$$可将上述公式合并得到$$C_{n+1}^{k}$$所以答案为$$C_{n+1}^{k}+n-k$$当$$k &gt; \\frac{n}{2}$$时，根据对称性，令$k=n-k$即可转化成上一种情况又发现题目涉及组合数取模，所以要用到费马小定理 费马小定理:假如$a$是一个整数，$p$是一个质数，且$gcd(a,p)=1$，即$a,p$互质，那么有$a^{p−1}≡1(modp)$ 已知$a^{p-1}≡1$，可以得到$a \\cdot a^{p-2}≡1$，我们称$a$和$a^{p-2}$为在$mod(p)$意义下的乘法逆元然而这只解决了除法取模的问题，注意到$n$的范围在$1e9$直接计算组合数又是铁套老鹅(TLE)，于是借助Lucas定理 对于质数$p$,有$$C_n^m\\ mod \\ p = C_{\\lfloor \\frac{n}{p} \\rfloor}^{\\lfloor \\frac{m}{p} \\rfloor} \\cdot C_{n\\ mod\\ p}^{m\\ mod\\ p} \\ mod \\ p$$ 可知$n\\ mod\\ p$和$m\\ mod\\ p$一定是小于$p$的数，可直接求解，其余部分继续用Lucas定理求解，当$m=0$的时候返回$1$ 1234long long Lucas(long long n, long long m, long long p) { if (m == 0) return 1; return (C(n % p, m % p, p) * Lucas(n / p, m / p, p)) % p;} 有了这些工具之后就可以预处理阶乘和逆元了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;queue&gt;typedef long long LL;const int MAXN = 10000;using namespace std;LL N,K,MOD;bool isnotp[MAXN + 10];LL pri[1500], num = 0;//素数表int f[1300][MAXN];//阶乘int inv[1300][MAXN];//逆元inline void Euler() { isnotp[1] = true; memset(isnotp, false, sizeof(isnotp)); for (int i = 2; i &lt;= MAXN; i++) { if (!isnotp[i]) pri[++num] = i; for (int j = 1; j &lt;= num &amp;&amp; i*pri[j] &lt;= MAXN; j++) { isnotp[i*pri[j]] = true; if (i%pri[j]==0) break; } }}LL fffpow(LL x, LL y, LL pp) { LL sum = 1; LL a = x; while (y) { if (y&amp;1) { sum = (sum*a) % pp; } a = (a*a)%pp; y&gt;&gt;=1; } return (sum)%pp;}int cnt = 0;inline LL Lucas(int N,int M,int o){ LL a,b,ans=1; while(N &amp;&amp; M) { a = N%pri[o]; b = M%pri[o]; if(a &lt; b)return 0; ans = ans*f[o][a]%pri[o]*inv[o][b]%pri[o]*inv[o][a-b]%pri[o]; N /= pri[o]; M /= pri[o]; } return ans;} int main() { Euler(); for(int i = 1; i &lt;= num; i++) { f[i][0] = f[i][1] = 1; inv[i][0] = inv[i][1] = 1; for(int j = 2;j &lt; pri[i]; j++) { f[i][j] = f[i][j-1]*j % pri[i]; inv[i][j] = fffpow(f[i][j], pri[i]-2, pri[i]); } } while (cin &gt;&gt; N &gt;&gt; K &gt;&gt; MOD) { LL ans; if(K &gt; N/2) K = N - K; int l = 1, r = 1229; while(l &lt;= r) { int mid = (l + r) &gt;&gt; 1; if(MOD &lt; pri[mid]) r = mid - 1; else l = mid + 1; } ans = (Lucas(N + 1, K, l - 1) + N - K)%MOD; printf(&quot;Case #%d: %lld\\n&quot;, ++cnt, ans); } return 0;}","link":"/2019/12/13/lucas/"},{"title":"Fibonacci 矩阵快速幂","text":"Description请输出$Fib(n) mod 10000$$n \\leq 1000000000$ Solution由于$n$的范围在$1e9$直接递推铁TLE，考虑矩阵快速幂Fibonacci数列有如下性质通过多次迭代算是个板子题吧，记得在WUST新生赛做过一道想矩阵快速幂的题，然而正解是找规律QAQ，在此贴个板子。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;string&gt;typedef long long LL;const int MOD = 1e4;using namespace std;struct Matrix{ LL m[2][2]; void print(){ for (int i = 0; i &lt; 2; i++) { for (int j = 0; j &lt; 2; j++) cout &lt;&lt; m[i][j] &lt;&lt; ' '; cout &lt;&lt; endl; } }} base, ans;Matrix times(Matrix a, Matrix b) { Matrix ans; ans.m[0][1] = ans.m[0][0] = ans.m[1][0] = ans.m[1][1] = 0; for (int i = 0; i &lt; 2; i++) { for (int j = 0; j &lt; 2; j++) { for (int k = 0; k &lt; 2; k++) ans.m[i][j] = (ans.m[i][j] + a.m[i][k]*b.m[k][j])%MOD; } } return ans;}void Matrixpow(LL x) { base.m[0][0] = base.m[1][0] = base.m[0][1] = 1; base.m[1][1] = 0; ans.m[0][0] = ans.m[1][1] = 1; ans.m[0][1] = ans.m[1][0] = 0; while (x) { if (x&amp;1){ ans = times(ans, base); } x &gt;&gt;= 1; base = times(base, base); }}LL N;int main(){ while (cin &gt;&gt; N) { if (N == -1) break; if (N == 0) { cout &lt;&lt; &quot;0&quot; &lt;&lt; endl; continue; } Matrixpow(N); cout &lt;&lt; ans.m[0][1] % MOD &lt;&lt; endl; } return 0;}","link":"/2019/12/13/fibMatrix/"},{"title":"计算几何-平行四边形","text":"Description求平面上n个点构成的平行四边形个数。输入一行一个数n。接下来n行，每行两个数x,y，表示这个点的坐标为(x,y)。保证任意两点不重合，任意三点不共线。输出一行一个整数表示平行四边形个数。 Solution按照平行四边形的性质，两组顶点的中点重合，可以统计出每组顶点的中点，再统计每个顶点的个数，排列组合一下 Note第一发对于顶点的统计出锅了，排序条件写错，提交都要检查排序","link":"/2020/05/13/jsjh/"},{"title":"莫队-小B的询问洛谷P2709","text":"DescriptionP2709小B 有一个长为n的整数序列$a$，值域为$[1,k]$。他一共有m个询问，每个询问给定一个区间$[l,r]$求：$\\sum_{i=1}^k c_i^2$其中 $c_i$表示数字 $i$ 在$[l,r]$ 中的出现次数。小B请你帮助他回答询问。 Solution莫队算法板子题 mark Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;set&gt;#define mem(a,b) memset(a,b,sizeof(a))#define debug cout&lt;&lt;0&lt;&lt;endl#define ll long longconst int MAXN = 5e4 + 10;const int MOD = 1e9 + 7;using namespace std;struct Q{ int l, r, k;} q[MAXN];int N, M, K;int pos[MAXN], a[MAXN], cnt[MAXN];ll ans[MAXN];ll res;inline void Add(int n) { cnt[a[n]]++; res += 2ll*cnt[a[n]] - 1;}inline void Sub(int n) { cnt[a[n]]--; res -= 2ll*cnt[a[n]] + 1;}int main() { ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; N &gt;&gt; M &gt;&gt; K; int siz = sqrt(N); for (int i = 1; i &lt;= N; i++) { cin &gt;&gt; a[i]; pos[i] = i/siz; } for (int i = 1; i &lt;= M; i++) { cin &gt;&gt; q[i].l &gt;&gt; q[i].r; q[i].k = i; } sort(q+1,q+M+1,[](Q x, Q y){ return pos[x.l] == pos[y.l] ? x.r &lt; y.r : pos[x.l] &lt; pos[y.l]; }); int l = 1, r = 0; for (int i = 1; i &lt;= M; i++) { while (q[i].l &lt; l) Add(--l); while (q[i].r &gt; r) Add(++r); while (q[i].l &gt; l) Sub(l++); while (q[i].r &lt; r) Sub(r--); ans[q[i].k] = res; } for (int i = 1; i &lt;= M; i++) { cout &lt;&lt; ans[i] &lt;&lt; endl; } return 0;}","link":"/2020/10/07/modui/"},{"title":"Triangle Fibonacci+二分查找","text":"Description有$n$个木棍，长度为$1,2,3…n$，现在要从中删掉一些木棍，使得剩下的木棍不能构成三角形，使删掉木棍的数量最少。T组数组，$T \\leq 20$$n \\leq 20$ Solution由于数据范围很小，可以直接暴力求解，依次选取两个数$a,b(a&lt;b)$相加，要知道不能有任何一个数小于这个值，直接删掉$(a,a+b)$范围中的数即可如果$n$的范围是$1e9$呢？通过找规律发现我们剩下的数是这样的$1,2,3,5,8,13,21…$这是Fibonacci数列!!!!所以我们只需要找到$\\leq n$的Fibonacci数有几个，减去就是答案可以直接lower_bound注意处理极限数据！！！即$n==1||n==2$的情况也可手写二分，但是二分貌似常数有点大，又考虑到第$88$个Fibonacci数就爆掉$1e9$了，所以直接便利也完全没问题 Code暴力版本12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;bool vis[23];int main() { int T; cin &gt;&gt; T; for (int i = 1; i &lt;= T; i++) { int N, ans = 0; cin &gt;&gt; N; memset(vis, false, sizeof(vis)); for (int j = 1; j &lt;= N - 1; j++) if (!vis[j]) { for (int k = j + 1; k &lt;= N; k++) { if (!vis[k]) { for (int l = k + 1; l &lt;= j + k - 1; l++) if (!vis[l] &amp;&amp; l &lt;= N) vis[l] = true, ans++; break; } } } printf(&quot;Case #%d: %d\\n&quot;, i, ans); } return 0;} 二分+Fib123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;queue&gt;typedef unsigned long long uLL;typedef long long LL;const LL MOD = 1e18; using namespace std;LL f[100];int main() { f[0] = 1; f[1] = 1; for (int i = 2; i &lt;= 80; i++) f[i] = f[i - 1] + f[i - 2]; int T; cin &gt;&gt; T; for (int i = 1; i &lt;= T; i++){ LL N; cin &gt;&gt; N; if (N == 1 || N == 2) { printf(&quot;Case #%d: 0\\n&quot;, i); continue; } int l = 1, r = 80; /*手写二分查找 while (l &lt;= r) { int mid = (l + r) &gt;&gt; 1; if (f[mid] &lt;= N) l = mid + 1; else r = mid - 1; } int pos = l; */ int pos = lower_bound(f, f + 80, N) - f; if (f[pos] != N) pos--; printf(&quot;Case #%d: %d\\n&quot;, i, N - pos); } return 0;}","link":"/2019/12/13/fib/"},{"title":"Luogu3964-松鼠聚会","text":"Luogu3964 Description草原上住着一群小松鼠，每个小松鼠都有一个家。时间长了，大家觉得应该聚一聚。但是草原非常大，松鼠们都很头疼应该在谁家聚会才最合理。每个小松鼠的家可以用一个点$(x,y)$表示,两个点的距离定义为点 $(x,y)$ 和它周围的8个点 $$(x-1,y)，(x+1,y),(x,y-1)，(x,y+1)$$$(x−1,y+1),(x-1,y-1),(x+1,y+1),(x+1,y-1)$距离为1。输出一个整数，表示松鼠为了聚会走的路程和最小是多少。 Solution观察题目发现，松鼠家之间的距离为切比雪夫距离，可以通过转换成曼哈顿距离求解，即问题转换为给出平面中的N个点，求一个点到其他所有点的曼哈顿距离之和最小是多少。如果选定的点为第j个答案即为$$\\sum_{i=1}^{N}dis(i,j)$$,dis表示两个点的曼哈顿距离将两个坐标拆开计算，可以得到$$ans_x = \\sum_{i=1}^Ndis(j,i)$$$$dis(1,j)+dis(2,j)+dis(3,j) +…+dis(n,j)$$将横坐标按照升序排序$$(x_j-x_1)+(x_j-x_2)+(x_j-x_3)+…+(x_j-x_{j-1})+(x_{j+1}-x_j)+…+(x_n-x_j)$$ $$\\sum_{i=1}^{j-1}(x_j-x_i)+\\sum_{i=j+1}^{N}(x_i-x_j)$$ $$(j-1)*x_j-\\sum_{i=1}^{j-1}x_i + \\sum_{i=j+1}^Nx_i-(N-j)*x_j$$ $$\\sum_{i=1}^Nx_i-2\\sum_{i=1}^jx_i-x_j*(n-2*j)$$于是可以使用前缀和优化，坐标排序后预处理前缀和在每次进行计算时在有序坐标数组中找到对应的下标精度问题可以先把坐标都扩大二倍，最后令答案处以2 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;set&gt;#define debug cout&lt;&lt;0&lt;&lt;endl#define ll long longconst int MAXN = 1e5 + 10;const int MOD = 1e9 + 7;using namespace std;int N;struct point { ll x, y;} a[MAXN];ll x[MAXN]; ll prex[MAXN];ll y[MAXN];ll prey[MAXN];int main() { ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; N; for (int i = 1; i &lt;= N; i++) { int xx, yy; cin &gt;&gt; xx &gt;&gt; yy; x[i] = a[i].x = (xx + yy); y[i] = a[i].y = (xx - yy); } sort(x+1, x+N+1); sort(y+1, y+N+1); for (int i = 1; i &lt;= N; i++) { prex[i] = prex[i-1] + x[i]; prey[i] = prey[i-1] + y[i]; } ll ans = __LONG_LONG_MAX__; for (int i = 1; i &lt;= N; i++) { ll temp; int lx = lower_bound(x+1,x+N+1,a[i].x) - x; int ly = lower_bound(y+1,y+1+N,a[i].y) - y; temp = (prex[N]-2*prex[lx]-a[i].x*(N-2*lx)) +(prey[N]-2*prey[ly]-a[i].y*(N-2*ly)); // cout &lt;&lt; &quot; list = &quot;&lt;&lt; a[i].x &lt;&lt; ' ' &lt;&lt; a[i].y &lt;&lt; ' ' &lt;&lt; temp &lt;&lt; endl; ans = min(ans, temp); } cout &lt;&lt; (ans/2); return 0;}","link":"/2020/10/11/luogu3964/"},{"title":"WHUT新生赛&quot;游记&quot;","text":"Day -N快新生赛了啊啊啊啊，半个多月没碰算法题了，一直在搞ToKen的前端任务，还在搞服务器的事，感觉要凉凉。 Day 1嗯，就只有Day1.早上起的很晚，八点半才从床上爬起来，起来之后第一件事是看我的USB-HUB发货没有!!!都好几天了，一个USB接口坏了，机械键盘没法用啊，想去买usb转type-c线的想了想还是再等等吧ε=ε=ε=┏(゜ロ゜;)┛下楼去堕落一条街吃了早饭。中午吃完饭回来买了杯奶茶丫丫精，发现喝完了有点撑得慌~~~~然后就等12.30了。比赛开始赶紧去找签到题。 A题emmmmm像是的数学题，递推，一看数据范围感觉不可做。 B题这题面稍微有点问题啊。室友就以为是按顺序组合起来的，虽然感觉仔细想想也想出来是求和的，直接DFS走了？？？不存在的，这里有个老年人sum没重置，debug一万年啊，最后才发现sum每次没有赋初值ε=ε=ε=┏(゜ロ゜;)┛ C题签到题 D题一开始没看清题意，直接while求Σa*0.1一直到不影响答案为止，算到了1e-5，第一发不知道咋WA了，两发才过。 E题博弈论，不可做 F题并查集。但是！！老年人在这里又拉胯了！！！要输出没有感染的人，我输出了一万年感染的人，交了五六发？？？ J题模拟题。 Ｈ题贪心交了一发没过，分类讨论情况可能会很多，没敢用搜索。 I题博弈论sg==就会三种博弈的蒟蒻枯了。听WHU的巨巨说记忆化搜索也能过。 J题计算几何。我认输。在线处理当成直线做的，没考虑到路程是个线段，debug一万年，最后还有半个小时封板的时候放弃了QAQ K题模拟题，我充分意识到半个小时可能写不出来了，想去debug一下J题吧 后记最后五题榜19。校内 榜二。WHU和HUST的巨巨们霸榜啊orz。 进队了orz 其实感觉中间耽误了好多时间啊，低级错误，不然可能会在开出两题，just可能。orz J题一大遗憾。也是给自己个教训吧。 至此成为WHUTer之后，又成为了ToKener，又成为了ACMer。专心训练和学习啦。逃ε=ε=ε=┏(゜ロ゜;)┛：蒟蒻 蒟蒻 蒟蒻","link":"/2019/11/16/whutacm/"},{"title":"中缀表达式求值","text":"中缀表达式求值对于表达式求值，我们通常用栈来操作。常用的做法是先转换为后缀表达式，再利用栈来求值。步骤如下： 开一个栈一个储存运算符，再开一个结构存后缀表达式，可以选择string数组 每遇到一个数字，将其加入到后缀表达式种 遇到左括号，加入到符号栈种 遇到右括号，不断将栈顶元素添加到后缀表达式中，直到遇到左括号，然后弹出左括号 遇到普通运算符，只要栈顶符号的优先级不低于新符号，就不断取出栈顶元素存到后缀表达式，然后将新符号入栈，优先级顺序为乘除&gt;加减&gt;左括号 依次取出符号栈中剩余元素，加入到后缀表达式中 将得到的后缀表达式求值 Note代码在取栈顶元素时容易出错，需要注意对栈为空时的判断 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#define mem(a,b) memset(a,b,sizeof(a))#define debug cout&lt;&lt;0&lt;&lt;endl#define ll long longconst int MAXN = 1e4 + 10;const int MOD = 1e9 + 7;using namespace std;stack&lt;int&gt; stnumber;stack&lt;char&gt; stsign;stack&lt;int&gt; ans;struct node { string s=&quot;&quot;;} a[MAXN];int oder(char c) { if (c == '+' || c == '-') return 1; else if (c == '*' || c == '/') return 2; return 0;}int toInt(string ss) { int res = 0; for (int i = 0; i &lt; ss.length(); i++) { res = res*10 + ss[i] - '0'; } return res;}int calc(int aa, int bb, char op) { switch (op) { case '+': return aa + bb; break; case '/': return bb / aa; break; case '*': return aa*bb; break; case '-': return bb - aa; break; default: break; }}bool isnum(char si) { if (si &lt;= '9' &amp;&amp; si &gt;= '0') return true; return false;}int cur = 0;int main() { ios::sync_with_stdio(false); cin.tie(0); int N; cin &gt;&gt; N; string s; cin &gt;&gt; s; N = s.length(); int len = 0; for (int i = 0; i &lt; N; i += len) { len = 0; if (isnum(s[i])) { string t = &quot;&quot;; for (int j = i; j &lt; N; j++) { if (isnum(s[j])) { t += s[j]; len++; } else { break; } } a[++cur].s = t; } else { if (s[i] == '(') stsign.push(s[i]); else if (s[i] == ')') { while (stsign.top() != '(') { char op = stsign.top(); stsign.pop(); a[++cur].s += op; } stsign.pop(); } else { char op = s[i]; if (!stsign.empty()) while (!stsign.empty() &amp;&amp; oder(stsign.top()) &gt;= oder(op)) { a[++cur].s += stsign.top(); stsign.pop(); //if (stsign.empty()) break; } stsign.push(op); } len = 1; } } while (!stsign.empty()) { char op = stsign.top(); stsign.pop(); a[++cur].s += op; } // for (int i = 1; i &lt;= cur; i++) { // cout &lt;&lt; a[i].s &lt;&lt; endl; // } for (int i = 1; i &lt;= cur; i++) { int temp; if (isnum(a[i].s[0])) { temp = toInt(a[i].s); ans.push(temp); } else { int aa = ans.top(); ans.pop(); int bb = ans.top(); ans.pop(); ans.push(calc(aa, bb, a[i].s[0])); } } cout &lt;&lt; ans.top(); return 0;}","link":"/2020/10/07/zhongzhui/"},{"title":"计算机组成原理笔记","text":"本文随机更新机组笔记 CH2数据表示定点数与浮点数定点数小数点的位置固定不变，有两种形式，定点小数和定点整数.定点整数要求小数点在数据最低有效数位之后。$$00101001.$$定点小数要求小数点在数据最高有效数位之前。$$0.1111111$$ 浮点数基数为2的数F，浮点表示为$$F = M \\times 2^E$$其中M为尾数，E为阶码。尾数为带符号的纯小数，阶码为带符号的纯整数。按照上式表示的数字既可以是纯整数，也可以是纯小数，因此小数点位置不固定，所以称为浮点数。 在计算机中，常用的一种浮点数表示方法为 数符 阶符 阶码数值部分 尾数数值部分 1 1 k n 阶码和尾数的数值范围为 阶码与尾数 数值 阶码与尾数 数值 阶码最小值 $-2^k$ 阶码最大值 $2^k-1$ 尾数最小负值 $-1$ 尾数最大负值 $-2^{-n}$ 尾数最小正值 $+2^{-n}$ 尾数最大正值 $+(1-2^{-n})$ 因此可以得到浮点数表示的数值范围：最小负数:$-2^{2^k-1}=-2^{阶码最大值}$ 最大负数:$-2$ 因此浮点数编码位数位$$m=(n+1)+(k+1)$$ 补码补码的特点： n位补码表示的整数数值范围为$[-2^{n-1},2^{n-1}-1]$ n位补码表示的小数数值范围为$[-1,1-2^{-n+1}]$ 在补码中0的表示是唯一的 变形码，当模数为4时，可以形成双符号位补码，11表示负，00表示正，当两个符号位不同时表示运算溢出，又叫做变形补码。待更 求补运算，处理器中有求补指令，其功能是对操作数取负数(所有位变反+1) 简化加减法$$[X+Y]_补=[X]_补+[Y]_补$$ 移码当一个数字的正数所对的二进制与负数所对的二进制直接比较大小时，会出现负数所对的二进制更大的情况。例如对于十进制数31 $$10011111_{-31} &gt; 01100001_{31}$$ 如果对负数补码上加上一个偏移量，再进行比较即可反应实际情况。 定义为:对于包括符号位在内的n位字长，在其真值上加上$2^{n-1}$$$[X]_移 =2^{n-1}+X$$ 特点：$$[X]_移&lt;符号为取反&gt;[X]_补$$ 纠错码若有n位数据，添加k位校验位，共有n+k位编码 海明距离：$$d = |x-y|=\\sum_{i=0}^{m-1}|x_i-y_i|$$ 可以使用位运算异或求解，获得海明距离 奇偶校验码 奇校验：设$$X = x_0x_1x_2x_3x_4…x_{n-1}$$是一个n位字，在最高位添加一位奇校验c使得$$X’=cx_0x_1x_2x_3x_4…x_{n-1}$$有$$c \\oplus x_1\\oplus … \\oplus x_{n-1} = 1$$ 偶校验则相反，只能判断是否出错，无法纠错 海明校验码 对于16位数据，用$$D_{16}-D_{0}$$分别表示高位到低位，要使其拥有1位纠错功能，则需要在有效信息中添加5个校验位，H4～H0此时海明码的码长为$$m=n+k=16+5=21$$ 循环冗余校验码大概就是用一个性能比较好的生成多项式构造一个编码，利用模2除法的余数进行校验，而且纠错性能不是100%，先Pass 运算方法和运算器加减运算利用补码的性质，可以将运算转化为补码的加法。 $$[X+Y]_补=[X]_补+[Y]_补$$ 这里有一个需要区分的概念，求补运算和求补码的区别 求补：对一个正数求补，令其包括符号位在内的各位取反再加1，即可得到该数的负数，若对该负数再求补，可以得到原来的正数。 $$[[X]_补]_求=[-X]_补$$ 同理有 $$[[-X]_补]_求=[X]_补$$ 可以总结出补码减法的运算法则为 $$[X-Y]_补 = [X]_补+[-Y]_补 =[X]_补+[[Y]_补]_求$$ 因此可以将减法转化为加法运算 溢出判断只有两个符号相同的数字相加，或者符号相异的数相减才有可能发生溢出。若分别用xyz表示三个数字的符号位，可得标准最小项$$\\overline{x} \\cdot \\overline{y} \\cdot z+x\\cdot y\\cdot \\overline{z}$$只有该式为真时，将发生溢出。 双符号位判定每个数字有两个符号位，其中00表示正数，11表示负数令OF OverflowFlag表示溢出符号$$S_1,S_2$$分别表示运算结果的两符号， 有$$OF = S_1 \\oplus S_2$$ 进位符号判定$$令 C_{n-1}表示最高数值位产生的进位，C_n表示符号位产生的进位$$即有$$OF = C_{n-1}\\oplus C_n$$ 一位全加器计算每一位逻辑$$Z_i=X_i\\oplus Y_i \\oplus C_i$$进位信号通过递推产生可以设计出简单的行波式进位加法器，从最低位开始传递进位信号，是异步时序电路，因此运算速度比较慢。 在位数已知的情况下，可以设计电路一次性计算出所有的进位信号，比较理想的情况是以四个位数为一组，该电路增长量级太大，如果需要更多位数可以利用多个该电路组合使用，组成组内并行组间串行进位加法器。","link":"/2021/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/"},{"title":"汇编语言笔记","text":"简介本学期选了汇编语言这门选修课，我认为还是有很大的学习价值的，虽然学习的还是年代久远的8086CPU指令集，但对后续接触更多汇编语言还是有很大帮助，方便我们调试程序，多了一种查错的方式。其实关于调试自己很久之前就想学了，高中的时候看紫书，发现lrj老师讲了一段的gdb调试方法，当时感觉一点都看不懂，现在借此机会学习一下gdb的调试。本文除了将总结一些汇编语言学习过程中的笔记之外，还计划穿插一些cs213/CSAPP 的内容以及bomb lab的解析。 准备工作dos系统现在以及年代久远，想使用8086CPU指令集调试的话需要借助DosBox来实现。DosBox官网 由于macOS下没有DOSbox需要的调试工具，因此下载之后需要挂载debug.exe等Windows下的调试工具在DOSbox中输入 123mount C ~/dosC:debug 即可进入debug模式 实验1前置知识几条汇编指令 1234mov 目标操作对象,源操作数add 目标操作对象,源操作数jmp 寄存器 //修改IP寄存器的值or 12345jmp CS:IPeg: jmp ax == (let IP = ax) jmp 2AE3:3 == let CS = 2AE3H and let IP = 0003Hsub ax,bxax = ax - bx 1234inc and decinc 操作对象 eg: inc ax == ax+=1 dec ax == ax-=1 注意：不可用mov指令修改段寄存器的值。（代码段寄存器CS，指令指针寄存器IP）CPU中识别CS:IP为执行指令操作对象可以是寄存器，也可以是地址 Debug命令 123456r: 看查寄存器内容，或者修改寄存器内容d: 看查内存内容e: 改写内存内容u: 将机器指令翻译为汇编指令t: 执行下一条汇编指令a: 写入汇编指令 编译指令 123masm testlink test.objdebug test.exe lab112345678MOV WORD PTR [1100],3445MOV WORD PTR [1102],5678MOV WORD PTR [1106],6732MOV AX,[1100]SUB AX,[1102]ADD AX,[1106]MOV [1104],AXHLT //使CPU停止工作 123456789101112MOV AX,1234 MOV [1000],AXMOV BX,1002MOV BYTE PTR[BX],20MOV DL,39INC BXMOV [BX],DLDEC DLMOV SI,3MOV [BX+SI],DLMOV [BX+SI+1],DLMOV WORD PTR[BX+SI+2],2846","link":"/2021/03/16/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/"},{"title":"记录一次Go项目的部署","text":"最近写了一个go项目，需要部署到服务器进行测试，如果只是go run main.go难免也太麻烦了点，于是学习了项目部署的相关知识。项目的部署有多种方式，Jenkins,nginx等方式，本文只讲解一下简单的shell脚本部署。 系统信息系统信息: CentOS Linux release 8.3.2011 x86_64Go version: go version go1.14.12 linux/amd64 几条命令的介绍nohupnohup命令的全称为no hang up不挂起，可以在系统后台不挂断的运行命令，退出终端后程序也会正常运行。语法格式：nohup ./xxx &gt; xxx.log 2&gt;&amp;1 &amp;解释：&gt; xxx.log表示将输出重定向至该文件，可以记录运行时的日志2&gt;&amp;1将标准错误2重定向到标准输出&amp;1，然后标准输出&amp;1再被重定向至xxx.log文件 git pullgit pull origin dev为了方便项目的及时更新，使用改名了保证运行时与上游仓库的代码保持一致。 psps命令为 process status,可以查看系统当前的进程状态 例如 123456~&gt; ps PID TTY TIME CMD 255873 pts/0 00:00:02 zsh 258517 pts/0 00:00:00 sh 258519 pts/0 00:00:00 OnlineJudge 263021 pts/0 00:00:00 ps 我们将用ps命令与grep等命令筛选出项目的pidps命令有很多参数选择，这里介绍一下用到的两条命令: 12ps -e 列出所有进程ps -f 显示进程的全部信息 grepgrep命令可以查找文本中符合条件的字符串，用于匹配进程的名称，还可以匹配文本中的各种信息，本文不再具体展开，后续打算更一篇具体记录Linux命令的博客。 awk用于处理文本提取信息，将使用grep查询到的进程信息提取出pid查询到的结果为root 263948 263946 0 12:49 pts/0 00:00:00 ./OnlineJudge我们只需要第二项的pid，使用awk {print $2}即可提取出进程的pid 263948 killkill pid杀死进程 Shell脚本1234567891011121314echo -e &quot;*** Online_Judge ***\\n&quot;echo -e &quot;*** 检查上游代码中 ***\\n&quot;git pull origin devecho -e &quot;*** 编译中 ***\\n&quot;go buildchmod -R 777 OnlineJudgepid=`ps -ef|grep OnlineJudge|grep -v grep|awk '{print $2}'`echo -e &quot;$pid\\n&quot;kill $pid &amp;&amp; nohup ./OnlineJudge &gt; OnlineJudge.log 2&gt;&amp;1 &amp;pid2=`ps -ef|grep OnlineJudge|grep -v grep|awk '{print $2}'`echo -e &quot;项目部署成功***进程ID为:$pid2&quot; 将脚本保存至项目目录，赋予执行权限chmod +x setup.sh执行脚本 1234567891011121314151617181920➜ git:(dev) ✗ ./setup.sh *** Online_Judge ****** 检查上游代码中 ***From url * branch dev -&gt; FETCH_HEADAlready up to date.*** 编译中 ****** 添加权限 ***添加权限成功*** kill进程 ***258519./setup.sh: line 18: 258519 Terminated nohup ./OnlineJudge &gt; OnlineJudge.log 2&gt;&amp;1项目部署成功***进程ID为:263948 至此项目即可部署成功上述shell中的视个人情况而修改 ReferenceLinux命令大全如何优雅的通过Shell脚本一键部署GO项目到服务器？","link":"/2021/03/30/godeploy/"},{"title":"Git学习笔记","text":"对于git，很早很早就在用了，但是还没有系统整理过，并且有些命令使用时需要注意的事项，在此也一并标出。 About Gitgit是一个分布式版本控制工具，如果你是一个程序猿，那你必须要学会如何使用git来管理你的代码或者项目。可能更多人所熟知的是GitHub，顾名思义，按照英语的命名特点，GitHub就是所有git上传的枢纽，汇聚到一起，你可以开源你的代码，指定一款开源协议共享给所有需要的人，也可以将仓库设为私有，只有自己或者受到邀请的人可见或者进行编辑。除了GitHub，世界上还有很多这种代码托管平台，比如国内的gitee,coding等，国外还有gitlab等平台提供代码托管服务。 Setup在一个目录中，你可以使用git init来初始化这个目录，git会把这个文件夹变为一个git目录， 12&gt; GitTest git initInitialized empty Git repository in /Users/username/GitTest/.git/ 使用git remote add origin {your repo url}即可添加远程的仓库地址。 Commit &amp;&amp; Push对于一个采用迭代式开发或者其他开发模式的项目来说，都避免不了后续对代码进行修改或者添加一些新的文件，对于每一次这样的操作，都要对添加或者修改的文件指定一个commit。例如：修改了项目功能中的bug，文件名字为a.cpp可以使用 12git add a.cppgit commit -m &quot;fix: the bug in xxx&quot; 这样就可以将此次更改添加到提交的队列中如果使用git add .，git将添加所有监控的文件到缓冲区再使用git push就可以将修改添加到远程仓库中 对与一个团队而言，有标准规范的commit格式是很重要的，例如以下格式 12345feat: 新功能featurefix: 解决bugadd: 添加模块update: 更新模块... 等等 Dangerous Pull ing如果是多人协作开发，那么必然会导致本地文件之间存在着不一致，为了解决这个问题，可以使用git pull，执行该命令后将同步仓库中存在并且与本地不同的文件。这个操作看似简单，但是有时候如果使用了–force强制执行的话，会覆盖掉本地的文件，属于非常危险的操作，所以无论在什么时候使用–force之前都要思考清楚自己在干什么。 Branch我觉得git很强大的一个功能就是对分支的管理，在不同分支中切换可以让项目的代码得到更有效的管理，例如在main主分支中保存可以稳定运行的版本，在另一个dev分支中保存正在开发的非稳定版，后续改进之后可以将dev分支合并到main分支中去。如果更新过后的主分支依然出现问题，也是可以通过回滚的方式回到之前某个稳定的版本。分支的创建也非常简单 12git branch namegit checkout name 切换后git所有的操作将在新的分支进行 .gitignore顾名思义，肯定是让git去忽略某些项目，比如文件夹，或者是单个文件，添加到gitignore之后git将不在追踪这些文件的变化，因此我们可以将例如npm庞大的node_modules这种文件夹添加到其中，或者是编译器调试产生的临时文件，优化仓库的存储结构。 1git status 使用该命令看查目前项目的改动 123456On branch devUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) b.cppnothing added to commit but untracked files present (use &quot;git add&quot; to track) git监控到了文件b.cpp的产生，我们将b.cpp添加到.gitignore中 12On branch devnothing to commit, working tree clean 再次使用git status看查，发现b.cpp已经不再被监控了，在.gitignore中还可以使用文件夹名忽略整个文件夹的项目，或者使用通配忽略包含特定后缀名的文件等。 End随着开发工具的现代化，很多时候我们已经用不到这些git命令了，很多繁琐的命令早已被图形化的界面取代，但不乏还有git爱好者们做出的努力，如lazygit等工具。当你接收一台崭新的服务器时，这些命令又显得格为重要了。因此，在简便的工具的包裹下，他们背后的原理才是最值得我们去了解的，就如同学习汇编语言一样，给力我们另一种看待程序的方式。很早就像总结一下git了，拖了这么久终于写完了，后续还想再添加一些更具体的内容，希望能给初入git的同学一些启发。","link":"/2021/04/02/GitNote/"},{"title":"OJ部署debug记录","text":"学校重构之后的OJ终于进入了前后端对接的阶段，经过了一周的紧张对接环境，项目依然是(正在稳定推进的阶段)，和前端对接口的一周里，我感觉到自己之前工作的不足，在此做出反思，以后要改掉这些错误。同时在和运维一起部署的过程中，也发现了许许多多的问题，在此一并记录一下。 Access to Judger Ana In Docker因为OJ要防止恶意代码的提交，解决办法就是使用docker，为了让评测机稳定于是又要在docker里跑一个docker。直接docker run评测机，用了一下judge_test的模块，发现返回的结果全是AC，这就非常奇怪了。问了一下hr发现ana是用grpc通信的，好，没有学过，于是开始看怎么测试grpc是否正常，初步定位问题是没接上。也去docker里配了一下环境，加了工作目录，放行端口，发现还是不行。当hr进入服务器的时候，才发现真正的问题所在。直接docker pull的时候是跑的master分支的镜像，而新评测机接口是在另一个分支的。于是把锅甩给了嘎嘎豪。 NPM throw error后端采用了go语言的gin+gorm框架搭建，直接go build然后丢到后台守护进程，前端使用了vue框架，要先用npm build一下，但是我本意是想直接npm run serve的，无奈npm一直疯狂报错。最初我也是打算现在本地run serve然后只测试后台的，但是npm先是依赖问题没有解决，最后重装了全局的依赖之后发现报错有个字段为darwin-arm64，看到这个我就感觉不对劲，可能是M1芯片没有合适的包可以下载，于是才决定丢到服务器上。在服务器上也是遇到了依赖的问题，直接尝试删除所有包，包括全局包，发现一个报错，大概就是说npm要没钱了，快来funding，好家伙，我直接npm uninstall * --no-fund删除了所有依赖，然后重新npm install，跑完之后在此run serve，显然还是不行，问了王哥之后他给出了一个解决办法，先build然后用nginx反代到build之后生成的dist文件夹中。于是开始build，很不错，这回没有报错。于是开始了nginx反代。 Nginx服务器没有绑定域名，因此直接将服务器的某个端口直接映射到前端渲染出来的dist文件夹中去，需要现在安全组放行端口，这里就不得不提一下宝塔界面了，最初接触服务器的时候感觉宝塔确实很方便，今天运维也吐槽了一下，有些地方宝塔反而做复杂了，我就感觉上传或者下载文件比较方便，懒得用ftp。还不得不提yum包管理器是我用过最难用的，不如pacman，也没apt包全，但是总不能在服务器上跑arch吧 Orz。在宝塔上装了Nginx，开始做反代。先是监听一下888端口,并反代/请求到dist文件夹,设置首页为index.html 123456server { listen 888; index index.html index.htm index.php; root /root/dev/OnlineJudge/front_end/dist;} 好，重载一下nginx的配。咦，发现403 forbidden，运维猜测是nginx没有权限访问那个目录。这就开始打算直接chmod 777了，仔细一看发现，没改nginx配置里的user。 1user root root; 正常情况下建议分一个用户单独给nginx。然后发现访问首页是空白内容，打开F12看看，发现是js和css的请求全阻塞了，又去看了一眼nginx的配置，发现正则匹配的js和css文件目录不对。 123456789 location ~ .*\\.js?${ root /root/dev/OnlineJudge/front_end/dist;}location ~ .*\\.css?${ root /root/dev/OnlineJudge/front_end/dist;} 这里要注意，一开始我是分别代理到/dist/js和/dist/css文件夹的，这样是不对的，因为请求的uri里是带有js和css字段的，于是就造成了路径不对，成了/js/js/**。至此，首页可以成功进入了。开始测试喜闻乐见的登录环节，发现请求没发出去，前端的请求之前是发送到远程服务器的，现在应该是访问本机localhost，于是进行代理转发请求 1234location /api{ proxy_pass http://127.0.0.1:5000;} 终于可以登录了。到了八点多，感觉要下班了，又发现后台登录不进去了，又发现是只有我自己的chrome登录不进去，看日志的报错是interface提取的时候出问题了，uint和int之间产生了冲突，但是感觉事情没有那么简单，定位到出错的代码之后，发现异常是用_接收的，于是又对id打了log，再次运行。这个id怎么这么熟悉。原来是前端的session里的id，看来是因为前台后台共用了session，导致id混用了。 End此时已经到了晚上八点多了，看似已经解决了不少bug，但是很多问题都是和OJ无关的配置问题，真正的debug才刚刚开始。 项目正在稳定的向前推进。","link":"/2021/04/03/debugnote/"},{"title":"三种插值方法及实现","text":"插值方法插值属于数值分析领域中的一种方法，是一种通过已知的离散的数据点，来拟合原函数根据给定的自变量估算因变量的方法。 常用的插值方法有很多，本文章给出三种常见的插值方法的实现。 使用语言: Python 使用下面的数据，预测函数在x=1处的值 12x = np.array([0.5, 0.6, 0.4, 0.7])y = np.array([-0.6931, -0.5108, -0.9163, -0.3567]) 线性插值线性插值及求一次多项式$p(x)$，满足$p(x_0), p(x_1) = y_1$可以根据点斜式方程求解即 $p(x) =y_0 \\frac{y_{1}-y_{0}}{x_1-x_0}(x-x_0)$还可以将公式整理成如下形式 $p(x) = y_0 \\frac{x - x_1}{x_0 - x_1} + y_1 \\frac{x- x_0}{x_1 - x_0}$ 我们令这里的$l_0(x)=\\frac{x-x_1}{x_0 - x_1}, l_1(x)=\\frac{x-x_0}{x_1-x_0}$ 将其线性组合之后即为 $p(x)=y_0 l_0(x)+y_1 l_1(x)$ 是Lagrange插值的特殊形式 此处给出线性插值的代码实现： 1234567891011121314151617import numpy as npdef linear(x, y, x0): ''' x : 为横坐标数组 y : 为纵坐标数组 x0: 为需要预测点的横坐标 res: 预测结果 ''' res = y[1] + (y[1] - y[0])*(x0 - x[1])/(x[1] - x[0]) # 根据公式计算结果 return resx = np.array([0.5, 0.6, 0.4, 0.7])y = np.array([-0.6931, -0.5108, -0.9163, -0.3567])answer = linear(x, y, 1)print(np.around(answer, 4)) # 保留四位小数 Largrange插值根据Lagrange插值基函数$l_k(x)$，其满足如下性质当$i=k,l_k(x_i)=1$ 当$i\\not ={k}, l_k(x_i) = 0$ 其中$l_k(x) = \\prod_{i=0,i \\not ={k}}^{n} \\frac{x-x_i}{x_k-x_i}$ 可以得到$p(x)=y_0 l_0(x) + y_1 l_1(x) + … + y_n l_n(x)$ $p(x)$满足$p(x_i)=y_i, i = 0,1,…,n$ 即根据插值结点确定的方程，可以使得$p(x_i)=y_i$，是一种可行的插值方法，极大的提高了插值精度。 并且当只有两个插值结点时，Lagrange插值就退化成了线性插值，当有三个结点时，退化成抛物线插值。 12345678910111213141516171819202122232425import numpy as npfrom matplotlib import pyplot as pltdef largrange(x, y, x0): ''' x : x数组 y : y数组 x0: 预测点横坐标 res: 预测结果 ''' n = len(x) res = 0 for i in range(n): param = np.append(x[:i], x[(i+1):]) # 获得除去xi的所有横坐标 numerator = (x0 - param).prod() # 分子，使用prod求出矩阵中所有元素的积 denominator = (x[i] - param).prod() # 计算分母 res += y[i]*numerator/denominator # 根据公式计算当前步骤对答案的贡献 return resx = np.array([0.5, 0.6, 0.4, 0.7])y = np.array([-0.6931, -0.5108, -0.9163, -0.3567])answer = largrange(x, y, 1)print(np.around(answer, 4)) 运行结果：0.0634 Newton插值我们引入差商的概念，设有函数$f(x), x_0,…,x_n$ $f[x_i, x_j] = \\frac{f(x_j)-f(x_i)}{x_j - x_i}$ 称为$f(x)$关于点$x_i, x_j$的一阶差商 $f[x_i, x_j, x_k] = \\frac{f[x_j, x_k] - f[x_i, x_j]}{x_k - x_i}$ 称为$f(x)$关于点$x_i， x_j， x_k$二阶差商 我们可以得到差商的一般定义，对于k阶差商 $f[x_0, x_1, …, x_k] = \\frac{f[x_1, …, x_k] - f[x_0, …, x_{k-1}]}{x_k - x_0}$计算差商可以通过差商表来计算 $x_i$ $f(x_i)$ 一阶差商 二阶差商 三阶差商 … n阶差商 $x_0$ $f(x_0)$ $x_1$ $f(x_1)$ $f[x_0, x_1]$ $x_2$ $f(x_2)$ $f[x_1, x_2]$ $f[x_0, x_1, x_2]$ $x_3$ $f(x_3)$ $f[x_2, x_3]$ $f[x_1, x_2, x_3]$ $f[x_0, x_1, x_2, x_3]$ … … … … … … $x_n$ $f(x_n)$ $f[x_{n-1}, x_{n}]$ $f[x_{n-2}, x_{n-1}, x_{n}]$ $f[x_{n-3}, x_{n-2}, x_{n-1}, x_{n}]$ $f[x_0, x_1, …, x_n]$ 将对角线上的差商值用来构造插值函数 $f(x) = f(x_0) + f[x_0, x_1](x- x_0) + f[x_0, x_1, x_2](x - x_0)(x - x_1) + … + f[x_0, …, x_n](x - x_0)…(x - x_{n-1}) + f[x,x_0,x_1,x_2,…,x_n](x - x_0)…(x - x_{n})$ 其中$R(x) = f[x,x_0,x_1,x_2,…,x_n](x - x_0)…(x - x_{n})$为插值余项 综上，牛顿插值的最终表达式为 $R(x) = N(x)+R(x)$ 牛顿插值的插值基函数有可继承的特点，可以优化计算方法 直接利用上一次的计算结果增量更新 123456789101112131415161718192021222324252627282930313233343536373839import numpy as np# 计算差商表第j列的元素def GetColumRes(arr, j): n = len(arr[:,0]) colum = np.zeros(n) for i in range(j-1, n): colum[i] = (arr[i, j-1] - arr[i-1, j-1])/(arr[i, 0] - arr[i-j+1, 0]) return colum# 计算差商def CalculateDividedDiffernces(x, y): n = len(x) arr = np.zeros((n, n+1)) arr[0:n, 0] = x arr[0:n, 1] = y for i in range(2, n+1): # 获得差商表第i列的元素 arr[:, i] = GetColumRes(arr, i) print(arr) return arrdef newton(x, y, x0): res = y[0] n = len(x) factor = 1 DD = CalculateDividedDiffernces(x, y) for i in range(1,n): # factor因数迭乘 factor *= (x0-x[i-1]) # 取出对角线上的元素进行计算 res += DD[i, i+1]*factor return resx = np.array([0.5, 0.6, 0.4, 0.7])y = np.array([-0.6931, -0.5108, -0.9163, -0.3567])answer = newton(x, y, 1)print(np.around(answer, 4)) 运行结果： 差商表 [ 0.5 -0.6931 0. 0. 0. ] [ 0.6 -0.5108 1.823 0. 0. ] [ 0.4 -0.9163 2.0275 -2.045 0. ] [ 0.7 -0.3567 1.86533333 -1.62166667 2.11666667] 运行结果0.0634","link":"/2021/04/19/newtown/"},{"title":"数值积分方法","text":"数值积分应用背景：微积分的基本计算公式为经典的牛顿莱布尼茨公式，但是作为计算机来说，计算原函数等操作过于困难，因此需要其他方法进行优化，代替牛顿莱布尼茨公式进行计算，本文将分享两种求积公式及其代码实现。 使用语言： Python-Numpy 使用两种方法计算$f(x)=sin(x)$在[1,2]上的积分 复化梯形的递推公式由梯形公式改进，将区间[a, b]等分为n个小区间$[x_i, x_{i+1}]$ $\\int_{a}^{b}f(x)dx=\\sum_{i=0}^{n-1}\\int_{x_i}^{x_{i+1}}f(x)dx\\approx \\frac{h_i}{2}[f(x_i)+f(x_{i+1})]$ 根据梯形公式化简为区间端点值组合 将求和公式展开，分离出左右端点 得到最终的化简结果 $T_n = \\frac{h}{2} [f(a)+2\\sum_{i=1}^{n-1}f(x_i)+f(b)]$ 但是该方法的步长太小的话会导致计算次数太大，步长太大又难以保证效率 采用区间不断对分的方法，取$n = 2^k$，反复使用复合求积公式 $T^{(k)}=\\frac{1}{2}T^{(k-1)}+\\frac{h_{k-1}}{2}\\sum_{i=0}^{2^{k-1}-1}f(a+ih_{k-1} + 0.5h_{k-1})$ 其中$h_{k-1} = \\frac{b-a}{2^{k-1}}$ Code 1234567891011121314151617181920212223242526272829import numpy as npdef f(x): return np.sin(x)def Calc(): eps = 1e-7 Flag = True l = 1.0 r = 2.0 h = r - l t1 = 1.0*(h/2)*(1+f(r)) t2 = 0.0 while Flag: sum = 0 x = l + h/2 while x &lt; r: sum += f(x) x += h t2 = t1/2 + h*sum/2 h /= 2.0 if abs(t2 - t1) &lt; abs(eps): Flag = False t1 = t2 res = t2 return resanswer = Calc()print(answer, 6) 0.9564492180077249 Romberg 算法基于梯形递推公式，将上一级递推公式的结果进行线性组合，得到Simpson公式，再对Simpson公式结果进行线性组合得出Cotes公式结果，最后对Cotes公式线性组合得出Romberg算法的递推公式 该方法为Richardson外推法 $T_{m}^{(k)}=\\frac{4^m T_{m-1}^{(k+1)} - T_{m-1}^{(k)}}{4^m - 1}$ k为Romberg算法的阶数，Romberg算法具有收敛性，一般情况下我们取四阶 k = 3进行计算就可以满足精度要求 123456789101112131415161718192021222324252627282930313233import numpy as npdef f(x): return np.sin(x)# 计算梯形公式的结果def trapezcomp(l, r, k): h = (r - l)/k x = l Sum = f(x) for i in range(1, k): x += h Sum += 2*f(x) return (Sum + f(r))*h*0.5def romberg(x, y, n): ''' x : 积分下限 y : 积分上限 n : Romberg算法求解的阶数 ''' I = np.zeros((n, n)) for i in range(0, n): # 获得梯形公式的结果 I[i, 0] = trapezcomp(x, y, 2**i) for j in range(0, i): # 使用加速递推公式计算 I[i, j+1] = (4**(j+1)*I[i, j] - I[i-1, j])/(4**(j+1)-1) # 返回4阶Romberg算法的递推值 return I[n-1, n-1]answer = romberg(1.0, 2.0, 4)print(answer) 运行结果：0.9564491426149814","link":"/2021/04/23/integration/"},{"title":"常微分方程初值问题求解方法","text":"常微分方程初值问题常微分方程描述了不同变量之间的变化关系，通过该关系我们可以确定变量之间的具体函数关系，但是微分方程不一定总是可解的，并且有些求解起来相当困难。给出积分曲线初始位置的状态，求解需要预测点的状态，为常微分方程的初值问题，我们可以在求解微分方程即的情况下对结果做出复合精度要求的预测。 以$f(x) = \\sqrt{1+2x}$为例 有$y’=\\frac{dy}{dx}=y-\\frac{2x}{y}$ 本文给出几种算法的原理与实现。 Euler方法及其改进从初始点开始，根据不同离散点的导数值对曲线进行预测，导数值可以通过对ODE的化简求解，做出一条折线图，最终曲线会逼近预测值。 该方法有明显的缺点就是在每一步做出抉择时，只考虑了当前的状态，并没有考虑后面的状态，因此必然会造成较大的误差，因此采用下一个结点的导数值进行修正。 具体流程如下 选取一定的步长h，一般为区间的n等分 预测下一个值$\\overline{y}_{i+1} = y_i + hf(x_i, y_i)$ 校正预测值$y_{i+1} = y_i + \\frac{h}{2}[f(x_i, y_i)+f(x_{i+1}, \\overline{y}_{i+1})]$ 改写成平均化形式 $y_p = y_i +hf(x_i, y_i)$ $y_c = y_i + hf(x_{i+1}, y_p)$ $y_{i+1} = \\frac{1}{2} (y_p+y_c), i =0,1,2,3,…,n-1$ 12345678910111213141516171819202122232425262728293031323334353637import numpy as np# 常微分方程化简def ode(x, y): return y - 2 * x / ydef f(x): return np.sqrt(1+2*x)def Euler(bound, start): ''' bound : 预测边界值 start : 起始点 ''' h = 0.1 # 对步长h等分 n = int(bound/h) x = np.zeros(n) y = np.zeros(n) sample = np.zeros(n) for i in range(0, n): # 获取均分后的所有点 x[i] = 0+i*h # 生成标准值做对比 sample[i] = f(x[i]) y[0] = start for i in range(1, n): # 预测值 yp = y[i-1] + h*ode(x[i-1], y[i-1]) yc = y[i-1] + h*ode(x[i], yp) # 使用预测值求加权平均值 y[i] = (yp+yc)/2.0 return y, sampleanswer,sample = Euler(2, 1)print(answer)print(sample) 运行结果： 标准值 [1. 1.09544512 1.18321596 1.26491106 1.34164079 1.41421356 1.4832397 1.54919334 1.61245155 1.67332005 1.73205081 1.78885438 1.84390889 1.8973666 1.94935887 2. 2.04939015 2.0976177 2.14476106 2.19089023] 预测值 [1. 1.09590909 1.18409657 1.26620136 1.34336015 1.41640193 1.4859556 1.55251409 1.61647478 1.67816636 1.7378674 1.79581974 1.8522386 1.90732042 1.96124939 2.01420304 2.06635728 2.11789132 2.16899248 2.21986124] Runge-Kuta法Runge-Kuta法在思想上与之前的方法大致相同，都是通过若干个斜率的加权平均值来做出下一步选择。此处只给出常用的四阶Runge-Kuta的处理方式。 $K_1=f(x_i,y_i)$ $K_2 =f(x_i + \\frac{h}{2}, y_i + \\frac{h}{2}K_1)$ $K_3=f(x_i + \\frac{h}{2}, y_i + \\frac{h}{2}K_2)$ $K_4=f(x_i + h, y_i + hK_3)$ $y_{i+1}= y_i + \\frac{h}{6}(K_1+K_2+K_3+K_4)$ 1234567891011121314151617181920212223242526272829303132333435363738import numpy as npfrom matplotlib import pyplot as pltdef ode(x, y): return y - 2 * x / ydef f(x): return np.sqrt(1+2*x)def RungeKutta(bound, start): ''' bound : 计算边界 start : 初始值f(0) ''' h = 0.1 n = int(bound/h) x = np.zeros(n) y = np.zeros(n) sample = np.zeros(n) for i in range(0, n): x[i] = 0+i*h sample[i] = f(x[i]) y[0] = start for i in range(1, n): # 求各个点的斜率 k1 = ode(x[i-1], y[i-1]) k2 = ode(x[i-1] + h/2, y[i-1] + h/2*k1) k3 = ode(x[i-1] + h/2, y[i-1] + h/2*k2) k4 = ode(x[i-1] + h, y[i-1] + h * k3) # 对斜率求平均值并进行预测 y[i] = y[i-1] + h/6*(k1 + 2 * k2 + 2 * k3 + k4) plt.show() return y, sampley, sample = RungeKutta(2, 1)print(y)print(sample) 运行结果 ：预测值 [1. 1.09544553 1.18321675 1.26491223 1.34164235 1.41421558 1.48324222 1.54919645 1.61245535 1.67332466 1.73205637 1.78886107 1.84391692 1.89737622 1.9493704 2.00001382 2.0494067 2.09763752 2.14478481 2.1909187 ] 标准值 [1. 1.09544512 1.18321596 1.26491106 1.34164079 1.41421356 1.4832397 1.54919334 1.61245155 1.67332005 1.73205081 1.78885438 1.84390889 1.8973666 1.94935887 2. 2.04939015 2.0976177 2.14476106 2.19089023]","link":"/2021/04/23/ode/"},{"title":"迭代法求解线性方程组","text":"求解线性方程组在线性代数中，有一类经典问题，就是求解线性方程组，我们熟知的解法有高斯消元法，但是高斯消元法属于直接求解的方法，不适合编程计算，因此引入更适合计算机求解的迭代法。 以线性方程组： $$ \\left[ \\begin{matrix} 10 &amp; -1 &amp; -2 \\ -1 &amp; 10 &amp; -2 \\ -1 &amp; -1 &amp; 5 \\end{matrix} \\right] x = \\left[ \\begin{matrix} 7.2 \\ 8.3 \\ 4.2 \\end{matrix} \\right]$$为例 Jacobi迭代法考虑线性方程组$Ax=b$ 用L和U分别表示严格下三角矩阵和严格上三角矩阵 可以利用迭代公式 $x^{k+1}=D^{-1}(b-(L+U)x^{k}))$ 进行迭代求解，可以通过精度控制迭代次数，还需要控制迭代是否收敛，不然迭代次数再多也无法求解。 迭代法需要给定解列向量的初值，因此初值的选取也很重要。 1234567891011121314151617181920212223import numpy as npdef Jacobi(A, B, N, x): # Ax=B N为迭代次数 # 获得对角矩阵的数组 D = np.diag(A) # 获得L+U矩阵，减去对角矩阵即可 # diagflat为D数组转为对角矩阵 R = A - np.diagflat(D) # R = L + U print(R/D) for i in range(N): # 迭代过程，可以直接/D表示逆矩阵 x = (B - np.dot(R, x))/D return xA = np.array([[10, -1, -2], [-1, 10, -2], [-1, -1, 5]] )B = np.array([7.2, 8.3, 4.2])# 设定迭代初始值x = np.array([1, 1, 1])answer = Jacobi(A, B, 30, x)print(answer) 求解结果为x = [1.1, 1.2, 1.3] Gauss Seidel迭代法Gauss Seidel法使用了另一种迭代格式，获得了快的收敛速度 首先我们利用迭代求解的特性，新得到的值总会比老值更优，因此使用新值来进行迭代，即 $x^{k+1}=D^{-1}(b+Lx^{k+1}+Ux^k)$ 化简 $x^{k+1}=(D-L)^{-1}(Ux^k+b)$ 1234567891011121314151617181920212223242526import numpy as npdef GaussSeidel(A, B, N, x): # 下三角矩阵 L = np.tril(A) # 严格上三角矩阵 U = A - L # 获得对角矩阵 D = np.diagflat(np.diag(A)) LL = L - D # x^{k+1} = (D + L)^-1 (b - Ux^{k}) # 输出迭代矩阵 print(np.dot(np.linalg.inv(D-LL), U)) for i in range(N): # 使用linalg包中的inv函数求出L矩阵的逆矩阵 # 使用上述迭代公式求解 x = np.dot(np.linalg.inv(L), B - np.dot(U, x)) return xA = np.array([[10, -1, -2], [-1, 10, -2], [-1, -1, 5]] )B = np.array([7.2, 8.3, 4.2])# 设定迭代初始值x = np.array([1, 1, 1])answer = GaussSeidel(A, B, 30, x)print(answer) 解得x = [1.1, 1.2, 1.3]","link":"/2021/04/25/matrix/"},{"title":"方程求根的迭代法","text":"迭代法求解方程的根求解方程的根，即$f(x)=0$的数值解等问题，对于经典的二次方程等函数我们可以直接进行求解，但是对于超越方程我们不能用常规方法进行求解。因此我们可以通过使用计算机实现某些求解算法进行计算。 选取样例 $f(x) =x^3 - x - 2$ $\\frac{dy}{dx} = 3x^2-1$ 求解$f(x)$在[1, 2]上的零点 二分法在高中数学课本我们就接触过二分法求函数零点，根据零点存在性定理，可以保证我们得到符合要求的一个根，但是该方法局限性太大，只能求解区间内的一个根。 大致流程如下 先确定要求解的区间[x, y]，然后不断对区间进行二分，根据精度要求判断根是否合法，再根据中点值与端点值的符号是否相同缩小二分范围。 $if \\ f(mid)\\times f(l) &gt; 0$ $let \\ l = mid$ $or \\ r = mid$ Code 123456789101112131415161718192021222324import numpy as npimport math as mdef f(x): return x**3-x-2def binary(x, y): res = 0 eps = 1e-3 h = 1e-3 l = x r = y while l &lt;= r: mid = (l+r)/2 if abs(f(mid)-0) &lt; eps: return mid if f(mid)*f(x) &gt; 0: l = mid else: r = mid return -1answer = binary(1.0, 2.0)print(np.around(answer, 4)) 运算结果为1.5215 牛顿迭代法牛顿迭代法的基本思想为将非线性方程线性化，选取一个初始点，做切线交与x轴一点，然后继续该操作，直到根收敛或者达到精度要求。 基本流程为 取任意的迭代初始值$x_0$ 计算 $x_1 = x_0 - \\frac{f(x_0)}{f’(x_0)}$ 判断收敛性：如果$|x_1 - x_0|&lt; \\epsilon \\ or |f(x_1)-0| &lt; \\epsilon$ 令$x_0 = x_1$，保存上一步结果，继续迭代 Code 123456789101112131415161718192021222324import numpy as npimport math as m# f(x) = x**3 - x - 2# df/dx = 3x**2 -1def df(x): return 3*x**2 - 1def f(x): return x**3 - x - 2def newton(x): eps = 1e-7 x0 = x x1 = x0 - f(x0)/df(x0) while abs(x1-x0) &gt; eps: t = x1 x1 = t - f(t)/df(t) x0 = t return x1answer = newton(1.0)print(np.around(answer, 4)) 运算结果为1.5214","link":"/2021/04/25/equtaion/"},{"title":"Bilibili视频网站排行榜评分的线性回归分析","text":"Bilibili（哔哩哔哩）是当下最热门的视频播放网站，人们在该网站对视频进行浏览，会根据自己喜好对视频进行点赞、投币、收藏、分享、回复等操作，Bilibili同时还有一个排行榜机制，记录了近期比较热门的视频，并给出了一个评分，排行榜的排序规则即根据该评分，本文将根据这些排行榜视频的各项数据，进行线性回归分析，结合实际情况找出对评分影响最大的数据。 Bilibili提供了获取排行榜数据的API，因此我们可以利用该API获取实时的排行榜数据，获取的数据为json格式，经过解析，已将数据保存至Bilibili.csv文件中。 本文的思路即为多元线性回归，在统计学中，线性回归（linear regression）是利用称为线性回归方程的最小二乘函数对一个或多个自变量和因变量之间关系进行建模的一种回归分析。这种函数是一个或多个称为回归系数的模型参数的线性组合。只有一个自变量的情况称为简单回归，大于一个自变量情况的叫做多元回归（multivariable linear regression）。 完成了对各个自变量权重的计算，找出了对评分影响权重最高的因素，并得到了验证。 数据获取在哔哩哔哩官网首页处获取排行榜信息的API，得到为 https://api.bilibili.com/x/web-interface/ranking/v2?rid=0 请求参数为 rid 分类，0代表全部分类 返回格式为json格式，json中的data字段为视频信息数组。 为了防止请求次数过多增加服务器压力，导致本机IP禁止访问哔哩哔哩，先将请求的response保存到data.txt文件中。 使用python的json包进行解析 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758{&quot;aid&quot;: 375696064,&quot;videos&quot;: 1,&quot;tid&quot;: 17,&quot;tname&quot;: &quot;单机游戏&quot;,&quot;copyright&quot;: 1,&quot;pic&quot;: &quot;http://i0.hdslb.com/bfs/archive/85005893d4c4959ff096d6fb061040e223842bcb.jpg&quot;,&quot;title&quot;: &quot;史上最骚魔法师！(第二集)&quot;,&quot;pubdate&quot;: 1621566911,&quot;ctime&quot;: 1621566912,&quot;desc&quot;: &quot;本期请到了Warma参与配音！鼓掌！！！！！\\n游戏：Darkside Detective\\n第一集：BV1M64y1m7gA\\n各位如果看得开心，希望三连支持一下！&quot;,&quot;state&quot;: 0,&quot;duration&quot;: 658,&quot;mission_id&quot;: 24025,&quot;rights&quot;: {&quot;bp&quot;: 0,&quot;elec&quot;: 0,&quot;download&quot;: 0,&quot;movie&quot;: 0,&quot;pay&quot;: 0,&quot;hd5&quot;: 0,&quot;no_reprint&quot;: 1,&quot;autoplay&quot;: 1,&quot;ugc_pay&quot;: 0,&quot;is_cooperation&quot;: 0,&quot;ugc_pay_preview&quot;: 0,&quot;no_background&quot;: 0},&quot;owner&quot;: {&quot;mid&quot;: 546195,&quot;name&quot;: &quot;老番茄&quot;,&quot;face&quot;: &quot;http://i0.hdslb.com/bfs/face/bc5ca101313d4db223c395d64779e76eb3482d60.jpg&quot;},&quot;stat&quot;: {&quot;aid&quot;: 375696064,&quot;view&quot;: 1149043,&quot;danmaku&quot;: 7300,&quot;reply&quot;: 3278,&quot;favorite&quot;: 37490,&quot;coin&quot;: 98319,&quot;share&quot;: 1780,&quot;now_rank&quot;: 0,&quot;his_rank&quot;: 1,&quot;like&quot;: 210211,&quot;dislike&quot;: 0},&quot;dynamic&quot;: &quot;用魔法击败魔法&quot;,&quot;cid&quot;: 341808079,&quot;dimension&quot;: {&quot;width&quot;: 1920,&quot;height&quot;: 1080,&quot;rotate&quot;: 0},&quot;short_link&quot;: &quot;https://b23.tv/BV1jo4y117Vf&quot;,&quot;short_link_v2&quot;: &quot;https://b23.tv/BV1jo4y117Vf&quot;,&quot;bvid&quot;: &quot;BV1jo4y117Vf&quot;,&quot;score&quot;: 2446535} 通过解析json格式文件并整理得到bilibili.csv 数据处理的代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import numpy as npimport pandas as pdimport osfrom urllib.request import Request, urlopenimport urllibimport requestsimport jsondef getDataFromFile(): if not os.path.isfile('./data.txt'): raise TypeError(&quot;file not exist&quot;) text = open('./data.txt').read() return text def getResponse(url): headers = {'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.8 5 Safari/537.36'} data = requests.get(url = url, headers=headers).text return dataurl = 'https://api.bilibili.com/x/web-interface/ranking/v2?rid=0&amp;type=all'res = getDataFromFile()jsonData = json.loads(res)title = [] # 标题author= [] # up🐷view = [] # 播放量danmu = [] # 弹幕数coins = [] # 投币share = [] # 分享like = [] # 点赞score = [] # 分数favor = [] # 收藏reply = [] # 评论rank = [] # 排名cnt = 0for i in range(0, 104): temp = '' try: videoData = jsonData['data']['list'][i] score.append(videoData['score']) title.append(videoData['title']) author.append(videoData['owner']['name']) videoStat = videoData['stat'] danmu.append(videoStat['danmaku']) view.append(videoStat['view']) rank.append(videoStat['his_rank']) reply.append(videoStat['reply']) favor.append(videoStat['favorite']) coins.append(videoStat['coin']) share.append(videoStat['share']) like.append(videoStat['like']) cnt = cnt + 1 except: continueoutfile = pd.DataFrame({&quot;title&quot;: title ,&quot;author&quot;: author, &quot;rank&quot;: rank, &quot;score&quot;: score, &quot;view&quot;: view, &quot;coins&quot;: coins, &quot;favorite&quot;: favor, &quot;reply&quot;: reply, &quot;danmu&quot;: danmu})outfile.to_csv(&quot;bilibili2.csv&quot;, index = False) 数据分析数据加载 12345678910111213141516171819202122import pandas as pd # csv文件读写分析import numpy as np # 线性代数import matplotlib.pyplot as plt # 制图data = pd.read_csv('./bilibili.csv', index_col='title')# 评分score = data['score'] # 播放量view = data['view'] # 投币coins = data['coins']# 收藏favor = data['favorite']# 评论reply = data['reply']# 点赞like = data['like']# 弹幕数量danmu = data['danmu']# 分享次数share = data['share'] 绘制图像，观察数据之前的关系由图像可以得出，b站综合打分的评分和各个数据之前有一定的相关性，主要为正相关。 多元线性回归我们的目的是得到$$f(x_i) = w^{T} x_i + b $$类似的，使用最小二乘法估计w和b 利用求解公式$$ \\hat w^{} = (X^{T}X)^{-1}X^{T}y$$ 123456# 计算系数矩阵w-hatw_hat = np.dot(np.dot(np.linalg.inv(np.dot(X.T, X)), X.T), Y)# 获取b矩阵b = w_hat[-1]# 获取w系数矩阵w = w_hat[:-1] 看查w的值 1234567[[ 0.53588246] [ 2.01063732] [ 5.79443124] [-4.91889223] [17.51523907] [-3.73019387] [ 0.89537493]] 这里发现w系数矩阵中出现了负值，经检查发现该项目对应的自变量为like和reply，即视频的点赞次数和评论数，这与实际情况是不符的，猜测是因为该自变量对结果的影响过小，导致预测出现了偏差，同时发现弹幕数量对视频评分的影响过大，远超于其他参数，显然与实际生活不符，并且作为对视频质量的估计，弹幕数也的确不能作为一个重要的参数。 因此我们对弹幕数进行剔除重新进行拟合。 123456789101112131415# 获取自变量矩阵，剔除弹幕数X = data.iloc[:,[3, 4, 5, 6, 8, 9]].values# 获取因变量矩阵Y = data.iloc[:,2].values.reshape(-1,1)# 生成设计矩阵om = np.ones(X.shape[0]).reshape(-1,1)X = np.hstack((X, om))# 计算系数矩阵w-hatw_hat = np.dot(np.dot(np.linalg.inv(np.dot(X.T, X)), X.T), Y)# 获取b矩阵b = w_hat[-1]# 获取w系数矩阵w = w_hat[:-1]print(w) 得到w的值为 123456[[ 0.60269881] [ 2.82157809] [ 5.35461617] [ 3.04630747] [-3.9125348 ] [ 0.33063835]] 观察发现此时各项参数对于评分的影响已经较为接近正常水平。但是share，视频分享数对于评分的影响仍为负值，依然根据上述猜测，share对于总分的影响过小，导致拟合的结果差，因此再次剔除share字段。 1234567891011121314151617# 获取自变量矩阵，剔除弹幕数，分享数X = data.iloc[:,[3, 4, 5, 6, 9]].values# 获取因变量矩阵Y = data.iloc[:,2].values.reshape(-1,1)# 生成设计矩阵om = np.ones(X.shape[0]).reshape(-1,1)X = np.hstack((X, om))# 计算系数矩阵w-hatw_hat = np.dot(np.dot(np.linalg.inv(np.dot(X.T, X)), X.T), Y)# 获取b矩阵b = w_hat[-1]# 获取w系数矩阵w = w_hat[:-1]X_test = data.iloc[:, [3, 4, 5, 6, 9]].valuesY_predict = np.dot(X_test, w) + b 得到w矩阵为 12345[[0.59149795] [2.85961313] [4.47955342] [0.34492927] [0.35243338]] 绘制预测值与实际值图像 观察预测值与实际值的差距，发现拟合的趋势基本吻合，但仍有较大的误差 分析得出，该线性模型的拟合误差较为集中，集中在[0, 181348.81788162683]即平均误差之间。 12345[0.59149795] [2.85961313] [4.47955342] [0.34492927] [0.35243338] 根据权重分析各个数据对总分的影响，可以发现，收藏对于视频总评分的影响占比最高，其次是硬币数，播放数，说明哔哩哔哩对与视频的质量高低评判有一定的综合考量，播放量属于可以由视频制作人通过其他方式刷取，但是收藏量是由用户对于视频质量的高低做出的决定，因而更具代表性，更有说服力。反观实际观看体验中，有些视频制作人会以视频收藏满几万后，更新下一期视频，因为该项对视频的收益影响最大，更能给视频制作人带来实际收益。 本次线性回归的拟合可以较为准确的判断出各各数据对于视频评分的影响，但是对于视频评分的预测误差较大，但是仍能较准确的判断出视频评分所影响的视频排名，认为有如下原因： 数据量过少，导致拟合程度不足 评分规则非线形模型，应该更换模型 还有其他未考虑的因素如果要更准确的对视频评分进行预测，应该综合分析数据的特性，或者采用机器学习等更优秀的手段来进行求解和预测，线性回归仍有一定的局限性。","link":"/2021/07/02/bilibili/"},{"title":"127.0.0.1,localhost和0.0.0.0暨🐼一次两次的神神秘秘的debug记录","text":"前记潘达某天在本机docker部署了他的服务，但是发现无论如何都无法ping通，他冥(疯)思(狂)苦(谷)想(歌)，逛遍了GitHub上的各种issues，stack overflow上的各种回答，各种博客文章，都没有解决他的问题，直到他的mentor来到他的电脑前，一通命令猛如虎啊，发现他竟然在docker内监听了容器中的127.0.0.1的端口，那必然会访问不到，检查发现原来是在服务的config中写了magic number，让服务开在了127.0.0.1，在本地这样必然是没问题的，但是如果要与外部进行通信，那就要改成0.0.0.0了。 又是一天，潘达又部署起了他的rpc服务，想在服务器上部署一个微服务然后本机去访问，测试框架是否可以通过域名通信各个微服务，然而，服务器上启动成功，本地依然迟迟无法连接，上来就是一个curl: (7) Failed to connect to ababab.ababab port ababa: Connection refused，安全组也放行了对应的端口，然后他看到了一行127.0.0.1，但是他感觉不是这个问题，继续debug，然后再次呼叫他的mentor，希望得到帮助，还是一顿操作猛如虎，找到了那个127.0.0.1的监听服务，乐。 于是，这篇blog就诞生了。 127.0.0.1 和 localhost127.0.0.1是回路地址中的一个，在计算机中127.*.*.*被称为回路地址，所有对这些地址的请求都会让本机接收，最最重要的是，外部设备也不能通过这个地址访问到本机的服务。localhost其实是一个域名，他一般指代本机的网络，大多数机器都会默认localhost指向127.0.0.1，可以自行修改为其他地址。 0.0.0.0可能我们都会以为localhost为本地的网络地址，但实际上真正的本地网络是0.0.0.0，但是他是不能被ping通的。在服务器中，0.0.0.0并不是一个真实的的IP地址，它表示本机中所有的ipv4地址。监听0.0.0.0的端口，就是监听本机中所有IP的端口。如果服务监听在0.0.0.0，那么外部访问的所有ip都可以通过对应的端口访问这个服务。 所以问题得到了解答，如果是在本机的话，127.0.0.1的话显然是没问题的，但是如果要将服务上云或者容器，就需要进行调整，首先要避开127.0.0.1，再根据是否只允许内网ip访问进行端口映射和服务监听。 后记这两次问题前前后后折腾了半天，本想自己找到解决办法，查了不少资料后还是要寻求运维☁️的帮助，其实问题并不是很大，还是自己的知识储备不够，不能准确定位的问题的所在。另外，计网应该开始看了。🐼。","link":"/2021/07/26/localhost/"},{"title":"操作系统","text":"CSAPP读书笔记 Ch-1 宏观看一看操作系统，很多知识之前确实没了解到，值得一读 Ch1源程序 -&gt; 预处理器 (cpp) —hello.i—&gt; 编译器(ccl) —–hello.s—–&gt; 汇编器(as) —-hello.o(binary) with printf.o—&gt; 连接器 ——-&gt; 可执行二进制文件 主存：临时存储设备 DRAM组成 进程：并发执行多个进程-上下文切换 进程运行所需的所有状态信息 上下文 例如：PC和寄存器文件的当前值，主存的内容 并发执行 ：一个进程的指令和另一个进程的指令交错执行 线程：进程是由多个线程的执行单元组成 ，运行在进程的上下文中，共享同样的代码和全局数据 多线程共享数据比多进程容易 虚拟内存：对于进程，提供虚拟地址空间 包含 程序代码和数据，堆malloc 和free，共享库so，栈，内核虚拟内存为内核保留，不允许应用程序读写这个区域 基本思想：一个进程虚拟内存的内容存储在磁盘，利用主存座位磁盘的高速缓存 并发和并行： 并发：同时具有多个活动的系统 并行：用并发是一个系统运行的更快 线程级并发：在一个进程中执行多个控制流 指令级并行：流水线技术 单指令，多数据并行 SIMD并行 操作系统的抽象： 文件是对I/O设备的抽象 虚拟内存是对主存和磁盘的抽象 进程是对处理器，主存和IO设备的抽象 网络可以看做一种IO设备","link":"/2021/12/09/csapp/"},{"title":"【leetcode-179】最大数","text":"https://leetcode-cn.com/problems/largest-number/ Description给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。 注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。 Solution将数字全部转为字符串，进行逐个比较，比较规则为： 从最高位开始比较，如果第一个数字较大，则把较大的排在前面 比较后续数字，将出现更大数字的数排在前面 若数字a为数字b的前缀，或相反，则返回a+b&gt;b+a，判断如何构造可以使得数字更大 注意数字全为0的情况 sort里用lambda很香 Code12345678910111213141516171819202122232425262728class Solution {public: string largestNumber(vector&lt;int&gt;&amp; nums) { vector&lt;string&gt; nums_str; bool zero_flag = false; nums_str.clear(); for (auto num : nums) { if (num != 0) zero_flag = true; nums_str.push_back(to_string(num)); } if (!zero_flag) return &quot;0&quot;; sort(nums_str.begin(), nums_str.end(), [](const string &amp;a, const string &amp;b) -&gt; bool { if (a[0] != b[0]) { return a[0] &gt; b[0]; } for (int i = 1; i &lt; min(a.size(), b.size()); i++) { if (a[i] == b[i]) continue; return a[i] &gt; b[i]; } return a + b &gt; b + a; }); string ans = &quot;&quot;; for (auto str : nums_str) { ans += str; } return ans; }};","link":"/2021/12/09/leetcode-179/"},{"title":"【算法题】幸运数字","text":"Description给定一个数字N，给定一个数字的集合，使用集合里的数字构造出小于数字N的最大数。 如N = 23131，集合为{2, 4, 9} 则构造出22999 Solution分两种情况讨论，构造的数字长度和N一样，或者比N少一位，若长度一样，则是从头开始按照比数字N小的数构造，若长度少一位可以直接用集合中的最大数填满。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;queue&gt;const int MAXN = 1e5;const int MOD = 1e9+7;typedef long long ll;using namespace std;// 23131// 2 4 9// 22999// 229// 2// 22int N, x;vector&lt;int&gt; nums;vector&lt;int&gt; v;int maxv = -1;int main() { cin &gt;&gt; N; v.clear(); nums.clear(); while (cin &gt;&gt; x) { v.push_back(x); maxv = max(maxv, x); } int temp = N; int setNumber = v.size(); sort(v.begin(), v.end()); while (temp) { nums.push_back(temp % 10); temp /= 10; } reverse(nums.begin(), nums.end()); int number = 0; int ans = 0; bool done = true; for (int i = 0; i &lt; nums.size(); i++) { number = number*10 + nums[i]; cout &lt;&lt; &quot;number = &quot; &lt;&lt; number &lt;&lt; endl; bool find = false; for (int j = setNumber - 1; j &gt;= 0; j--) { if (v[j] &lt;= number) { ans = ans*10 + v[j]; find = true; number -= v[j]; break; } } if (!find) { done = false; break; } } cout &lt;&lt; &quot;size &quot; &lt;&lt; nums.size() &lt;&lt; endl; if (!done) { for (int i = 0; i &lt; nums.size() - 1; i++) { cout &lt;&lt; maxv; } } else { cout &lt;&lt; ans; } return 0;}","link":"/2021/12/10/luckynumber/"},{"title":"【操作系统】信息的表示和处理","text":"本章为CSAPP Ch-2的读书笔记，复习了数据的存储方式 信息存储最小可寻址内存单位 -字节byte 一般为8位的块 内存被视为一个很大的字节数组，也就是虚拟内存，每个字节用地址标识 地址的集合为虚拟地址空间 虚拟内存中包含程序的数据，指令，控制信息 十六进制表示跳 字数据大小字长为数据标称大小 字长决定了虚拟地址空间的最大大小，字长为w的机器虚拟地址范围是[0, $$2^w-1$$] 最多访问$$2^w$$个字节 32位和64位 gcc -m32可以编译32位程序 gcc -m64可以编译64位程序 寻址和字节顺序最低有效字节在前-小端法 最高有效字节在前-大端法 部分cpu支持双端法 ，但是操作系统只支持小端模式（iOS &amp; Android） 大小端的影响 网络收发统一顺序 汇编阅读字节顺序 按字节打印 字符串表示以null结尾的字符数组 每个字符使用ASCII码，在各个系统都相同，因此文本数据的表示有更高的平台独立性（than二进制数据） 终止字符0x00 UTF-8，每个字符使用一个字节来编码 布尔代数null 位运算掩码运算 掩码：表示从一个字中选出来位的集合 整数表示跳","link":"/2021/12/10/csapp-ch2/"},{"title":"【操作系统】程序的机器级表示","text":"讲解机器代码以及汇编 TODO了，有个bomb lab","link":"/2021/12/10/csapp-ch3/"},{"title":"【操作系统】系统级IO","text":"高级别的IO程序，如c中的printf和scanf，c++中的&gt;&gt;和&lt;&lt;，都依赖Unix 系统级IO CSAPP Ch-10 笔记 Unix IOLinux文件即是m个字节的序列$B_0, B_1, …, B_k, …, B_{m-1}$ 所有的IO设备（网络，磁盘，终端）被抽象为文件，输入和输出被作为相应文件的读和写进行，Linux内核只需要暴露一个简单低级的应用接口 输入和输出的统一方式: 打开文件：应用程序请求IO设备，内核返回描述符 Linux Shell创建的进程开始时有三个文件：标准输入0，标准输出1，标准错误2 改变当前的文件位置：内核存储文件位置k，初始为0，通过seek改变这个偏移量 读写文件：读为复制字节到内存，当k&gt;=m时，会触发EOF条件；写为复制字节到一个文件中，从当前位置k开始，然后更新k 关闭文件：通知内核，内核释放文件打开时创建的数据结构，释放描述符，进程终止时内核会释放打开的文件以及内存 文件 普通文件：文本文件：ASCII或Unicode字符文件，其他的都是二进制文件，对内核而言无区别，换行符\\n对应ASCII LF 目录：包含一组链接的文件，链接将文件名映射到一个文件 套接字socket：与另一个进程进行跨网络通信的文件 命名通道named pipe，符号链接，字符和块设备 绝对路径：以斜杠开始/home/test 相对路径：以文件名开始,../test 打开和关闭文件open函数打开或创建文件 返回一个文件描述符，在进程中没有打开的最小描述符几种控制参数flags 123456O_RDONLY 只读O_WRONLY 只写O_RDWR 可读可写O_CREAT 文件不存在则创建空文件O_TRUNC 存在则截断，清空O_APPEND 追加写入 mode参数控制读写权限 每个进程都有umask 访问权限为mode &amp; ~umask close(int fd)关闭文件，成功返回0，失败-1 读写文件read和write 输入的size为unsigned long类型，ssize_t为long类型，因为read和write函数需要返回-1 read和write读写遇到不足的情况： 读取时遇到EOF 从终端读文本行 读写socket：网络延迟导致read和write返回值不足 RIO包 Robust IO读取文件元数据stat和fstat函数，读取文件信息 读取目录内容opendir函数 共享文件 描述符表，每个进程之间独立 文件表，打开文件的集合，所有进程共享，包含文件位置，引用计数，指向vnode表的指针，当引用计数为0时，操作系统删除表项 v-node，进程间共享，包含stat中的信息，st mode，st size IO重定向标准输出重定向到磁盘文件 覆盖写入文件之前的内容 使用dup2函数，将终端的输出关闭，改为磁盘文件，磁盘文件引用次数+1 标准IO标准IO将打开的文件模型化为一个流，减少系统级IO操作的调用 第一次getc调用IO read函数读取到缓冲区，之后调用将缓冲区第一个字节返回给应用程序 选取IO函数问题socket中不要使用标准IO，可能会导致崩溃，使用RIO函数/Unix IO","link":"/2022/01/03/sysio/"},{"title":"编译原理笔记","text":"编译原理笔记，词法语法分析 词法分析有穷自动机 DFA$$f: K \\times \\sum \\to K$$是一个单值函数，任何输入符号都唯一的确定了下一个状态 不确定的有穷自动机 NFA至少一个初态节点，若干个终态节点DFA是NFA的特例 子集法 NFA转换为DFA对于状态集合$I$，定义两个运算 集合$I$的$\\epsilon-Closure(I)$，是一个状态集$I$中的任何状态经过任意条$\\epsilon$弧能到达的状态集合 因为当输入符号为空时，则自动机停留在原来的位置上，所以有关系$\\forall S \\in I \\ \\ , S \\in \\epsilon-Closure(I)$ 状态集合$I$的$a$弧转换，表示为$move(I,a)$，定义为状态集合J，其中$J$是所有那些可以从$I$中的某一状态经过一条$a$弧而到达的状态的全体 有关系$\\forall S_i \\in I \\ \\ , move(I,a)=f(S_1,a)\\bigcup f(S_2,a) \\bigcup f(S_3,a)…$算法流程：123456789101112let C as a set save Status-Setlet K_0 = epsilon-Closure(0)C &lt;- epsilon-Closure(K_0)while(if C have set not visit) { visit[T] = true for a in Char Set { U := epsilon-Closure(Move(T,a)) if (U not in C) { C &lt;- U } }} 经过状态重新命名可以得到DFADFA的化简化简 的DFA：没有多余状态，没有两个状态是互相等价的。DFA可以通过消除无用状态和合并等价状态二转换成一个与之等价的最小状态的DFA 无用状态：从开始状态触发，任何输入串都无法到达 或者从这个状态没有通路到达终态![[Pasted image 20211230203930.png]]如s4，s6，s8，可以直接消除 DFA中的状态等价条件： 一致性条件-状态s和t必须同时为可接受状态或不可接受状态 蔓延性条件-对于所有输入符号，状态s和t必须转换到等价的状态 分割法分解DFA状态：步骤： 先将终态和非终态分割，作为两个子集，作为一个划分 在划分中对每个子集加上可输入字符，将可区别的状态拆分，得到新的划分 重复直到划分不可以再分割 化简后的DFA便于在计算机上实现 由DFA化简为正规式很简单缩缩缩 由正规式生成NFA$L(G)$表示文法G产生的语言的集合$L(G1) = L(G2)$ 则两个文法等价反正就是构造一个等价的$\\mathbb{NFA}$ 语法制导按照语法结构构造将正规式分解为子表达式 闭包：终态输入epsilon到达初态分解方式不唯一可以从头开始，也可以分部进行 处理步骤： 如$r_1 r_2$，顺序拼接两个NFA 如$r1^*$处理闭包，终态输入epsilon链接到初态 如$r_1|r_2$，由初态输入epsilon到两个NFA，由两个NFA输入epsilon到达终态 语法分析自顶向下文法特点： 每个产生式右部都由终结符号开始 若两个产生式都由相同的左部，右部都由不同的终结符开始分析过程是唯一的 FIRST集$FIRST(\\alpha)={以\\alpha为左部的，产生式右部的第一个非终结符集合}$为a的开始符号集 FOLLOW集对于上下文无关文法，S是开始符号$FOLLOW(A)={状态A后跟符号}$若A可以引导终止epsilon ，则加入#到FOLLOW集 构造算法对文法中每一非终结符A，构造FOLLOW(A)的算法如下：反复使用如下规则，直至FOLLOW集不再增大为止。⑴若A是文法的开始符号,则把输入结束符＃加入FOLLOW(A)中；⑵若B→αAaβ,a是终结符,则把a加入FOLLOW(A)中；⑶若B→αAXβ,X是非终结符,则把FIRST(Xβ)加入FOLLOW(A)中；⑷若B→αA或B→αAβ,且β可以推导至ε，则把FOLLOW(B)加入FOLLOW(A)中。 SELECT集$SELECT(A \\to a)=(FIRST(a)-{\\epsilon})\\bigcup FOLLOW(A)$ LL(1)文法：第一个L表示自顶向下分析是从左到右扫描输入串，第二个L表明分析过程中将用最左推导，1表明只需要向右看一个符号便可以决定如何推导。充要条件:对于每个非终结符A，的两个不同产生式$SELECT(A \\to \\alpha)\\bigcap SELECT(A \\to \\beta)=\\varnothing$ 非LL(1)文法到LL(1)文法的等价转换LL(1)文法的性质：① LL(1)文法是无二义性的；② LL(1)文法不含左递归；③ LL(1)文法没有公共左因子。 消除左递归消除回溯：提取左公因子改造成LL1文法 消除直接左递归：例如： A→Aα|β对A引入一个新的非终结符A′，把上式改写为：A →βA′A′→αA′|ε例2：E→E +T | TT→T * F | FF→i |（E）改造为E→TE′E′→+T E′|εT→FT ′T′→* FT′|εF→i |（E） 消除间接左递归把式子带入，然后按照消除直接左递归的方法去消除S → Aα|β ⑴A → Sγ ⑵得到S → Sγα|β ⑶消除左递归S → βS′S ′→γαS′|ε","link":"/2022/01/02/compiler/"},{"title":"【操作系统】网络编程","text":"承接Unix I/O这一章节，了解网络如何构建以及客户端和服务器如何通信，socket函数相关内容的学习 CSAPP Ch-11 笔记 CS编程模型客户端服务器模型 一个服务器进程，多个客户端进程 基本操作是事务transaction 有四步 客户端向服务器发送请求，发起一个事务 服务器解释请求，用响应的方式操作资源 服务器返回响应，等待下一个请求 客户端接受响应并处理 网络网络是一种IO设备，是数据源和数据接收方 网络数据接收后经IO和内存总线复制到内存，双向传输 以太网Ethernet是局域网技术 电缆链接主机和集线器，集线器广播每个端口的信息到所有主机 主机发送帧frame开头的信息，包括header，随后是有效载荷，payload，网内每个主机都可以见，只有目的主机读取 桥接以太网，主机…-集线器-桥-桥-集线器-…主机，网桥会根据通信需要来选择是否转发帧到其他网桥 连接多个局域网使用路由器 协议解决网络传输中的差异，提供命名机制（网络地址）和传输机制（包头+有效载荷） 数据发送过程： 主机A通过系统调用从虚存加载数据到内核缓冲区 主机A上的协议软件添加互联网包头和接口帧头，互联网包头指向主机B，接口帧头指向主机LAN1。是封装关系。帧头的包数据为互联网包头以及数据，帧头为其自己的互联网包头 LAN1适配器复制数据到网络 路由器读取数据猴传送到协议软件 协议软件读取目标互联网地址，作为路由表的索引转发到对应的LAN2适配器 LAN2适配器复制帧到网络 到达主机B，从适配器读取帧，传输到协议软件 协议软件去除包头和帧头，读取数据，主机B通过系统调用拷贝数据到虚拟地址空间 全球IP客户端（用户）-【socket接口系统调用】-TCP/IP（内核）-【硬件接口，中断】-网络适配器（硬件）-全局IP因特网 使用socket接口函数和Unix IO函数通信，socket函数为系统调用，调用内核的TCP/IP函数 TCP/IP是一个协议族，IP协议提供命名方法和传递机制，数据报 IP机制不可靠，数据报丢失不会自动恢复 UDP UNreliable datagram protocol，不可靠数据报协议对其进行了扩展，包可以在进程之间传递，而不是主机之间 TCP是基于IP的协议，进程间可靠的全双工连接 因特网的特性： 主机集合映射到32位ip地址 ip地址映射为一组域名 主机上的进程能够通过连接其他主机的进程通信 ipv4和ipv6： version 4：32位地址 version 6：128位地址 ip地址32位无符号整数，8*4 TCP/IP统一了字节顺序，大端法 使用点分十进制表示，Linux查看主机地址 1hostname -i 域名一级域名mil，edu，gov，com，cn 二级域名whut.edu hosts文件手工维护ip和域名的映射 DNS，domain name system Linux使用nslookup查看域名ip 1nslookup baidu.com 通常域名和ip一一对应，多个域名也可以对应同一ip，泛域名cs.whut.edu, ee.whut.edu 多个域名可以映射到同一组的多个ip，如www.twitter.com和twitter.com映射到199.16.156.* 因特网连接客户端和服务器在连接上发送和接收字节流来通信，点对点，全双工，可以同时双向流动 socket是连接的端点，每个socket都有socket地址，由地址:端口构成，十六位端口号0-65535 客户端发起请求时，客户端socket地址端口由内核自动分配，临时端口；服务器的为默认端口 web使用80（http），电子邮件地址使用25（SMTP） 可以通过/etc/services看查知名服务默认端口 一个连接两端的socket地址是唯一确定的，socket pair，格式(cliaddr:cliport, servaddr:servport)，即(客户端IP:客户端端口,服务器IP:服务器端口) socket接口一组函数实现，和Unix IO配合创建网络应用 流程： 客户端getaddrinfo-&gt;socket-&gt;connect发送连接请求-&gt;rio_writen-&gt;rio_readlineb-&gt;close发送EOF 服务器getaddrinfo-&gt;socket-&gt;bind-&gt;listen-&gt;accept接受请求-&gt;rio_readlineb读客户端的write-&gt;rio_writen写入response-&gt;rio_readlineb读取EOF-close socket地址结构对于Linux内核，socket就是一个有描述符的打开文件 socket地址存放与sockaddr_in，包含AF_INET，sin_port为16位端口号，sin_addr为32位ip地址，都是以大端法存放 socket函数客户端和服务器使用socket函数创建socket描述符 1clientfd = Socket(AF_INET, SOCK_STREAM, 0); AF_INET表示使用32位IP地址，SOCK_STREAM表示该socket为连接端点 该函数返回的描述符为部分打开的，不能读写，将有客户端完成打开socket的工作 connect函数客户端调用connect函数建立和服务器连接 connect函数会阻塞一直到连接成功建立或者错误，成功后clientfd为可读写状态 由getaddrinfo函数获取connect的参数 bind函数bind函数通知内核将addr中的服务器socket地址和socket描述符socketfd联系到一起 由getaddrinfo函数获取bind的参数 listen函数客户端是发起请求的主动实体，服务器是被动实体 默认，内核认为socket函数创建的描述符为主动socket，服务器通过listen函数通知内核描述符是被服务器使用而不是客户端 将socketfd从主动socket转化为监听socket，监听socket可以接受客户端的连接请求 参数backlog为队列中未完成的请求数量，一般设置较大的数 accept函数服务器使用accept函数等待客户端的连接请求 已经获得监听描述符connfd，listenfd，返回一个已连接描述符，该描述符可以被Unix IO读写，可以和客户端通信，将connfd返回给客户端 与监听描述符不太，监听描述符是客户端连接请求的端点，只创建一次，存在于服务器的整个生命周期 已连接描述符为客户端和服务器直接已经建立连接的端点，服务器每次接受请求都会创建 可以理解为后端程序当前已经监听系统的某个端口，此时客户端请求后后端在该基础上创建一个线程去处理该请求 主机和服务的转换 getaddrinfo将主机名、主机地址、服务名端口号转为socket地址结构返回result为一个addrinfo链表，每个结构对应一个host和service的socket地址结构客户端调用之后，遍历链表，尝试每个地址，直到socket和connect成功，建立连接服务器会遍历每个地址，直到socket和bind成功避免内存泄露，最后调用freeaddrinfo释放链表参数讲解跳了 getnameinfo将socket地址转换为主机和服务名字符串 socket接口辅助函数以上接口的整合封装 open_clientfdint open_clientfd(char *hostname, char *port) open_clientfd建立和服务器的连接，返回描述符，可以直接用于Unix IO函数读写 流程：getaddrinfo，返回addrinfo链表，遍历链表尝试建立连接，失败则关闭描述符，成功后释放链表将描述符（connfd）返回给客户端 open_listenfd服务器创建监听描述符 int open_listenfd(char *port) 遍历链表直到调用socket和bind成功 echo实例简单的单线程处理服务器 EOF概念，并不是字符，而是内核检测的一个条件，read函数返回0时，程序检测到EOF条件。磁盘文件读写，文件位置超出长度，判断EOF。网络连接，进程关闭连接其中一端，触发EOF。尝试读取通信中字节流的最后一个字节之后的字节，触发EOF。 Web服务器Web基础HTTP协议，Hypertext Transfer Protocol超文本传输协议 Web内容内容是MIME，多用途的网际邮件扩充协议，类型相关的字节序列 读取一个磁盘文件，将内容返回给客户端，磁盘文件为静态内容 运行可执行文件，将输出返回 使用URL标识每个文件 根据目录指定返回规则 根目录为网页静态内容的根目录 后缀为/时服务器自动补全默认文件名 HTTP事务使用Linux的Telnet和任何web服务器执行事务 1telnet url port HTTP请求 请求行method URI version 0个或多个请求报头 一个空的文本行终止报头列表 body 123GET / HTTP/1.1 Host: www.baidu.com 请求方法GET、POST、OPTIONS、HEAD、PUT、DELETE、TRACE URI是相应URL的后缀，包括文件名和参数 version为http版本 Mozilla文档 header可以存放多种信息，比如cookie等 host请求头在HTTP 1.1位必须，1.0中不必须。代理缓存proxy cache会使用host报头，理解为反向代理？ 客户端和服务器直接可以由代理，代理链 HTTP响应组成： 1234响应行0个或多个响应头终止报头的空行响应主体body 响应行格式 version status-code status-message version对于HTTP版本，code为 123456781**200301 400403404501505 更多状态码 响应头中应有Content-Type，告知客户端主体内容的MIME类型，Content-Length，告知主体的字节大小 传递参数 URI或者请求主体2. 服务器传递参数给子进程 fork一个子进程，调用execve在子进程上下文中执行对应的程序，通过环境变量，如QUERY_STRING, REQUEST_METHOD等信息，程序做出对应的处理 子进程的输出到哪里？CGI程序（通用网关接口Common Gateway Interface），将内容发送到标准输出，在子进程调用CGI程序之前，使用Linux dup2函数将标准输出重定向到和客户端相连的已连接描述符，CGI程序写入到标准输出的内容都会直接到达客户端 实现一个Web服务器使用c配合CSAPP提供的封装搭建一个简易的web服务器 总结本章主要了解了Unix如何建立一个网络连接，以及数据传输的具体过程，socket的设计巧妙之处，以及Linux一切皆文件的进一步理解。","link":"/2022/01/03/netprog/"},{"title":"redis实战读书笔记","text":"redis基础知识以及一些应用场景总结 基础内存数据库 优于memcached，速度上功能上 基础数据结构： String，List，Set，Hash，ZSet redis命令手册 Stringkey-value 指令GET，SET，DEL LISTkey-list 指令 LPUSH，RPUSH 推入列表的左端和右端LPUSH listname item返回值为列表长度 LPOP，RPOP，从左端和右端删除元素 LINDEX，获取列表指定位置的元素LINDEX listname 1 LRANGE，获取给定范围内的所有元素LRANGE listname 0 -10为开始索引，-1位结束索引 SETkey-set SADD, SMEMBERS, SISMEMBER, SREM HASHkey-hash table 内部也是key-value HSET, HGET, HGETALL, HDEL ZSETkey-zset ZADD, ZRANGE, ZRANGEBYSCORE, ZREM 一个文章投票系统的设计基础功能设计根据文章的发布时间和投票数量计算一个评分，根据该评分来排序和展示文章 要求：如果有一篇文章符合有趣文章的要求（支持票至少200张），放在排行榜前100位至少一天 构造分数 $$score = up\\ vote\\ *C + post\\ time$$ 常量C可以选择432 分析：一天的秒数为86400，文章达到有趣需要200票，可以利用86400/200=432来作为每个投票对得分的贡献 保存评分以及存储文章信息 使用hash结构存储文章的标题，文章的url，发布文章的用户，发布时间，得票数量等信息 关于key的设置，可以使用任意字符作为分隔符，如article:ID 使用两个zset，其中一个成员为文章id，分值为文章的发布时间，另一个成员为文章id，分值为文章的评分，使得网站可以按照发布时间和评分两种方式展示文章 防止用户重复投票，建立已投票用户名单，使用set结构，key为voted:article_id 需要用到的一些指令： ZSCORE 获取文章发布时间的有序集合，判断发布时间是否在一周内 SADD 若可投票，将用户添加到已投票的set中，操作成功则说明用户未向该文章投过票 ZINCRBY 将文章的评分增加432 HINCRBY 对hash结构中的文章投票数量进行更新 发布获取文章发布文章需要新增id，使用计数器，执行incr指令 1incr keyname 可以得到计数器++之后的值 使用sadd将发布者id添加到文章投票的用户集合中（避免自己给自己投票） 集合的过期时间为一周，一周后自动释放expire HMSET存储文章相关信息 执行zadd添加文章初始评分到保存评分的zset 执行zadd添加文章发布时间到保存时间的zset 使用HGETALL获取存储在hash中的文章结构 使用ZREVRANGE取出评分最高的文章和最新发布的文章： 使用ZREVRANGE获取文章的id 使用HGETALL获取详细内容 文章分组TODO","link":"/2022/01/03/redis/"},{"title":"【操作系统】异常控制流","text":"异常控制流 CSAPP CH-8 指令地址间的过度为控制转移，控制转移序列叫做控制流 ECF Exceptional Control Flow 异常控制流是系统实现IO，进程和虚拟内存的基本机制 ECF用于应用程序和操作系统的交互 try catch等语句基于ECF 异常硬件实现，操作系统实现 异常是控制流中的突变 比如虚拟内存缺页， 算术溢出， 除以0 事件：处理器状态变化 处理器检测到事件发生，通过异常表的跳转表，进行间接过程调用，由异常处理程序处理异常，根据异常事件类型，进行： 将控制返回给当前指令I-curr 控制返回给I-next，则没有发生异常，执行下一条指令 终止被中断的程序 异常处理每种异常分配一个异常号，是异常表中的索引 系统启动时操作系统预处理一张异常表，第k个元素包含异常k的处理程序的地址 异常表基地址寄存器存放异常表的起始地址 过程调用和异常的区别： 过程调用，跳转回处理程序前，处理器将返回地址入栈；异常为根据异常以及处理结果进行跳转 处理器会将额外处理器状态入栈 控制从用户程序转移到内核，都被压入内核栈 异常处理运行在内核模式 硬件触发异常，异常处理程序在软件中完成 异常类型中断 interrupt 来自IO设备 异步 返回到下一条指令 陷阱 trap 有意异常 同步 返回到下一条指令 故障 fault 潜在的可恢复错误 同步 可能返回当前指令 终止 abort 不可恢复错误 同步 不会返回 中断异步发生，来自处理器外部的IO设备 异步的含义：中断不是由一个专门指令造成的 异常由中断处理程序处理 trap和系统调用trap是指向指令的结果，用于在用户程序和内核之间提供一个接口，叫做系统调用 读文件，创建进程fork，加载程序 故障由错误情况引起，被故障处理程序修正，控制返回到引起故障的指令，从而重新执行，否则返回到内核的abort，将引起故障的程序终止。 终止硬件错误，dram或者sram损坏 会返回abort然后终止应用程序 Linux x86-64系统中的异常故障号和cpu架构有关 Linux中的故障和终止除法错误：除以0，Unix会直接终止程序 floating exception 一般故障保护：神秘的错误，如程序引用了未定义的虚拟内存地址，或者访问只读的文本，也就是段错误segmentation fault 缺页：会从新执行产生故障的指令，将磁盘上的虚拟内存的一个页面映射到物理内存的一个页面，然后重新执行这条指令 机器检查：是在导致故障的指令执行中检测到致命的硬件错误时发生的 系统调用请求内核的服务 每个系统调用有一个编号，对应内核中跳转表的偏移量 c语言中syscall函数，c一般封装了系统调用库函数，带着参数陷入内核，将系统调用的执行状态返回 Linux系统调用的参数通过寄存器传递 进程执行中程序的实例，每个程序运行在某个进程的上下文context中 上下文包括内存中程序的代码和数据，栈，通用目的寄存器，程序计数器，环境变量，文件描述符集合 提供抽象：独立的逻辑控制流，假象程序独占处理器；私有地址空间，假象程序独占内存 逻辑控制流是交错的，进程轮流使用处理器，每个进程执行流的一部分 并发流逻辑流可以是进程、线程等 并发：多个流并发的执行 运行在同一个处理器上 并行：运行在不同处理器核上 每个控制流中的一部分是时间片 私有地址空间进程为每个程序提供假象，n位地址机器，地址空间2^n， 底部用于用户程序：包括代码，数据，堆，栈 顶部给内核 用户模式和内核模式通过模式位寄存器控制 /proc文件系统，包含系统属性，如内核数，cpu类型，某进程使用的内存段地址 上下文切换实现多任务 内核为每个进程维护一个上下文，包含重新启动一个进程所需的状态 包含通用目的寄存器，浮点寄存器，程序计数器，用户栈，状态寄存器，内核栈，内核数据结构（描述地址空间的页表、当前进程信息的进程表、已打开文件的文件表） 内核可以通过调度决定执行哪个进程 保存当前进程上下文 恢复先前被抢占进程的上下文 控制传递给新恢复的进程 错误处理全局变量 errno，strerror(errno) 进程控制获取进程idpid","link":"/2022/01/14/ecf/"},{"title":"图解HTTP读书笔记","text":"图解HTTP读书笔记 Web及网络基础HTTP/0.9 不是http的正式标准，临时版本 HTTP/1.0 RFC1945 HTTP/1.1 目前应用较广 RFC2616 HTTP/2.0 大幅提高了web性能 TCP/IP互联网运行与TCP IP协议族之上，HTTP包含于其中 ip，dns，udp，ftp，http，tcp。。。 TCP/IP的分层管理 应用层：决定了向用户提供服务时通信的活动，ftp，dns，http 传输层：对应用层提供连接的两台计算机的数据传输，TCP Transmission Control Protocol传输控制协议和UDP User Data Protocol用户数据报协议 网络层：处理网络上的数据包，数据包是网络传输的最小数据单位，规定如何传输路线，传输数据包 数据链路层：处理连接网络的硬件，网络适配器NIC网卡 物理层 层次化好处：1.设计好接口，每个层次内部的设计可以自由改动 2.使设计变得更简单，应用层上的应用不需要考虑接收方的地理位置等 IP、TCP、DNSIPIP协议位于网络层 mac地址为网卡的固定地址，使用ARP协议（address resolution Protocol地址解析协议）凭借mac地址进行通信，解析ip到mac地址 选择传输路线叫做路由选择 TCP协议的可靠性位于传输层 将大数据块分割为报文段segment确保传输准确可靠 将请求报文按照序号分为多个报文段，将每个报文段可靠的传输，收到后再根据序列号重组报文 确保数据可到达： 三次握手three way handshaking TCP标志 SYN synchronize和ACK acknowledgement 具体过程： 发送端发送一个带有SYN标志的数据包 接收端收到后回传带有SYN/ACK标志的数据包 发送端传回带有ACK标志的数据包，握手结束 如果握手中的某个阶段中断，TCP协议会再次发送相同的数据包 DNS域名解析 URI和URLURL是URI的子集 HTTP协议http是无状态协议 使用cookie管理状态 使用URI定位资源 持久连接：任意一端未提出断开，则保持tcp连接状态，减少tcp连接重复建立和断开的开销 HTTP 1.1中，所有连接默认为持久连接 pipeline技术：连续发送请求，不必等待上一个请求返回 Cookie服务器响应报文中Set-Cookie header字段，告知客户端保存 客户端再次请求时自动在header中加入cookie HTTP报文换行符CR+LF，CR回车符0x0d，LF换行符0x0a header + CR+LF + Body 报文message是通信基本单位，8位组字节流 实体entity 请求或响应的在和，包含实体header和实体body 传输过程中可以对实体进行压缩 实体可以分割传输 获取部分内容的请求传输中断的恢复机制 在header中加Range Range: bytes= 1-5000 断点续传 HTTP状态码1XX，正在处理 信息性状态2XX，处理完毕 成功3XX，重定向状态码4XX，客户端错误状态码5XX，服务器错误状态码 200 OK HEAD方法不会返回body 204 No Content 处理成功，但是response中不包含实体 206 Partial Content 客户端进行了范围请求 301 Moved Permanently 永久重定向，资源分配了新的URI 302 Found 临时重定向 303 See Other 客户端用GET，临时重定向（比如POST访问时返回303，需要改GET方法重定向到另一个URI） 304 Not modified 我有你要的资源但是不让你访问 307 Temporary Redirect 临时重定向 400 Bad request 401 Unauthorized 403 Forbidden 不允许访问 404 Not Found 找不到资源 500 Internal Server Error 内部错误 503 Service Unavailable 服务器超负荷 Web服务器虚拟主机一台服务器可以绑定多个域名 通过dns解析 代理 网关 隧道代理转发中间人 每次转发会追加写入via首部 代理服务功能：缓存技术，访问控制，获取日志 缓存代理：将资源缓存在代理服务器上，不从原服务器获取（有点像redis 透明代理：转发请求和响应，不添加其他内容 网关转发客户端请求到实际程序 网关与服务器使用非http通信 隧道在客户端和服务器直接中转，保持双方的通信连接 本身不解析http请求，只传输 缓存客户端缓存和服务器缓存 客户端缓存存储在浏览器 各种header的作用 Cookie相关headerSet-Cookie: 后跟name=value的序列 Cookie: 发送cookie HTTPShttp缺点： 明文被窃听 不验证双方身份，可伪装 无法验证完整性，可以篡改 使用SSL secure socket layer或TLS transport layer security安全层传输协议 SSL使用证书确定身份 防止篡改：使用md5或sha-1等校验方法校验报文完整性 HTTP+通信加密+证书+完整性保护 通信接口部分用ssl和tls协议代替 http先和ssl通信，ssl再和tcp通信 非对称加密 公钥进行加密，私钥进行解密 通信步骤 客户端发送client hello开始ssl通信 服务器响应server hello 服务器发送certificate报文，包含公钥证书 服务器发送server hello done 客户端发送client key exchange报文响应，ssl握手部分结束 客户端发送change cipher spec 客户端发送finished 服务器发送change cipher spec ssl连接建立成功，开始进行http请求","link":"/2022/01/16/tujiehttp/"},{"title":"Mysql学习笔记","text":"","link":"/2022/01/17/mysql/"},{"title":"【操作系统】虚拟内存","text":"虚拟内存提供了三个重要能力： 将主存看做是 存储在磁盘上地址空间的 高速缓存，主存按照需要在磁盘和主存中传递数据 每个进程提供一致的地址空间，简化内存管理 保护每个进程的地址空间不被其他进程破坏","link":"/2022/01/18/virtualmem/"},{"title":"Go语言学习笔记","text":"Go语言源码阅读与原理分析 Go的编译数据结构数组声明 12[3]{1, 2, 3}[...]{1, 2, 3}语法糖 第二种编译器会进行上限推导 语句转换 由字面量（具体整数，浮点数，字符串）组成的数组，根据长度进行优化 元素数量&lt;=4，元素放在栈上 &gt;4时，元素保存在静态区，运行时取出 元素数量&lt;=4时，简化为赋值表达式 1234var arr [3]intarr[0] = 1arr[1] = 2arr[2] = 3 review编译之后的二进制文件包含：栈，堆，数据段，代码段 堆栈为动态区域，数据段和代码段为静态区域 栈：编译器自动分配释放，存放参数值，局部变量等 堆：程序动态申请的内存，malloc，用链表实现 代码区：函数体的二进制代码 数据段：包含 只读数据段 const 已初始化的读写数据段 初始化的全局变量，初始化的静态局部变量static 未初始化段 未初始化的全局变量和静态变量 当数组元素个数大于四个时 获取一个唯一的staticname，在静态存储区进行初始化，之后再拷贝到栈上 访问和赋值 编译器的静态类型检查时检测数组越界，索引是否为非负整数，索引越界 使用变量作为索引时，无法编译检查，需要运行时阻止 发现数组切片字符串越界时通过运行时的runtime.panicIndex和runtime.goPanicIndex触发panic 下标没有越界时，编译器获取数组的内存地址和访问下标，计算出目标地址，使用Load将元素加载到内存中 赋值时先确定目标元素地址，使用Store指令将数据存入地址，在编译阶段而不是运行时","link":"/2022/01/25/godesign/"}],"tags":[{"name":"Math","slug":"Math","link":"/tags/Math/"},{"name":"ACM","slug":"ACM","link":"/tags/ACM/"},{"name":"数论","slug":"数论","link":"/tags/%E6%95%B0%E8%AE%BA/"},{"name":"Lucas定理","slug":"Lucas定理","link":"/tags/Lucas%E5%AE%9A%E7%90%86/"},{"name":"费马小定理","slug":"费马小定理","link":"/tags/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/"},{"name":"计算几何","slug":"计算几何","link":"/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"},{"name":"莫队","slug":"莫队","link":"/tags/%E8%8E%AB%E9%98%9F/"},{"name":"游记","slug":"游记","link":"/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"Note","slug":"Note","link":"/tags/Note/"},{"name":"计算机组成原理","slug":"计算机组成原理","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"汇编语言","slug":"汇编语言","link":"/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"Golang","slug":"Golang","link":"/tags/Golang/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"Numpy","slug":"Numpy","link":"/tags/Numpy/"},{"name":"线性回归","slug":"线性回归","link":"/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"思维","slug":"思维","link":"/tags/%E6%80%9D%E7%BB%B4/"},{"name":"CSAPP","slug":"CSAPP","link":"/tags/CSAPP/"},{"name":"Go","slug":"Go","link":"/tags/Go/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"}],"categories":[{"name":"ACM","slug":"ACM","link":"/categories/ACM/"},{"name":"数论","slug":"数论","link":"/categories/%E6%95%B0%E8%AE%BA/"},{"name":"ACM","slug":"数论/ACM","link":"/categories/%E6%95%B0%E8%AE%BA/ACM/"},{"name":"Note","slug":"Note","link":"/categories/Note/"},{"name":"Course Note","slug":"Course-Note","link":"/categories/Course-Note/"},{"name":"Web","slug":"Web","link":"/categories/Web/"},{"name":"Math","slug":"Math","link":"/categories/Math/"},{"name":"数学建模","slug":"数学建模","link":"/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"Tech","slug":"Tech","link":"/categories/Tech/"},{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"}]}