[{"content":"Background 自很久以前就开始使用静态博客，并且在GitHub Pages上部署后同时在服务器上进行同步，每次push新的修改后都需要在服务器上手动pull，因此决定探究使用Github Workflow自动化部署静态博客的解决方案。\nIntro Github Workflows 在仓库的目录下，创建.github/workflows目录，目录内存放需要使用的工作流配置文件。\n例如：\n.github └── workflows └── rsync-action.yml Rsync Action Github提供了很全面的Actions操作，包括Hooks功能，支持在对仓库进行push、merge等操作后触发对应的脚本。对于本需求，我们需要使用GitHub的Rsync Action插件。\n插件主页 Rsync Deployments Action\n包含如下参数：\n switches* - The first is for any initial/required rsync flags, eg: -avzr --delete rsh - Remote shell commands path - The source path. Defaults to GITHUB_WORKSPACE and is relative to it remote_path* - The deployment target path remote_host* - The remote host remote_port - The remote port. Defaults to 22 remote_user* - The remote user remote_key* - The remote ssh key remote_key_pass - The remote ssh key passphrase (if any) *标记为Required  也就是说我们要配置远程服务器的主机地址host，ssh端口，用户名，ssh公钥，以及同步的目的地址\n对于GitHub WorkSpace，也就是仓库内的文件，需要指定要同步的目录，可以用.来同步整个目录。\n最终需要实现的效果即为：\n本地通过hugo/hexo生成静态文件后，push到远程仓库后即可自动触发服务器静态资源目录和GitHub仓库的同步，保证自动实时更新。\nGithub Secret KV GitHub为每个仓库提供了Secret配置，相当于系统环境变量，防止在yml中泄露敏感信息，可以利用该功能配置服务器的host，ssh公钥，用户名等信息。\n如上图所示，可以进行GitHub Secrets的配置，通过new repository secret添加新的环境变量。\n对于这些变量的访问，通过在yml中${{ secrets.DEPLOY_HOST }}类似的方式进行访问。\nRsync-Action.yml 编写yml工作流\nname:Deploy# 工作流名称on:push:branches:- hexo # 触发工作流的分支jobs:deploy:runs-on:ubuntu-lateststeps:- uses:actions/checkout@v2- name:Rsync to Remote Serveruses:Burnett01/rsync-deployments@5.2.1with:switches:-avzr --delete # 同步参数 flagspath:${{ secrets.WORKSPACE_PATH }}# 同步的仓库目录remote_path:${{ secrets.DEPLOY_PATH }}# 服务器同步目录remote_host:${{ secrets.DEPLOY_HOST }}# 服务器主机IPremote_port:${{ secrets.DEPLOY_PORT }}# 服务器ssh端口remote_user:${{ secrets.DEPLOY_USER }}# 服务器用户名remote_key:${{ secrets.SSH_PRIVATE_KEY}}# 服务器ssh公钥这里我同步的仓库目录即为整个目录，通过.来配置\n服务器同步目录即为/var/www/blog目录\n服务器公钥尽量重新生成，GitHub会拒绝已经添加过的公钥\nssh-keygen -t rsa -b 4096 -C \u0026#34;email address 邮箱地址\u0026#34; 新公钥不防起名叫github-action.pub\n将github-action.pub（生成的新公钥）丢进GitHub Secrets中的SSH_PRIVATE_KEY变量中\n再把该公钥加入到authorized_keys中\ncat github-action.pub \u0026gt;\u0026gt; ~/.ssh/authorized_keys 此时，将该yml push到远程仓库中，即可触发同步action。\n如图所示，工作流全部完成。\n顺便还配置了七牛云图床，Typora和PicGo配合的自动图片上传，就不用每次手动上传了图片了，写作体验有效提升。\nReference Deploying to a server via SSH and Rsync in a Github Action\nUnderstanding how to use Github Actions\nRsync-Action Documentation\nPicGo Documentation\n","date":"2022-08-30T09:27:53+08:00","permalink":"https://ez4zzw.github.io/p/%E4%BD%BF%E7%94%A8github-workflow%E5%B7%A5%E4%BD%9C%E6%B5%81%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/","title":"使用GitHub Workflow工作流自动部署静态博客"},{"content":"0x00 Intro 1. 对称加密大战公钥同态加密 双方使用相同的key对数据进行加密解密，属于对称加密\n公钥同态加密（非对称加密）使用两个不同的key，使用公钥来对数据进行加密，使用私钥来对数据进行解密。\n二者的工作流程对比如上图所示\n2. 参数与安全性的关系 对于同态加密，参数的选取影响着安全性以及明文的类型和可以进行的计算。\n同态加密目前最重要的两个参数为：\n 密文空间$n$，大致对应每个密文中整数的数量 密文模数$q$，确定密文中每个整数的大小边界  一般来说，安全性随着$n$的增大而升高，随着$q$的增大而降低。\n$q$越大，在加密之后的密文上则可以执行更复杂的计算。\n加密方法最终都会对数据加噪声，只有当噪声$\u0026lt;q$时，才可以被解密。因此更大的q可以让我们执行更多的操作。\n基于格密码的同态加密，理论基础是$Learning \\ with \\ Errors (LWE)$问题难解性或者是他的变种问题$Ring \\ Learning-with-Errors (RLWE)$。在适当的参数下，该问题对于经典计算机和量子计算机都很难解。\n对于参数的选取可以根据所需要的安全性去查阅安全文档。\n0x01 BGV，BFV加密模式 基于RLWE问题的难解性，两种模式都支持明文为整数组成的向量。\n加密包括的参数：\n 明文模数$p$ 密文模数$q$ 密文维数$n$  明文模数$p$决定了明文向量整数的上限，约束加密后的密文计算中的结果。\n密文模数$q$是决定方案的加密计算能力。BGV或者BFV加密模式的密文包含一个长度为$2n$的整数数组，值为$[0,q-1]$，前文提到过，模数越大，密文可以执行的操作就越多。\n对于给定的$q$，密文的维数$n$决定了加密等级，越高则安全性越高。同时，还影响明文向量的大小。一般而言明文向量的长度等于$n$。\n1. 同态操作 密文在操作时保留模数p，输出结果同样为密文。\nCiphertext-Plaintext\n二元操作：\n Ciphertext-Ciphertext Addition Ciphertext-Plaintext Addition Ciphertext-Ciphertext Multiplication Ciphertext-Plaintext Multiplication Ciphertext-Ciphertext Subtraction Ciphertext-Plaintext Subtraction  一元操作：\n 向量旋转 否定  2. 参数选取 明文模数$p$：决定明文数据的宽度，要保证在应用范围内足够大，不发生溢出，有些场景下需要溢出。\n密文模数$q$：主要由乘法深度决定，更高的深度需要更大的模数，并且运算时间也会增大。\n举个例子：\n对于密文$A,B,C,D$，乘法运算$(A*B)*(C*D)$优于$A*(B*(C*D))$， 前者的乘法深度较小，需要的密文模数小。\n密文维数$n$：查阅安全性文档中的参数表来选取，选取表格时许啊要了解密钥分发等实现细节。\n3. BGV/BFV Hello World # set parameters p = 31 q = 65537 n = 16 # generate key myPublicKey, mySecretKey = generateBFVkey(n, p, q) # encrypt data # each plaintext is a vector of 8 elements encrypted_a = encrypt(myPublicKey, [5, 11, 2, 0, 20, 3, 8, 11]) encrypted_b = encrypt(myPublicKey, [12, 7, 14, 11, 1, 2, 3, 24]) excrypted_c = encrypt(myPublicKey, [2, 10, 15, 13, 6, 3, 2, 1]) encrypted_d = addCiphertexts(myPublicKey, encrypted_a, encrypted_b) # Encryption of vector [17, 18, 16, 11, 21, 5, 11, 4] # Maybe we want to multiply the result by the 3rd ciphertext.  encrypted_e = multiplyCiphertexts(myPublicKey, encrypted_c, encrypted_d) # Encryption of vector [3, 25, 23, 19, 2, 15, 22, 4] # encrypted_c * encrypted_d % p # Then rotate by 2 to the right encrypted_f = rotateBy2(myPublicKey, encrypted_e) # To actually see the final result we have to use the key.  decrypted = decrypt(mySecretKey, encrypted_f) print(decrypted) # This should print [22, 4, 3, 25, 23, 19, 2, 15] ","date":"2022-08-28T23:41:33+08:00","permalink":"https://ez4zzw.github.io/p/homomorphic-encryption-learning-notes/","title":"Homomorphic Encryption Learning Notes"},{"content":"Intro 优化I/O的方法\n 用户层面直接调用外部存储设备，需要应用包含文件系统的调用，臃肿，同时不同应用和用户间的冲突问题。 优化操作系统内核的I/O 栈  使用轮询来减少上下文切换的开销 在底层减少一半的中断处理 分散I/O指令 I/O block调度机制    Related Work 减少内核的开销\n 减少中断处理的后半部分 是用轮询技术而非中断，减少上下文切换 混合轮询 基于SSD的闪存随机读写简化调度策略 在NVMe固件中进行调度 对高优先级的任务，提供不同的IO path支持，最小化IO path的开销  修改存储接口\n 分散/分散 IO合并多个IO到一个指令，减少往返次数 移除doorbell机制和完成信号  改善fsync\n 冲fsync请求发出到收到response，延长数据持久化的时间 在日志提交记录中使用校验和，有效的重叠日志写入和块写入 提出写守序系统调用，重叠的fsync效果相同，当应用需要使用fsync时，关于IO的操作将同步进行  用户层直接访问外设，存在隔离、保护等安全问题\nMotivation 背景 现状：\n I/O 请求过程中太多的步骤 页面缓存分配和索引 DMA，一系列数据结构的创建  目前的 ULL SDD实现了低于10微妙的IO延迟，然而操作系统内核产生的延迟没有明显变化\n本文专注于：\n Linux内核中的read()和write()+fsync() 基于NVMe SSD的Ext4文件系统  For Read Path 研究发现许多剩余的操作不必在设备I/O之前或之后执行\n此类操作可以在设备I/O操作进行时执行\n因为此类操作大多独立于设备I/O操作，因此考虑让这些操作与IO重叠\nFor Write Path 缓冲写write()，并不发起IO请求，不能异步处理\n由于fsync的回写机制和文件系统崩溃一致性（日志系统），包含部分IO请求\n由于文件系统带来的三次IO操作\n 数据块写 jbd2发起写入日志Block I/O 提交Block I/O  这些IO的创建，涉及众多过程（block分配，请求缓冲页，创建和提交bio，设置DMA地址），因此可以让CPU将这些前置操作在IO请求发起前预执行。\nFor Lightweight Block Layer 传统Block Layer涉及过多过程，推迟了IO指令提交给设备的时间\n因为ULL SSD的高速随机IO性能和低速的顺序IO，请求重排的效果很低\n简化block layer，针对异步IO stack进行优化\nDesign 轻量化的Block I/O Layer LBIO，为LL NVMe SSD而设计，只支持IO submission/completion和IO指令tagging\n只使用lbio来表示一个block I/O请求，减少了bio-to-request的时间\n每个lbio包括\n LBA I/O 长度 复制的页面 页面的DMA地址  使用全局的lbio二位数组来记录\n行的个数为CPU核心数，行成组被分配到一个NVMe队列\n例如8核心，4NVMe队列，每个队列分配2个核心的lbio 当核心数等于队列数时，可以实现无锁的命令提交\nlbio在全局数组中的索引用作NVMe指令的tag，减少了之前赋tag的过程\nlbio提交后，调用nvme_queue_lbio来提交I/O指令\nLBIO不会合并和调度IO请求\nRead Path Ext4文件系统中，由extent status tree保存缓存到物理文件block的映射\n预加载映射到内存中，当树太大时，可以只对某个文件预加载\n异步页面申请和DMA分配 提前分配空闲页池\n为了减少页面DMA的分配，为每个核维护一个DMA映射空闲页（4KB DMA映射页的链表）\n当空闲页池不够用时，将退化为同步进行（origin）\n缓存页索引 自旋锁防止并发问题，影响效率\n在请求发出，但是页面还没有更新时，可能重复请求更新页面\n解决方案是不限制request，在request completion阶段解决问题\n尽管多个block请求，但是只能有一个页面被索引\n对于其他页面，标记为abandoned，中断发生之后，如果标记为abandoned，则清除已经完成的页面\nDMA解除映射 原本使用中断来处理，改为当系统空闲或等待一个IO请求时处理\n该方式可能会产生漏洞窗口，若不受到恶意访问，不会产生影响，否则用户可以自行选择关闭惰性DMA映射接触\nWrite \u0026amp;\u0026amp; fsync Path 当fsync涉及文件系统中事务时，可以将jbd2日志处理重叠处理\nExperiment 基于Linux内核5.0.5版本\n使用文件描述符O_AIOS\nEvaluation Conclusion 提出了AIOS\nLBIO层\nAIOS将I/O路径中的同步操作替换为异步操作，以将与读取和fsync相关的计算与设备I/O访问重叠。\nAIOS在Optane SSD上实现了一位数微秒的I/O延迟。\n此外，AIOS通过Z-SSD和Optane SSD上的模拟实验和实际测试显著降低延迟和性能改进。\n一些启发  优化I/O可以从CPU的空闲时间分析，需要考虑内核和文件系统的工作流程，最大程度的利用CPU资源，减少空闲。 硬件设备在发展的同时，软件应该提供必要适配 减少内核中与I/O相关的结构类型转化，可以有效节省时间开销 惰性修改会存在安全问题，在保证安全的情况下，可以提高效率  ","date":"2022-08-17T10:30:41+08:00","permalink":"https://ez4zzw.github.io/p/asynchronous-i/o-stack-a-low-latency-kernel-i/o-stack-for-ultra-low-latency-ssds-atc19/","title":"Asynchronous I/O Stack: A Low-latency Kernel I/O Stack for Ultra-Low Latency SSDs (ATC'19)"},{"content":"超低延迟固态硬盘从内核到固件的服务器存储堆栈\n个别名词解释 the 99^th percentile 超过统计数据99%的数是多少\nblk-mq Linux Multiqueue block layer 内核对ssd随机I/O的优化\nmessage signaled interrupt (MSI)\n1.摘要 flash share\n在内核中，扩展了系统堆栈的数据结构，传递应用程序的属性（？），包括内核层到SSD固件。\n对于给定的属性，FlashShare的块层管理IO调度并处理NVMe中断。\n评估结果表明，FLASHSHARE可以将共同运行应用程序的平均周转响应时间分别缩短22%和31%。\n1.0 Intro 1.1 现状 网络服务提供商，满足服务级别协议SLA，延迟敏感\n某个段时间短可能有大量请求涌入，供应商会超额配置机器以满足SLA\n现状：该场景并不常见，因此大部分情况下服务器的资源占用率非常低，能耗比低。\n为了解决利用率低，服务器会运行离线的数据分析应用，延迟不敏感，以吞吐量为导向。\n因此，在运行了多个进程的服务器上，I/O延迟增高，满足SLA非常困难。\n现有的ULL SSD相较于NVMe SSD可以减少10倍的延迟\n但是这些ULL SSD在同时运行多个进程下高强度压榨服务器的时候，不能充分利用ULL SSD的优势/表现一般。\nthe 99th percentile 是0.8ms（apache）\n但是当服务器同时运行pagerank的时候，延迟会增加228.5%。\n原因：略\n从固件到内核优化堆栈的存储。\n  内核级别的增强：\n两个挑战\n Linux的blk-mq导致I/O请求队列化，引入延迟 NVMe的队列机制没有对I/O优先级的策略，因此，来自离线应用的IO请求容易阻塞在线应用的紧急请求，造成延迟。  对于latency critical的请求，绕过NVMe的请求队列。同时令NVMe的驱动通过知晓每个应用的延迟临界匹配NVMe的提交和请求队列。\n  固件层设计：\n  ​\t即使内核级的优化保证了延迟敏感的请求可以获得高优先级，但如果基础固件不了解延迟临界值，ULL特性（类似内存的性能）无法完全暴露给用户。本文中重新设计了I/O调度和缓存的固件，以直接向用户暴露ULL特性。将ULL SSD的集成缓存进行分区，并根据工作负载的属性对每个I/O服务独立的分配缓存。固件动态的更新分区大小并以精细粒度调整预取I/O粒度。\n ULL SSD的新中断处理服务：  ​\t当前的NVMe中断机制没有对ULL I/O服务优化。轮询方法（Linux 4.9.30）消耗了大量的CPU资源去检查I/O服务的完成情况。当轮询在线交互服务的IO请求完成状态时，flashShare使用一个仅对离线应用程序使用消息信号中断的选择性中断服务程序Select-ISR。\n​\t通过将NVMe队列和ISR卸载到硬件加速器中来进一步优化NVMe completion routine。\n​\t各种仿真实验后效果不错，效率提高了22%和31%。\n2.0 Background 2.1 存储内核栈  Linux文件系统IO\n bio request nvme_rw_command   存储堆栈中，NVMe驱动发起的请求通过nvme_rw_command的形式传递到PCI/PCIe设备驱动中。\n当I/O请求完成后，发送信号中断，中断直接被写入到中断处理器的中断向量中。被中断的核心选择ISR处理该中断请求，随后NVMe驱动再SQ/CQ中清空相应的记录并将结果返回至上一层（比如blk-mq和文件系统）。\n2.2 设备固件栈  收到request SQ tail++入队 写入SQ门铃寄存器 通过DMA读取数据的物理位置 SQ head++出队 将请求转发至嵌入式缓存层或者FTL 当出现缺页或者页面替换时，FTL将目标LBA转换成Z-NAND中相应的物理地址，必要时自行GC 在完成I/O请求之后，NVMe控制器增加这个CQ的tail，入队 通过DMA传输数据，并修改phase tag 主机ISR通过搜索队列中检查phase tag，对于有效的phase tag，ISR清除tag位，并且处理剩余的I/O完成请求程序。 CQ head++出队，在SQ中移除相应的记录，并且写入CQ的head doorbell  3.0 跨层设计 3.1 快速存储的挑战 原因是存储栈无法区分来自Apache的I/O请求，及时两个应用需要不同级别I/O的响应。\n3.2 预知灵敏响应 为了让内核可以区分I/O 请求的优先级和紧迫程度，修改Linux的进程控制快task_struct.\n为了保证有效性，在address_space,bio,request,nvme_rw_command\n中都保存工作负载属性，在存储堆栈上打孔。\nFlashShare同时提供了一个可以在服务器上配置这些属性的工具。叫做chworkload_attr。\n可以方便的修改每个应用的属性并绑定到task_struct中\n修改了syscall表arch/x86/entry/syscalls/syscall 64.tbl添加了两个系统调用，可以从task_struct中set/get工作属性。\n在/linux/syscall.h中进行注册，并带有asmlinkage标签。\n用户通过shell给定特定进程，实现于/sched/cores.c\n3.3 内核优化 优化文件系统中的blk-mq和NVMe驱动\nblk-mq合并重排请求提高了带宽使用，但是引入了延迟\n跳过所有在线应用的I/O 请求\n如果离线应用程序的 I/O 请求被 blk-mq 调度到后续在线应用程序发出的同一 LBA，则可能发生危险。\n如果两个请求的操作类型不同，blk-mq会将两个请求串联。否则blk-mq会将两个请求合并为一个request并交给NVMe驱动。\n为了防止延迟敏感的I/O 被NVMe控制器杀死：\n 为每个核心创建两个SQ队列和一个CQ队列  其中一个SQ保存来自在线应用的I/O请求。NVMe驱动程序通过管理员队列发送消息，通知NVMe控制器选择一种新的队列调度方法，该方法始终优先安排该SQ中的请求。\n未来避免因优先级带来的饥饿，当该队列中的请求数量大于阈值时，或者没有在规定时间内被满足，NVMe驱动会满足所有离线应用I/O 。\n实验表明，队列大小为8或者200us的阈值最好。\n4.0 I/O Completion和缓存 采用轮询机制时查询I/O Completion时，内核态占用97%。\n带来两个问题：\n 没有为处理I/O 响应单独分配核心，对于多进程下低效 我们要减轻处理I/O轮询的核心开销，进一步降低延迟  4.1 中断处理程序 flash share仅对来自在线应用的I/O 请求使用轮询\n使用信号处理离线应用\n 修改blk-mq中的submit_bio()，将由文件系统或缓存的bio插入到mq 如果bio是来自离线应用的，则插入队列，as normal 如果bio是来自在线应用的，blk-mq则调用queue_rq()将请求发送至NVMe驱动。 NVMe驱动转换I/O 请求为NVMe指令并非插入到响应SQ队列中  使用Select-ISR，当请求为离线应用时，CPU核心可以通过上下文切换从NVMe驱动中释放。否则，blk-mq调用轮询机制blk-poll()。blk-poll()持续调用nvme_poll()，检查有效的完成记录是否存在于目标NVMe CQ中。如果存在，blk-mq禁用此CQ的IRQ，以至于MSI信号无法再次捕获blk-mq程序。nvme_poll()通过检查CQ中的phase tags查找CQ中的新记录。\n具体来说，nvme poll()搜索一个CQ记录，其请求信息与blk poll()等待完成的标签匹配。一旦检测到这样的新记录，blk-mq就会退出在blk poll()中实现的无限迭代，并将上下文切换到其用户进程。\n提出I/O-stack accelerator\n主要目的是将blk-mq的任务迁移到附属于PCIe的加速器中\n可以使得通过上层文件系统生成的bio直接转换成nvm_rw_command。\n通过特殊的tag索引搜索队列中的元素，并且代表CPU合并bio\n该方法可以减少36%的I/O completion时间。\n4.2 固件层 创建两个内存分区，一个服务于在线应用，一个服务于离线应用。\n三种模式\n 固定拆分缓存 根据I/O动态划分 数据可保留  4.3 I/O-Stack Acceleration 添加了一个barrier logic，简单的MUX，作为硬件仲裁\n引入status bitmap来过滤SQ队列中的记录\n 合并逻辑插入一个行的nvme 指令，status bitmap设置为1 如果监测到ULL SSD从I/O SQ中读取NVMe指令，status bitmap设置为0  如果状态位图表明CAM中的请求条目（与目标SQ相关联）无效，CAM将跳过对这些条目的搜索。\n5.0 实验 5.1 实验步骤 使用gem5系统结构模拟\n64位arm指令集\nLinux 4.9.30\n8核心2GHz\nL1 Cache 64KB\n2GB Memory\nRelated Work 将SSD固件转移到主机上，消除冗余的地址转换\n根据应用程序特征对缓存进行分区处理，然而不能发挥ULL SSD的作用\n从文件系统和block IO设备方面优化移动端操作系统，使其提高SQLite的性能，有局限性，应用程序、ULL SSD\n在内核的多个层对写请求进行调度，容易阻塞读请求和ULL操作\n根据前台任务和后台任务中的依赖关系，分配优先级，允许后台任务高优先级，IO通常情况下没有依赖关系，效果差，服务器大部分都是多进程\n考虑对在线应用设置高优先级，但是没有考虑对IO stack中其他部分的影响\n","date":"2022-08-17T10:30:30+08:00","permalink":"https://ez4zzw.github.io/p/flashshare-punching-through-server-storage-stack-from-kernel-to-firmware-for-ultra-low-latency-ssds-osdi19/","title":"Flashshare: Punching Through Server Storage Stack from Kernel to Firmware for Ultra-Low Latency SSDs (OSDI'19)"},{"content":"DNS 使用UDP 53端口\n多路复用和多路分解 无连接运输UDP UDP无需建立连接，速度快\n无连接状态，不需要维护序列号，可以支持更多用户活跃（游戏服务器）\n首部只有8个字节，源端口号和目的端口号，长度和check sum\n为什么需要checksum校验和：\n 在路由器内存中可能有bit差错 链路传输不可靠  checksum最终为1111111\u0026hellip;则可能无差错\n端到端原则：某种功能应该在较高级别提供，在较低级别上设置该功能可能会冗余\nUDP只能检查错误，不能纠错\nDNS服务采用UDP\n何时UDP，何时TCP？\n 不希望延迟报文的发送，TCP有拥塞控制机制，并容忍数据的丢失  可靠数据传输 差错检测\n接收方反馈：\n ACK肯定确认 NAK否定确认  ACK 0接收成功，ACK 1接收失败\n重传，收方发现差错，发送方重传\n序号，检测哪个数据包出错进行重传\n数据包可靠传输：\n 在没有ack的情况下，等待一定的时间后进行重传 序号可以保证传输不冗余（接收方检测是否冗余）  发送方需要实现：\n 没发送或者重传一个分组，启动定时器countdown timer 定时器过期后响应 终止定时器  流水线可靠传输协议：\n 采用极小的数据包，接收方收到最后一bit立即ack  GBN协议（回退N步），滑动窗口协议 限制数据包的序号，直到相应序号ack之后再发送后续的序号，用长度为N的窗口控制。\nGBN发送方：\n 发送数据包时，检查发送窗口，未满则返回未发送的分组 收到ack后，对分组中的序号累积确认，表明接收方，正确接收到序号为n的分组以及以前的所有分组，[0, N] 超时，发送方重传所有未被确认的分组  接收方收到的分组都是有序的，如果出现无序，会丢弃后面的数据包，等待重传\n选择重传 避免不必要的重传\n发送方接收方都维护一个窗口\n发送方：\n 收到send base后窗口右移到第一个没确认的分组处 接收ack将窗口内分组标记为ack 定时器防止分组丢失  接收方：\n 接收的分组落在窗口内，返回ack 如果序号不连续，直接缓存 如果分组序号等于rcv_base将从rcv base开始的已缓存分组交付给上层，窗口移动 序号落在窗口之外，[rcv_base-N, rcv_base-1]上一个窗口中，返回ack  窗口长度不能太大\nTCP 运行与端系统中，路由器等视角下看到的是数据报\n全双工\nsocket是对tcp协议的封装\n流量控制 每一方都设置接收缓存，数据先放在缓存中，应用程序从缓存中读取数据。\n目的是消除发送方使接收方缓存溢出的可能。匹配发送方和接收方的读写速率。\n收发各自维护接收窗口。保存接收方还有多少缓存空间rwnd。\n发送方维持为确认的数据量在rwnd之内。\n如果剩余空间为0，发送方发送只有一个字节的报文。\nUDP没有流量控制，因此可能会出现缓冲区溢出。\n三次握手  客户端发送SYN=1，随机选择一个序列号seq=x 服务器读取该报文，为tcp连接分配资源，对客户端发送SYN=1，ack=x+1，seq=y（随机选取） 客户端为该连接分配资源（缓存和变量），发送SYN=0，ack=y+1，seq=x+1   为什么三次？ 确保双方的收发能力都是正常的最小次数。\n  握手能不能携带数据？ 第一二次握手不能携带数据，第三次握手可以携带数据\n 四次挥手  客户端发送FIN=1 服务器响应ACK 服务器发送FIN=1 客户端发挥ACK  拥塞控制 丢包的原因？\n 网络堵塞后，路由器缓存溢出  方法：\n 慢启动 快速重传 拥塞避免 快速恢复  ","date":"2022-03-05T10:32:46Z","permalink":"https://ez4zzw.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/","title":"计算机网络自顶向下"},{"content":"Go语言源码阅读与原理分析\nGo的编译 数据结构 数组 声明\n[3]{1, 2, 3} [...]{1, 2, 3}语法糖 第二种编译器会进行转换成第一种\n上限推导\n语句转换\n由字面量（具体整数，浮点数，字符串）组成的数组，根据长度进行优化\n 元素数量\u0026lt;=4，元素放在栈上 \u0026gt;4时，元素保存在静态区，运行时取出  元素数量\u0026lt;=4时，简化为赋值表达式\nvar arr [3]int arr[0] = 1 arr[1] = 2 arr[2] = 3 review 编译之后的二进制文件包含：栈，堆，数据段，代码段\n堆栈为动态区域，数据段和代码段为静态区域\n栈：编译器自动分配释放，存放参数值，局部变量等\n堆：程序动态申请的内存，malloc，用链表实现\n代码区：函数体的二进制代码\n数据段：包含\n 只读数据段 const 已初始化的读写数据段 初始化的全局变量，初始化的静态局部变量static 未初始化段 未初始化的全局变量和静态变量  当数组元素个数大于四个时\n获取一个唯一的staticname，在静态存储区进行初始化，之后再拷贝到栈上\n访问和赋值\n编译器的静态类型检查时检测数组越界，索引是否为非负整数，索引越界\n使用变量作为索引时，无法编译检查，需要运行时阻止，出发panic\n发现数组切片字符串越界时通过运行时的runtime.panicIndex和runtime.goPanicIndex触发panic\n下标没有越界时，编译器获取数组的内存地址和访问下标，计算出目标地址，使用Load将元素加载到内存中\n编译时插入运行时越界检查函数\n赋值时先确定目标元素地址，使用Store指令将数据存入地址，在编译阶段而不是运行时\n切片 编译时确定类型，存储在Extra字段\n数据结构\nData Len Cap 切片只在运行时确定内容\n初始化 切片slice[l:r] 调用SliceMake函数，参数为 元素类型，数组指针，切片大小和容量\n这样初始化的切片创建了指向原切片的结构体\n字面量 编译时：\n对字面量数组做大小推断，初始化为数组\n创建一个数组指针，指向静态数组\n使用[:]通过指针创建切片\nmake make([]int, len, cap) 会做参数校验，cap \u0026gt;= len\n 判断切片大小和容量是否足够 切片是否发生了逃逸，最终在堆上初始化  切片太大时也会在堆上初始化，使用运行时makeslice\nmakeslice会在堆上申请连续的内存\n可能的运行时错误：\n 内存空间大小发生了溢出 申请内存大于最大可分配内存 传入的len\u0026lt;0 or len \u0026gt; cap  访问 对len和cap的访问会在编译时替换为常量\n使用index获取元素会直接转换为对地址的访问\nappend和扩容 如果append之后不需要赋值给原有变量：\n判断append之后的大小和容量触发扩容\n如果append之后需要赋值给原有变量：\nappend后的切片覆盖原切片，编译器优化为不发生拷贝，直接操作原切片\ngrowslice 先确定新切片容量，扩容策略：\n 如果期望容量大于当前的两倍，就会使用期望容量 当前切片长度小于1024会将容量翻倍 如果当前的切片长度大于1024每次增加25%的容量，直到新容量大于期望容量  扩容之后进行内存对齐，提高内存分配效率，减少碎片\n使用预制的内存大小数组向上取整，然后通过该内存大小重新计算cap\n对于非指针切片，将原数组内容拷贝至新内存\ngrowslice返回的是一个新的切片，都是新的 slice(p, len, newcap)\ncopy copy(a,b)\n编译时会直接使用memmove拷贝到内存\n运行时会直接进行合法性检查\n大切片性能开销比较大\n哈希 解决冲突 开放寻址 从index处向后寻找空闲位置，读取会从index处向后匹配相等元素\n装载因子=元素数量/数组大小\n装载因子增大，线性探测法的平均用时增加，最坏到On\n拉链法 使用链表数组，每个数组是一个桶，通过index访问\n装载因子=元素数量/桶数量\n一般情况下不超过1，装载因子太大会触发扩容\nstruct runtime hmap\n保存对数，桶的数量都是2的倍数\n包含runtime bmap，能存储8个键值对，超过8个时会使用extra.nextOverflow中的溢出桶存\nbmap中存储key哈希的高八位tophash uint8\n初始化 字面量 当哈希表的元素\u0026lt;=25个时，将初始化转化为\nhash := map[string]int { \u0026#34;1\u0026#34;: 1, \u0026#34;2\u0026#34;: 2, } to hash := make(map[string]int, 3) hash[\u0026#34;1\u0026#34;] = 1 hash[\u0026#34;2\u0026#34;] = 2 超过时会转换为两个切片循环加入hash\n运行时 当桶的数量小于$2^4$，不创建溢出桶\n否则创建$2^{B-4}$个溢出桶\n读写 遍历使用for range\n删除delete(hash, key)\nbmap的实际存储是tophash为一个连续的空间，keys，values 。。。\n访问时限获取哈希值，再获取哈希的高8位\n通过哈希的最低几位获取桶序号\n 这里因为哈希计算出来并不在桶范围内，在二进制中体现出来是取高几位和低几位，低几位就是取模之后的值，因此可以有效避免桶中有大量重复tophash\n 在bmap中先比较哈希高8位，加速访问\n匹配成功会根据指针和偏移量获取key进行比较，匹配成功再获取value\n尽量使用双值接收结果，防止实际的value是nil\n写入时会遍历正常桶和溢出桶，溢出桶也包含tophash\n如果桶满，创建新的桶护着在溢出桶中保存\n获取存储地址后，将值拷贝到内存\n扩容 在写入时，触发扩容\n 装载因子超过6.5 哈希使用了太多溢出桶，容易产生内存泄露  扩容非原子过程，扩容前判断是否正在扩容\n溢出桶太多触发等量扩容，新桶保存数据，回收旧桶（大量的写入删除操作）\n翻倍扩容，随着写操作增量进行，不会产生性能的巨大抖动，创建一组新桶和溢出桶，将原来的桶组设置到oldbuckets，溢出桶也设置到oldoverflow上\n数据迁移发生在运行时 evacuate，对传入桶的元素再分配，每个旧桶元素分流到两个新桶\n分流逻辑：原来通过取模得到的桶掩码为0b11，扩容翻倍之后将变为0b111，因此该数据被分流到3号和7号桶\n当旧桶完全被分流后清除oldbuckets和oldoverflow，通过计数器控制\n扩容期间访问时，若oldbuckets存在，并且旧桶没有被分流时会先去旧桶寻找\n扩容期间写入赋值时，会触发增量拷贝，向新桶分流\n删除 扩容期间删除，会分流桶中的元素，然后找到桶中的目标键值对删除\n与写入类似\n访问，写入删除都是运行时处理\n字符串 只读的字节数组，使用连续空间\ndata和len\n分配在只读的内存空间，修改需要和[]byte相互转换\n 拷贝内存到栈或者堆 将变量修改为[]byte然后修改字节数据 修改字节数组转回string  str := \u0026#34;hello\\\u0026#34;\u0026#34; str := ` { \u0026#34;name\u0026#34; : \u0026#34;panda\u0026#34;, \u0026#34;tags\u0026#34; : [\u0026#34;panda\u0026#34;] } ` 赋值时使用scanner解析字符串成token流\nstrconv.Unquote去除引号\n使用+拼接，拼接字符串的数量小于等于五个时，使用concatstring{2,3,4,5}，否则使用runtime.concatstrings，传入数组切片，最终通过运行时过滤空字符串计算拼接后长度，如果非空字符串数量为1，并且不在栈上，则直接返回\n拷贝到目标地址空间\n类型转换有性能损失，需要拷贝数据\n函数调用 c语言使用寄存器传参数，小于等于六个时使用寄存器，大于6个的参数使用栈传递，使用寄存器传递返回值，并且只使用一个寄存器，因此只能有一个返回值。\ngo语言使用栈传递参数和返回值，因此存在性能损失，但是可以支持多返回值，便于维护编译器，不需要考虑寄存器数量和命名。\n参数传递方式 传值，基本类型，结构体，指针，对参数进行拷贝\n","date":"2022-01-25T20:14:16Z","permalink":"https://ez4zzw.github.io/p/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"Go语言学习笔记"},{"content":"基础知识 单进程多线程，线程之间共享内存\nOLTP Online Transaction Processing 在线事务处理\nInnoDB overview 特点：\n 行级锁 支持外键 支持事务  MVCC并发控制，插入缓冲，二次写，自适应哈希索引，预读\n四种隔离级别：\n REPEATABLE 默认  聚集方式保存数据，按主键顺序存放，没有主键则生成6字节的ROWID\n后台线程  Master Thread 缓冲区数据异步更新到磁盘 IO Thread innodb使用异步IO，提高数据库性能，负责接受回调 Purge Thread 事务提交后回收undolog页 Page Cleaner Thread 脏页刷新  主要都是为了减轻Master的负担，提高性能，减少对用户查询线程的阻塞\n内存 用页管理记录\n缓冲池：通过内存来弥补低速硬盘的影响，数据库读取页，从磁盘获取页放入缓冲池fix，读取时先判断缓冲区，命中后直接读取；修改时先修改缓冲池的页，然后通过checkpoint机制刷新到磁盘上。基本上和虚拟内存一样。\n配置参数innodb_buffer_pool_size\n数据页分类：索引页，数据页，undo页，插入缓冲，自适应哈希索引，innodb锁信息，数据字典信息等\n允许有多个缓冲池\n内存管理 LRU List 频繁使用的在列表前，不频繁的在列表后，先释放尾部的页\n页默认大小16KB\ninnodb会把新读取的页放入midpoint位置，为列表长度的$$\\frac{5}{8}$$，midpoint之后为old，之前为new，如果放在首部会导致某些sql导致缓冲池页被刷新，如全表扫描遍历全表。防止一条指令拖慢其他指令效率。\nFree列表保存空闲页\nMyISAM  表锁 全文索引 不支持事务  缓冲区只缓存索引文件，不缓冲数据\nMYD保存数据，MYI保存索引文件\nmyisampack使用Huffman编码压缩MYD，压缩后只读\n","date":"2022-01-17T23:16:08Z","permalink":"https://ez4zzw.github.io/p/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"Mysql学习笔记"},{"content":"图解HTTP读书笔记\nWeb及网络基础 HTTP/0.9 不是http的正式标准，临时版本\nHTTP/1.0 RFC1945\nHTTP/1.1 目前应用较广 RFC2616\nHTTP/2.0 大幅提高了web性能\nTCP/IP 互联网运行与TCP IP协议族之上，HTTP包含于其中\nip，dns，udp，ftp，http，tcp。。。\nTCP/IP的分层管理\n应用层：决定了向用户提供服务时通信的活动，ftp，dns，http\n传输层：对应用层提供连接的两台计算机的数据传输，TCP Transmission Control Protocol传输控制协议和UDP User Data Protocol用户数据报协议\n网络层：处理网络上的数据包，数据包是网络传输的最小数据单位，规定如何传输路线，传输数据包\n数据链路层：处理连接网络的硬件，网络适配器NIC网卡\n物理层\n 层次化好处：1.设计好接口，每个层次内部的设计可以自由改动 2.使设计变得更简单，应用层上的应用不需要考虑接收方的地理位置等\n IP、TCP、DNS IP IP协议位于网络层\nmac地址为网卡的固定地址，使用ARP协议（address resolution Protocol地址解析协议）凭借mac地址进行通信，解析ip到mac地址\n选择传输路线叫做路由选择\nTCP协议的可靠性 位于传输层\n将大数据块分割为报文段segment确保传输准确可靠\n将请求报文按照序号分为多个报文段，将每个报文段可靠的传输，收到后再根据序列号重组报文\n确保数据可到达：\n三次握手three way handshaking\nTCP标志 SYN synchronize和ACK acknowledgement\n具体过程：\n 发送端发送一个带有SYN标志的数据包 接收端收到后回传带有SYN/ACK标志的数据包 发送端传回带有ACK标志的数据包，握手结束  如果握手中的某个阶段中断，TCP协议会再次发送相同的数据包\nDNS 域名解析\nURI和URL URL是URI的子集\nHTTP协议 http是无状态协议\n使用cookie管理状态\n使用URI定位资源\n持久连接：任意一端未提出断开，则保持tcp连接状态，减少tcp连接重复建立和断开的开销\nHTTP 1.1中，所有连接默认为持久连接\npipeline技术：连续发送请求，不必等待上一个请求返回\nCookie 服务器响应报文中Set-Cookie header字段，告知客户端保存\n客户端再次请求时自动在header中加入cookie\nHTTP报文 换行符CR+LF，CR回车符0x0d，LF换行符0x0a\nheader + CR+LF + Body\n报文message是通信基本单位，8位组字节流\n实体entity 请求或响应的在和，包含实体header和实体body\n传输过程中可以对实体进行压缩\n实体可以分割传输\n获取部分内容的请求 传输中断的恢复机制\n在header中加Range\nRange: bytes= 1-5000\n断点续传\nHTTP状态码 1XX，正在处理 信息性状态 2XX，处理完毕 成功 3XX，重定向状态码 4XX，客户端错误状态码 5XX，服务器错误状态码\n200 OK\nHEAD方法不会返回body\n204 No Content 处理成功，但是response中不包含实体\n206 Partial Content 客户端进行了范围请求\n301 Moved Permanently 永久重定向，资源分配了新的URI\n302 Found 临时重定向\n303 See Other 客户端用GET，临时重定向（比如POST访问时返回303，需要改GET方法重定向到另一个URI）\n304 Not modified 我有你要的资源但是不让你访问\n307 Temporary Redirect 临时重定向\n400 Bad request\n401 Unauthorized\n403 Forbidden 不允许访问\n404 Not Found 找不到资源\n500 Internal Server Error 内部错误\n503 Service Unavailable 服务器超负荷\nWeb服务器 虚拟主机 一台服务器可以绑定多个域名\n通过dns解析\n代理 网关 隧道 代理 转发中间人\n每次转发会追加写入via首部\n代理服务功能：缓存技术，访问控制，获取日志\n缓存代理：将资源缓存在代理服务器上，不从原服务器获取（有点像redis\n透明代理：转发请求和响应，不添加其他内容\n网关 转发客户端请求到实际程序\n网关与服务器使用非http通信\n隧道 在客户端和服务器直接中转，保持双方的通信连接\n本身不解析http请求，只传输\n缓存 客户端缓存和服务器缓存\n客户端缓存存储在浏览器\n各种header的作用\nCookie相关header Set-Cookie: 后跟name=value的序列\nCookie: 发送cookie\nHTTPS http缺点：\n 明文被窃听 不验证双方身份，可伪装 无法验证完整性，可以篡改  使用SSL secure socket layer或TLS transport layer security安全层传输协议\nSSL使用证书确定身份\n防止篡改：使用md5或sha-1等校验方法校验报文完整性\nHTTP+通信加密+证书+完整性保护\n通信接口部分用ssl和tls协议代替\nhttp先和ssl通信，ssl再和tcp通信\n非对称加密 公钥进行加密，私钥进行解密\n通信步骤  客户端发送client hello开始ssl通信 服务器响应server hello 服务器发送certificate报文，包含公钥证书 服务器发送server hello done 客户端发送client key exchange报文响应，ssl握手部分结束 客户端发送change cipher spec 客户端发送finished 服务器发送change cipher spec ssl连接建立成功，开始进行http请求 ","date":"2022-01-16T22:25:00Z","permalink":"https://ez4zzw.github.io/p/%E5%9B%BE%E8%A7%A3http%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","title":"图解HTTP读书笔记"},{"content":"异常控制流\nCSAPP CH-8\n指令地址间的过度为控制转移，控制转移序列叫做控制流\nECF Exceptional Control Flow 异常控制流是系统实现IO，进程和虚拟内存的基本机制\nECF用于应用程序和操作系统的交互\ntry catch等语句基于ECF\n异常 硬件实现，操作系统实现\n异常是控制流中的突变\n比如虚拟内存缺页， 算术溢出， 除以0\n事件：处理器状态变化\n处理器检测到事件发生，通过异常表的跳转表，进行间接过程调用，由异常处理程序处理异常，根据异常事件类型，进行：\n 将控制返回给当前指令I-curr 控制返回给I-next，则没有发生异常，执行下一条指令 终止被中断的程序  异常处理 每种异常分配一个异常号，是异常表中的索引\n系统启动时操作系统预处理一张异常表，第k个元素包含异常k的处理程序的地址\n异常表基地址寄存器存放异常表的起始地址\n过程调用和异常的区别：\n 过程调用，跳转回处理程序前，处理器将返回地址入栈；异常为根据异常以及处理结果进行跳转 处理器会将额外处理器状态入栈 控制从用户程序转移到内核，都被压入内核栈 异常处理运行在内核模式  硬件触发异常，异常处理程序在软件中完成\n异常类型 中断 interrupt 来自IO设备 异步 返回到下一条指令\n陷阱 trap 有意异常 同步 返回到下一条指令\n故障 fault 潜在的可恢复错误 同步 可能返回当前指令\n终止 abort 不可恢复错误 同步 不会返回\n中断 异步发生，来自处理器外部的IO设备\n异步的含义：中断不是由一个专门指令造成的\n异常由中断处理程序处理\ntrap和系统调用 trap是指向指令的结果，用于在用户程序和内核之间提供一个接口，叫做系统调用\n读文件，创建进程fork，加载程序\n故障 由错误情况引起，被故障处理程序修正，控制返回到引起故障的指令，从而重新执行，否则返回到内核的abort，将引起故障的程序终止。\n终止 硬件错误，dram或者sram损坏 会返回abort然后终止应用程序\nLinux x86-64系统中的异常 故障号和cpu架构有关\nLinux中的故障和终止 除法错误：除以0，Unix会直接终止程序 floating exception\n一般故障保护：神秘的错误，如程序引用了未定义的虚拟内存地址，或者访问只读的文本，也就是段错误segmentation fault\n缺页：会从新执行产生故障的指令，将磁盘上的虚拟内存的一个页面映射到物理内存的一个页面，然后重新执行这条指令\n机器检查：是在导致故障的指令执行中检测到致命的硬件错误时发生的\n系统调用 请求内核的服务\n每个系统调用有一个编号，对应内核中跳转表的偏移量\nc语言中syscall函数，c一般封装了系统调用库函数，带着参数陷入内核，将系统调用的执行状态返回\nLinux系统调用的参数通过寄存器传递\n进程 执行中程序的实例，每个程序运行在某个进程的上下文context中\n上下文包括内存中程序的代码和数据，栈，通用目的寄存器，程序计数器，环境变量，文件描述符集合\n提供抽象：独立的逻辑控制流，假象程序独占处理器；私有地址空间，假象程序独占内存\n逻辑控制流是交错的，进程轮流使用处理器，每个进程执行流的一部分\n并发流 逻辑流可以是进程、线程等\n并发：多个流并发的执行\n运行在同一个处理器上\n并行：运行在不同处理器核上\n每个控制流中的一部分是时间片\n私有地址空间 进程为每个程序提供假象，n位地址机器，地址空间2^n，\n底部用于用户程序：包括代码，数据，堆，栈\n顶部给内核\n用户模式和内核模式 通过模式位寄存器控制\n/proc文件系统，包含系统属性，如内核数，cpu类型，某进程使用的内存段地址\n上下文切换 实现多任务\n内核为每个进程维护一个上下文，包含重新启动一个进程所需的状态\n包含通用目的寄存器，浮点寄存器，程序计数器，用户栈，状态寄存器，内核栈，内核数据结构（描述地址空间的页表、当前进程信息的进程表、已打开文件的文件表）\n内核可以通过调度决定执行哪个进程\n 保存当前进程上下文 恢复先前被抢占进程的上下文 控制传递给新恢复的进程  错误处理 全局变量 errno，strerror(errno)\n进程控制 获取进程id pid\n","date":"2022-01-14T10:12:15Z","permalink":"https://ez4zzw.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/","title":"【操作系统】异常控制流"},{"content":"redis基础知识以及一些应用场景总结\n基础 内存数据库\n优于memcached，速度上功能上\n基础数据结构：\n String，List，Set，Hash，ZSet  redis命令手册\nString key-value\n指令GET，SET，DEL\nLIST key-list\n指令\n LPUSH，RPUSH 推入列表的左端和右端 LPUSH listname item 返回值为列表长度 LPOP，RPOP，从左端和右端删除元素 LINDEX，获取列表指定位置的元素 LINDEX listname 1 LRANGE，获取给定范围内的所有元素 LRANGE listname 0 -1 0为开始索引，-1位结束索引  SET key-set\nSADD, SMEMBERS, SISMEMBER, SREM\nHASH key-hash table\n内部也是key-value\nHSET, HGET, HGETALL, HDEL\nZSET key-zset\nZADD, ZRANGE, ZRANGEBYSCORE, ZREM\n一个文章投票系统的设计 基础功能设计 根据文章的发布时间和投票数量计算一个评分，根据该评分来排序和展示文章\n要求：如果有一篇文章符合有趣文章的要求（支持票至少200张），放在排行榜前100位至少一天\n构造分数\n$ score = up\\ vote\\ *C + post\\ time $\n常量C可以选择432\n分析：一天的秒数为86400，文章达到有趣需要200票，可以利用86400/200=432来作为每个投票对得分的贡献\n保存评分以及存储文章信息\n使用hash结构存储文章的标题，文章的url，发布文章的用户，发布时间，得票数量等信息\n关于key的设置，可以使用任意字符作为分隔符，如article:ID\n使用两个zset，其中一个成员为文章id，分值为文章的发布时间，另一个成员为文章id，分值为文章的评分，使得网站可以按照发布时间和评分两种方式展示文章\n防止用户重复投票，建立已投票用户名单，使用set结构，key为voted:article_id\n需要用到的一些指令：\n ZSCORE 获取文章发布时间的有序集合，判断发布时间是否在一周内 SADD 若可投票，将用户添加到已投票的set中，操作成功则说明用户未向该文章投过票 ZINCRBY 将文章的评分增加432 HINCRBY 对hash结构中的文章投票数量进行更新  发布获取文章 发布文章需要新增id，使用计数器，执行incr指令\nincr keyname 可以得到计数器++之后的值\n使用sadd将发布者id添加到文章投票的用户集合中（避免自己给自己投票）\n集合的过期时间为一周，一周后自动释放expire\nHMSET存储文章相关信息\n执行zadd添加文章初始评分到保存评分的zset\n执行zadd添加文章发布时间到保存时间的zset\n使用HGETALL获取存储在hash中的文章结构\n使用ZREVRANGE取出评分最高的文章和最新发布的文章：\n 使用ZREVRANGE获取文章的id 使用HGETALL获取详细内容  文章分组 TODO\n","date":"2022-01-03T16:22:27Z","permalink":"https://ez4zzw.github.io/p/redis%E5%AE%9E%E6%88%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","title":"redis实战读书笔记"},{"content":"承接Unix I/O这一章节，了解网络如何构建以及客户端和服务器如何通信，socket函数相关内容的学习\nCSAPP Ch-11 笔记\nCS编程模型 客户端服务器模型\n一个服务器进程，多个客户端进程\n基本操作是事务transaction\n有四步\n 客户端向服务器发送请求，发起一个事务 服务器解释请求，用响应的方式操作资源 服务器返回响应，等待下一个请求 客户端接受响应并处理  网络 网络是一种IO设备，是数据源和数据接收方\n网络数据接收后经IO和内存总线复制到内存，双向传输\n以太网Ethernet是局域网技术\n电缆链接主机和集线器，集线器广播每个端口的信息到所有主机\n主机发送帧frame开头的信息，包括header，随后是有效载荷，payload，网内每个主机都可以见，只有目的主机读取\n桥接以太网，主机\u0026hellip;-集线器-桥-桥-集线器-\u0026hellip;主机，网桥会根据通信需要来选择是否转发帧到其他网桥\n连接多个局域网使用路由器\n协议解决网络传输中的差异，提供命名机制（网络地址）和传输机制（包头+有效载荷）\n数据发送过程：\n 主机A通过系统调用从虚存加载数据到内核缓冲区 主机A上的协议软件添加互联网包头和接口帧头，互联网包头指向主机B，接口帧头指向主机LAN1。是封装关系。 帧头的包数据为互联网包头以及数据，帧头为其自己的互联网包头 LAN1适配器复制数据到网络 路由器读取数据猴传送到协议软件 协议软件读取目标互联网地址，作为路由表的索引转发到对应的LAN2适配器 LAN2适配器复制帧到网络 到达主机B，从适配器读取帧，传输到协议软件 协议软件去除包头和帧头，读取数据，主机B通过系统调用拷贝数据到虚拟地址空间  全球IP 客户端（用户）-【socket接口系统调用】-TCP/IP（内核）-【硬件接口，中断】-网络适配器（硬件）-全局IP因特网\n使用socket接口函数和Unix IO函数通信，socket函数为系统调用，调用内核的TCP/IP函数\nTCP/IP是一个协议族，IP协议提供命名方法和传递机制，数据报\nIP机制不可靠，数据报丢失不会自动恢复\nUDP UNreliable datagram protocol，不可靠数据报协议对其进行了扩展，包可以在进程之间传递，而不是主机之间\nTCP是基于IP的协议，进程间可靠的全双工连接\n因特网的特性：\n 主机集合映射到32位ip地址 ip地址映射为一组域名 主机上的进程能够通过连接其他主机的进程通信  ipv4和ipv6：\n version 4：32位地址 version 6：128位地址  ip地址 32位无符号整数，8*4\nTCP/IP统一了字节顺序，大端法\n使用点分十进制表示，Linux查看主机地址\nhostname -i 域名 一级域名mil，edu，gov，com，cn\n二级域名whut.edu\nhosts文件手工维护ip和域名的映射\nDNS，domain name system\nLinux使用nslookup查看域名ip\nnslookup baidu.com 通常域名和ip一一对应，多个域名也可以对应同一ip，泛域名cs.whut.edu, ee.whut.edu\n多个域名可以映射到同一组的多个ip，如www.twitter.com和twitter.com映射到199.16.156.*\n因特网连接 客户端和服务器在连接上发送和接收字节流来通信，点对点，全双工，可以同时双向流动\nsocket是连接的端点，每个socket都有socket地址，由地址:端口构成，十六位端口号0-65535\n客户端发起请求时，客户端socket地址端口由内核自动分配，临时端口；服务器的为默认端口\nweb使用80（http），电子邮件地址使用25（SMTP）\n可以通过/etc/services看查知名服务默认端口\n一个连接两端的socket地址是唯一确定的，socket pair，格式(cliaddr:cliport, servaddr:servport)，即(客户端IP:客户端端口,服务器IP:服务器端口)\nsocket接口 一组函数实现，和Unix IO配合创建网络应用\n流程：\n客户端getaddrinfo-\u0026gt;socket-\u0026gt;connect发送连接请求-\u0026gt;rio_writen-\u0026gt;rio_readlineb-\u0026gt;close发送EOF\n服务器getaddrinfo-\u0026gt;socket-\u0026gt;bind-\u0026gt;listen-\u0026gt;accept接受请求-\u0026gt;rio_readlineb读客户端的write-\u0026gt;rio_writen写入response-\u0026gt;rio_readlineb读取EOF-close\nsocket地址结构 对于Linux内核，socket就是一个有描述符的打开文件\nsocket地址存放与sockaddr_in，包含AF_INET，sin_port为16位端口号，sin_addr为32位ip地址，都是以大端法存放\nsocket函数 客户端和服务器使用socket函数创建socket描述符\nclientfd = Socket(AF_INET, SOCK_STREAM, 0); AF_INET表示使用32位IP地址，SOCK_STREAM表示该socket为连接端点\n该函数返回的描述符为部分打开的，不能读写，将有客户端完成打开socket的工作\nconnect函数 客户端调用connect函数建立和服务器连接\nconnect函数会阻塞一直到连接成功建立或者错误，成功后clientfd为可读写状态\n由getaddrinfo函数获取connect的参数\nbind函数 bind函数通知内核将addr中的服务器socket地址和socket描述符socketfd联系到一起\n由getaddrinfo函数获取bind的参数\nlisten函数 客户端是发起请求的主动实体，服务器是被动实体\n默认，内核认为socket函数创建的描述符为主动socket，服务器通过listen函数通知内核描述符是被服务器使用而不是客户端\n将socketfd从主动socket转化为监听socket，监听socket可以接受客户端的连接请求\n参数backlog为队列中未完成的请求数量，一般设置较大的数\naccept函数 服务器使用accept函数等待客户端的连接请求\n已经获得监听描述符connfd，listenfd，返回一个已连接描述符，该描述符可以被Unix IO读写，可以和客户端通信，将connfd返回给客户端\n与监听描述符不太，监听描述符是客户端连接请求的端点，只创建一次，存在于服务器的整个生命周期\n已连接描述符为客户端和服务器直接已经建立连接的端点，服务器每次接受请求都会创建\n可以理解为后端程序当前已经监听系统的某个端口，此时客户端请求后后端在该基础上创建一个线程去处理该请求\n主机和服务的转换  getaddrinfo 将主机名、主机地址、服务名端口号转为socket地址结构 返回result为一个addrinfo链表，每个结构对应一个host和service的socket地址结构 客户端调用之后，遍历链表，尝试每个地址，直到socket和connect成功，建立连接 服务器会遍历每个地址，直到socket和bind成功 避免内存泄露，最后调用freeaddrinfo释放链表 参数讲解跳了 getnameinfo 将socket地址转换为主机和服务名字符串  socket接口辅助函数 以上接口的整合封装\n open_clientfd int open_clientfd(char *hostname, char *port)  open_clientfd建立和服务器的连接，返回描述符，可以直接用于Unix IO函数读写\n流程：getaddrinfo，返回addrinfo链表，遍历链表尝试建立连接，失败则关闭描述符，成功后释放链表将描述符（connfd）返回给客户端\nopen_listenfd 服务器创建监听描述符  int open_listenfd(char *port)\n遍历链表直到调用socket和bind成功\necho实例 简单的单线程处理服务器\nEOF概念，并不是字符，而是内核检测的一个条件，read函数返回0时，程序检测到EOF条件。磁盘文件读写，文件位置超出长度，判断EOF。网络连接，进程关闭连接其中一端，触发EOF。尝试读取通信中字节流的最后一个字节之后的字节，触发EOF。\nWeb服务器 Web基础 HTTP协议，Hypertext Transfer Protocol超文本传输协议\nWeb内容 内容是MIME，多用途的网际邮件扩充协议，类型相关的字节序列\n 读取一个磁盘文件，将内容返回给客户端，磁盘文件为静态内容 运行可执行文件，将输出返回  使用URL标识每个文件\n根据目录指定返回规则\n根目录为网页静态内容的根目录\n后缀为/时服务器自动补全默认文件名\nHTTP事务 使用Linux的Telnet和任何web服务器执行事务\ntelnet url port HTTP请求\n请求行method URI version\n0个或多个请求报头\n一个空的文本行终止报头列表\nbody\nGET / HTTP/1.1 Host: www.baidu.com 请求方法GET、POST、OPTIONS、HEAD、PUT、DELETE、TRACE\nURI是相应URL的后缀，包括文件名和参数\nversion为http版本\nMozilla文档\nheader可以存放多种信息，比如cookie等\nhost请求头在HTTP 1.1位必须，1.0中不必须。代理缓存proxy cache会使用host报头，理解为反向代理？\n客户端和服务器直接可以由代理，代理链\nHTTP响应组成：\n响应行 0个或多个响应头 终止报头的空行 响应主体body 响应行格式\nversion status-code status-message\nversion对于HTTP版本，code为\n1** 200 301 400 403 404 501 505 更多状态码\n响应头中应有Content-Type，告知客户端主体内容的MIME类型，Content-Length，告知主体的字节大小\n 传递参数  URI或者请求主体 2. 服务器传递参数给子进程\nfork一个子进程，调用execve在子进程上下文中执行对应的程序，通过环境变量，如QUERY_STRING, REQUEST_METHOD等信息，程序做出对应的处理\n子进程的输出到哪里？ CGI程序（通用网关接口Common Gateway Interface），将内容发送到标准输出，在子进程调用CGI程序之前，使用Linux dup2函数将标准输出重定向到和客户端相连的已连接描述符，CGI程序写入到标准输出的内容都会直接到达客户端  实现一个Web服务器 使用c配合CSAPP提供的封装搭建一个简易的web服务器\n总结 本章主要了解了Unix如何建立一个网络连接，以及数据传输的具体过程，socket的设计巧妙之处，以及Linux一切皆文件的进一步理解。\n","date":"2022-01-03T13:37:02Z","permalink":"https://ez4zzw.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","title":"【操作系统】网络编程"},{"content":"高级别的IO程序，如c中的printf和scanf，c++中的\u0026gt;\u0026gt;和\u0026lt;\u0026lt;，都依赖Unix 系统级IO\nCSAPP Ch-10 笔记\nUnix IO Linux文件即是m个字节的序列$B_0, B_1, \u0026hellip;, B_k, \u0026hellip;, B_{m-1}$\n所有的IO设备（网络，磁盘，终端）被抽象为文件，输入和输出被作为相应文件的读和写进行，Linux内核只需要暴露一个简单低级的应用接口\n输入和输出的统一方式:\n 打开文件：应用程序请求IO设备，内核返回描述符 Linux Shell创建的进程开始时有三个文件：标准输入0，标准输出1，标准错误2 改变当前的文件位置：内核存储文件位置k，初始为0，通过seek改变这个偏移量 读写文件：读为复制字节到内存，当k\u0026gt;=m时，会触发EOF条件；写为复制字节到一个文件中，从当前位置k开始，然后更新k 关闭文件：通知内核，内核释放文件打开时创建的数据结构，释放描述符，进程终止时内核会释放打开的文件以及内存  文件  普通文件：文本文件：ASCII或Unicode字符文件，其他的都是二进制文件，对内核而言无区别，换行符\\n对应ASCII LF 目录：包含一组链接的文件，链接将文件名映射到一个文件 套接字socket：与另一个进程进行跨网络通信的文件 命名通道named pipe，符号链接，字符和块设备  绝对路径：以斜杠开始/home/test\n相对路径：以文件名开始,../test\n打开和关闭文件 open函数打开或创建文件\n返回一个文件描述符，在进程中没有打开的最小描述符 几种控制参数flags\nO_RDONLY 只读 O_WRONLY 只写 O_RDWR 可读可写 O_CREAT 文件不存在则创建空文件 O_TRUNC 存在则截断，清空 O_APPEND 追加写入 mode参数控制读写权限\n每个进程都有umask\n访问权限为mode \u0026amp; ~umask\nclose(int fd)关闭文件，成功返回0，失败-1\n读写文件 read和write\n输入的size为unsigned long类型，ssize_t为long类型，因为read和write函数需要返回-1\nread和write读写遇到不足的情况：\n 读取时遇到EOF 从终端读文本行 读写socket：网络延迟导致read和write返回值不足  RIO包 Robust IO 读取文件元数据 stat和fstat函数，读取文件信息\n读取目录内容 opendir函数\n共享文件  描述符表，每个进程之间独立 文件表，打开文件的集合，所有进程共享，包含文件位置，引用计数，指向vnode表的指针，当引用计数为0时，操作系统删除表项 v-node，进程间共享，包含stat中的信息，st mode，st size  IO重定向 标准输出重定向到磁盘文件\n覆盖写入文件之前的内容\n使用dup2函数，将终端的输出关闭，改为磁盘文件，磁盘文件引用次数+1\n标准IO 标准IO将打开的文件模型化为一个流，减少系统级IO操作的调用\n第一次getc调用IO read函数读取到缓冲区，之后调用将缓冲区第一个字节返回给应用程序\n选取IO函数问题 socket中不要使用标准IO，可能会导致崩溃，使用RIO函数/Unix IO\n","date":"2022-01-03T10:31:33Z","permalink":"https://ez4zzw.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B3%BB%E7%BB%9F%E7%BA%A7io/","title":"【操作系统】系统级IO"},{"content":"编译原理笔记，词法语法分析\n词法分析 有穷自动机 DFA $f: K \\times \\sum \\to K$是一个单值函数，任何输入符号都唯一的确定了下一个状态\n不确定的有穷自动机 NFA 至少一个初态节点，若干个终态节点 DFA是NFA的特例\n子集法 NFA转换为DFA 对于状态集合$I$，定义两个运算\n  集合$I$的$\\epsilon-Closure(I)$，是一个状态集$I$中的任何状态经过任意条$\\epsilon$弧能到达的状态集合 因为当输入符号为空时，则自动机停留在原来的位置上，所以有关系$\\forall S \\in I \\ \\ , S \\in \\epsilon-Closure(I)$\n  状态集合$I$的$a$弧转换，表示为$move(I,a)$，定义为状态集合J，其中$J$是所有那些可以从$I$中的某一状态经过一条$a$弧而到达的状态的全体 有关系$\\forall S_i \\in I \\ \\ , move(I,a)=f(S_1,a)\\bigcup f(S_2,a) \\bigcup f(S_3,a)\u0026hellip;$ 算法流程：\n  let C as a set save Status-Set let K_0 = epsilon-Closure(0) C \u0026lt;- epsilon-Closure(K_0) while(if C have set not visit) { visit[T] = true for a in Char Set { U := epsilon-Closure(Move(T,a)) if (U not in C) { C \u0026lt;- U } } } 经过状态重新命名可以得到DFA\nDFA的化简 化简 的DFA：没有多余状态，没有两个状态是互相等价的。 DFA可以通过消除无用状态和合并等价状态二转换成一个与之等价的最小状态的DFA\n无用状态：从开始状态触发，任何输入串都无法到达 或者从这个状态没有通路到达终态 ![[Pasted image 20211230203930.png]] 如s4，s6，s8，可以直接消除\nDFA中的状态等价条件：\n 一致性条件-状态s和t必须同时为可接受状态或不可接受状态 蔓延性条件-对于所有输入符号，状态s和t必须转换到等价的状态  分割法分解DFA状态： 步骤：\n 先将终态和非终态分割，作为两个子集，作为一个划分 在划分中对每个子集加上可输入字符，将可区别的状态拆分，得到新的划分 重复直到划分不可以再分割  化简后的DFA便于在计算机上实现\n由DFA化简为正规式 很简单 缩缩缩\n由正规式生成NFA $L(G)$表示文法G产生的语言的集合 $L(G1) = L(G2)$ 则两个文法等价 反正就是构造一个等价的$\\mathbb{NFA}$\n语法制导 按照语法结构构造 将正规式分解为子表达式 闭包：终态输入epsilon到达初态 分解方式不唯一 可以从头开始，也可以分部进行\n处理步骤：\n 如$r_1 r_2$，顺序拼接两个NFA 如$r1^*$处理闭包，终态输入epsilon链接到初态 如$r_1|r_2$，由初态输入epsilon到两个NFA，由两个NFA输入epsilon到达终态  语法分析 自顶向下 文法特点：\n 每个产生式右部都由终结符号开始 若两个产生式都由相同的左部，右部都由不同的终结符开始 分析过程是唯一的  FIRST集 $FIRST(\\alpha)={以\\alpha为左部的，产生式右部的第一个非终结符集合}$ 为a的开始符号集\nFOLLOW集 对于上下文无关文法，S是开始符号 $FOLLOW(A)={状态A后跟符号}$ 若A可以引导终止epsilon ，则加入#到FOLLOW集\n构造算法 对文法中每一非终结符A，构造FOLLOW(A)的算法如下：反复使用如下规则，直至FOLLOW集不再增大为止。 ⑴若A是文法的开始符号,则把输入结束符＃加入FOLLOW(A)中； ⑵若B→αAaβ,a是终结符,则把a加入FOLLOW(A)中； ⑶若B→αAXβ,X是非终结符,则把FIRST(Xβ)加入FOLLOW(A)中； ⑷若B→αA或B→αAβ,且β可以推导至ε，则把FOLLOW(B)加入FOLLOW(A)中。\nSELECT集 $SELECT(A \\to a)=(FIRST(a)-{\\epsilon})\\bigcup FOLLOW(A)$\nLL(1)文法：第一个L表示自顶向下分析是从左到右扫描输入串，第二个L表明分析过程中将用最左推导，1表明只需要向右看一个符号便可以决定如何推导。 充要条件: 对于每个非终结符A，的两个不同产生式 $SELECT(A \\to \\alpha)\\bigcap SELECT(A \\to \\beta)=\\varnothing$\n非LL(1)文法到LL(1)文法的等价转换 LL(1)文法的性质： ① LL(1)文法是无二义性的； ② LL(1)文法不含左递归； ③ LL(1)文法没有公共左因子。\n消除左递归 消除回溯：提取左公因子 改造成LL1文法\n消除直接左递归： 例如： A→Aα|β 对A引入一个新的非终结符A′，把上式改写为： A →βA′ A′→αA′|ε 例2： E→E +T | T T→T * F | F F→i |（E） 改造为 E→TE′ E′→+T E′|ε T→FT ′ T′→* FT′|ε F→i |（E）\n消除间接左递归 把式子带入，然后按照消除直接左递归的方法去消除 S → Aα|β ⑴ A → Sγ ⑵ 得到 S → Sγα|β ⑶ 消除左递归 S → βS′ S ′→γαS′|ε\n","date":"2022-01-02T10:33:48Z","permalink":"https://ez4zzw.github.io/p/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/","title":"编译原理笔记"},{"content":"讲解机器代码以及汇编\nTODO了，有个bomb lab\n","date":"2021-12-10T21:19:54Z","permalink":"https://ez4zzw.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/","title":"【操作系统】程序的机器级表示"},{"content":"本章为CSAPP Ch-2的读书笔记，复习了数据的存储方式\n信息存储 最小可寻址内存单位 -字节byte 一般为8位的块\n内存被视为一个很大的字节数组，也就是虚拟内存，每个字节用地址标识\n地址的集合为虚拟地址空间\n虚拟内存中包含程序的数据，指令，控制信息\n十六进制表示 跳\n字数据大小 字长为数据标称大小\n字长决定了虚拟地址空间的最大大小，字长为w的机器虚拟地址范围是[0, $2^w-1$]\n最多访问$2^w$个字节\n32位和64位\ngcc -m32可以编译32位程序\ngcc -m64可以编译64位程序\n寻址和字节顺序 最低有效字节在前-小端法\n最高有效字节在前-大端法\n部分cpu支持双端法 ，但是操作系统只支持小端模式（iOS \u0026amp; Android）\n大小端的影响  网络收发统一顺序 汇编阅读字节顺序 按字节打印  字符串表示 以null结尾的字符数组\n每个字符使用ASCII码，在各个系统都相同，因此文本数据的表示有更高的平台独立性（than二进制数据）\n终止字符0x00\nUTF-8，每个字符使用一个字节来编码\n布尔代数 null\n位运算 掩码运算\n 掩码：表示从一个字中选出来位的集合\n 整数表示 跳\n","date":"2021-12-10T13:02:03Z","permalink":"https://ez4zzw.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/","title":"【操作系统】信息的表示和处理"},{"content":"Description 给定一个数字N，给定一个数字的集合，使用集合里的数字构造出小于数字N的最大数。\n如N = 23131，集合为{2, 4, 9}\n则构造出22999\nSolution 分两种情况讨论，构造的数字长度和N一样，或者比N少一位，若长度一样，则是从头开始按照比数字N小的数构造，若长度少一位可以直接用集合中的最大数填满。\nCode #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt;#include\u0026lt;algorithm\u0026gt;#include\u0026lt;string\u0026gt;#include\u0026lt;map\u0026gt;#include\u0026lt;set\u0026gt;#include\u0026lt;vector\u0026gt;#include\u0026lt;queue\u0026gt;const int MAXN = 1e5; const int MOD = 1e9+7; typedef long long ll; using namespace std; // 23131 // 2 4 9 // 22999 // 229 // 2 // 22 int N, x; vector\u0026lt;int\u0026gt; nums; vector\u0026lt;int\u0026gt; v; int maxv = -1; int main() { cin \u0026gt;\u0026gt; N; v.clear(); nums.clear(); while (cin \u0026gt;\u0026gt; x) { v.push_back(x); maxv = max(maxv, x); } int temp = N; int setNumber = v.size(); sort(v.begin(), v.end()); while (temp) { nums.push_back(temp % 10); temp /= 10; } reverse(nums.begin(), nums.end()); int number = 0; int ans = 0; bool done = true; for (int i = 0; i \u0026lt; nums.size(); i++) { number = number*10 + nums[i]; cout \u0026lt;\u0026lt; \u0026#34;number = \u0026#34; \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl; bool find = false; for (int j = setNumber - 1; j \u0026gt;= 0; j--) { if (v[j] \u0026lt;= number) { ans = ans*10 + v[j]; find = true; number -= v[j]; break; } } if (!find) { done = false; break; } } cout \u0026lt;\u0026lt; \u0026#34;size \u0026#34; \u0026lt;\u0026lt; nums.size() \u0026lt;\u0026lt; endl; if (!done) { for (int i = 0; i \u0026lt; nums.size() - 1; i++) { cout \u0026lt;\u0026lt; maxv; } } else { cout \u0026lt;\u0026lt; ans; } return 0; } ","date":"2021-12-10T12:46:33Z","permalink":"https://ez4zzw.github.io/p/%E7%AE%97%E6%B3%95%E9%A2%98%E5%B9%B8%E8%BF%90%E6%95%B0%E5%AD%97/","title":"【算法题】幸运数字"},{"content":"https://leetcode-cn.com/problems/largest-number/\nDescription 给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。\n注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。\nSolution 将数字全部转为字符串，进行逐个比较，比较规则为：\n 从最高位开始比较，如果第一个数字较大，则把较大的排在前面 比较后续数字，将出现更大数字的数排在前面 若数字a为数字b的前缀，或相反，则返回a+b\u0026gt;b+a，判断如何构造可以使得数字更大  注意数字全为0的情况\nsort里用lambda很香\nCode class Solution { public: string largestNumber(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;string\u0026gt; nums_str; bool zero_flag = false; nums_str.clear(); for (auto num : nums) { if (num != 0) zero_flag = true; nums_str.push_back(to_string(num)); } if (!zero_flag) return \u0026#34;0\u0026#34;; sort(nums_str.begin(), nums_str.end(), [](const string \u0026amp;a, const string \u0026amp;b) -\u0026gt; bool { if (a[0] != b[0]) { return a[0] \u0026gt; b[0]; } for (int i = 1; i \u0026lt; min(a.size(), b.size()); i++) { if (a[i] == b[i]) continue; return a[i] \u0026gt; b[i]; } return a + b \u0026gt; b + a; }); string ans = \u0026#34;\u0026#34;; for (auto str : nums_str) { ans += str; } return ans; } }; ","date":"2021-12-09T21:22:30Z","permalink":"https://ez4zzw.github.io/p/leetcode-179%E6%9C%80%E5%A4%A7%E6%95%B0/","title":"【leetcode-179】最大数"},{"content":"CSAPP读书笔记 Ch-1 宏观看一看操作系统，很多知识之前确实没了解到，值得一读\nCh1 源程序 -\u0026gt; 预处理器 (cpp) \u0026mdash;hello.i\u0026mdash;\u0026gt; 编译器(ccl) \u0026mdash;\u0026ndash;hello.s\u0026mdash;\u0026ndash;\u0026gt; 汇编器(as) \u0026mdash;-hello.o(binary) with printf.o\u0026mdash;\u0026gt; 连接器 \u0026mdash;\u0026mdash;-\u0026gt; 可执行二进制文件\n  主存：临时存储设备 DRAM组成\n  进程：并发执行多个进程-上下文切换\n  进程运行所需的所有状态信息 上下文\n例如：PC和寄存器文件的当前值，主存的内容\n  并发执行 ：一个进程的指令和另一个进程的指令交错执行\n  线程：进程是由多个线程的执行单元组成 ，运行在进程的上下文中，共享同样的代码和全局数据\n  多线程共享数据比多进程容易\n  虚拟内存：对于进程，提供虚拟地址空间\n包含 程序代码和数据，堆malloc 和free，共享库so，栈，内核虚拟内存为内核保留，不允许应用程序读写这个区域\n基本思想：一个进程虚拟内存的内容存储在磁盘，利用主存座位磁盘的高速缓存\n  并发和并行：\n 并发：同时具有多个活动的系统 并行：用并发是一个系统运行的更快 线程级并发：在一个进程中执行多个控制流 指令级并行：流水线技术 单指令，多数据并行 SIMD并行    操作系统的抽象：\n 文件是对I/O设备的抽象 虚拟内存是对主存和磁盘的抽象 进程是对处理器，主存和IO设备的抽象    网络可以看做一种IO设备\n ","date":"2021-12-09T19:58:54Z","permalink":"https://ez4zzw.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","title":"操作系统"},{"content":"前记 潘达某天在本机docker部署了他的服务，但是发现无论如何都无法ping通，他冥(疯)思(狂)苦(谷)想(歌)，逛遍了GitHub上的各种issues，stack overflow上的各种回答，各种博客文章，都没有解决他的问题，直到他的mentor来到他的电脑前，一通命令猛如虎啊，发现他竟然在docker内监听了容器中的127.0.0.1的端口，那必然会访问不到，检查发现原来是在服务的config中写了magic number，让服务开在了127.0.0.1，在本地这样必然是没问题的，但是如果要与外部进行通信，那就要改成0.0.0.0了。\n又是一天，潘达又部署起了他的rpc服务，想在服务器上部署一个微服务然后本机去访问，测试框架是否可以通过域名通信各个微服务，然而，服务器上启动成功，本地依然迟迟无法连接，上来就是一个curl: (7) Failed to connect to ababab.ababab port ababa: Connection refused，安全组也放行了对应的端口，然后他看到了一行127.0.0.1，但是他感觉不是这个问题，继续debug，然后再次呼叫他的mentor，希望得到帮助，还是一顿操作猛如虎，找到了那个127.0.0.1的监听服务，乐。\n于是，这篇blog就诞生了。 \n127.0.0.1 和 localhost 127.0.0.1是回路地址中的一个，在计算机中127.*.*.*被称为回路地址，所有对这些地址的请求都会让本机接收，最最重要的是，外部设备也不能通过这个地址访问到本机的服务。 localhost其实是一个域名，他一般指代本机的网络，大多数机器都会默认localhost指向127.0.0.1，可以自行修改为其他地址。\n0.0.0.0 可能我们都会以为localhost为本地的网络地址，但实际上真正的本地网络是0.0.0.0，但是他是不能被ping通的。在服务器中，0.0.0.0并不是一个真实的的IP地址，它表示本机中所有的ipv4地址。监听0.0.0.0的端口，就是监听本机中所有IP的端口。如果服务监听在0.0.0.0，那么外部访问的所有ip都可以通过对应的端口访问这个服务。\n所以问题得到了解答，如果是在本机的话，127.0.0.1的话显然是没问题的，但是如果要将服务上云或者容器，就需要进行调整，首先要避开127.0.0.1，再根据是否只允许内网ip访问进行端口映射和服务监听。\n后记 这两次问题前前后后折腾了半天，本想自己找到解决办法，查了不少资料后还是要寻求运维☁️的帮助，其实问题并不是很大，还是自己的知识储备不够，不能准确定位的问题的所在。另外，计网应该开始看了。🐼。\n","date":"2021-07-26T22:23:38Z","permalink":"https://ez4zzw.github.io/p/127.0.0.1localhost%E5%92%8C0.0.0.0%E6%9A%A8%E4%B8%80%E6%AC%A1%E4%B8%A4%E6%AC%A1%E7%9A%84%E7%A5%9E%E7%A5%9E%E7%A7%98%E7%A7%98%E7%9A%84debug%E8%AE%B0%E5%BD%95/","title":"127.0.0.1,localhost和0.0.0.0暨🐼一次两次的神神秘秘的debug记录"},{"content":"Bilibili（哔哩哔哩）是当下最热门的视频播放网站，人们在该网站对视频进行浏览，会根据自己喜好对视频进行点赞、投币、收藏、分享、回复等操作，Bilibili同时还有一个排行榜机制，记录了近期比较热门的视频，并给出了一个评分，排行榜的排序规则即根据该评分，本文将根据这些排行榜视频的各项数据，进行线性回归分析，结合实际情况找出对评分影响最大的数据。\nBilibili提供了获取排行榜数据的API，因此我们可以利用该API获取实时的排行榜数据，获取的数据为json格式，经过解析，已将数据保存至Bilibili.csv文件中。\n本文的思路即为多元线性回归，在统计学中，线性回归（linear regression）是利用称为线性回归方程的最小二乘函数对一个或多个自变量和因变量之间关系进行建模的一种回归分析。这种函数是一个或多个称为回归系数的模型参数的线性组合。只有一个自变量的情况称为简单回归，大于一个自变量情况的叫做多元回归（multivariable linear regression）。\n完成了对各个自变量权重的计算，找出了对评分影响权重最高的因素，并得到了验证。\n数据获取 在哔哩哔哩官网首页处获取排行榜信息的API，得到为\nhttps://api.bilibili.com/x/web-interface/ranking/v2?rid=0\n请求参数为\n rid 分类，0代表全部分类  返回格式为json格式，json中的data字段为视频信息数组。\n为了防止请求次数过多增加服务器压力，导致本机IP禁止访问哔哩哔哩，先将请求的response保存到data.txt文件中。\n使用python的json包进行解析\n{ \u0026#34;aid\u0026#34;: 375696064, \u0026#34;videos\u0026#34;: 1, \u0026#34;tid\u0026#34;: 17, \u0026#34;tname\u0026#34;: \u0026#34;单机游戏\u0026#34;, \u0026#34;copyright\u0026#34;: 1, \u0026#34;pic\u0026#34;: \u0026#34;http://i0.hdslb.com/bfs/archive/85005893d4c4959ff096d6fb061040e223842bcb.jpg\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;史上最骚魔法师！(第二集)\u0026#34;, \u0026#34;pubdate\u0026#34;: 1621566911, \u0026#34;ctime\u0026#34;: 1621566912, \u0026#34;desc\u0026#34;: \u0026#34;本期请到了Warma参与配音！鼓掌！！！！！\\n游戏：Darkside Detective\\n第一集：BV1M64y1m7gA\\n各位如果看得开心，希望三连支持一下！\u0026#34;, \u0026#34;state\u0026#34;: 0, \u0026#34;duration\u0026#34;: 658, \u0026#34;mission_id\u0026#34;: 24025, \u0026#34;rights\u0026#34;: { \u0026#34;bp\u0026#34;: 0, \u0026#34;elec\u0026#34;: 0, \u0026#34;download\u0026#34;: 0, \u0026#34;movie\u0026#34;: 0, \u0026#34;pay\u0026#34;: 0, \u0026#34;hd5\u0026#34;: 0, \u0026#34;no_reprint\u0026#34;: 1, \u0026#34;autoplay\u0026#34;: 1, \u0026#34;ugc_pay\u0026#34;: 0, \u0026#34;is_cooperation\u0026#34;: 0, \u0026#34;ugc_pay_preview\u0026#34;: 0, \u0026#34;no_background\u0026#34;: 0 }, \u0026#34;owner\u0026#34;: { \u0026#34;mid\u0026#34;: 546195, \u0026#34;name\u0026#34;: \u0026#34;老番茄\u0026#34;, \u0026#34;face\u0026#34;: \u0026#34;http://i0.hdslb.com/bfs/face/bc5ca101313d4db223c395d64779e76eb3482d60.jpg\u0026#34; }, \u0026#34;stat\u0026#34;: { \u0026#34;aid\u0026#34;: 375696064, \u0026#34;view\u0026#34;: 1149043, \u0026#34;danmaku\u0026#34;: 7300, \u0026#34;reply\u0026#34;: 3278, \u0026#34;favorite\u0026#34;: 37490, \u0026#34;coin\u0026#34;: 98319, \u0026#34;share\u0026#34;: 1780, \u0026#34;now_rank\u0026#34;: 0, \u0026#34;his_rank\u0026#34;: 1, \u0026#34;like\u0026#34;: 210211, \u0026#34;dislike\u0026#34;: 0 }, \u0026#34;dynamic\u0026#34;: \u0026#34;用魔法击败魔法\u0026#34;, \u0026#34;cid\u0026#34;: 341808079, \u0026#34;dimension\u0026#34;: { \u0026#34;width\u0026#34;: 1920, \u0026#34;height\u0026#34;: 1080, \u0026#34;rotate\u0026#34;: 0 }, \u0026#34;short_link\u0026#34;: \u0026#34;https://b23.tv/BV1jo4y117Vf\u0026#34;, \u0026#34;short_link_v2\u0026#34;: \u0026#34;https://b23.tv/BV1jo4y117Vf\u0026#34;, \u0026#34;bvid\u0026#34;: \u0026#34;BV1jo4y117Vf\u0026#34;, \u0026#34;score\u0026#34;: 2446535 } 通过解析json格式文件并整理得到bilibili.csv\n数据处理的代码如下\nimport numpy as np import pandas as pd import os from urllib.request import Request, urlopen import urllib import requests import json def getDataFromFile(): if not os.path.isfile(\u0026#39;./data.txt\u0026#39;): raise TypeError(\u0026#34;file not exist\u0026#34;) text = open(\u0026#39;./data.txt\u0026#39;).read() return text def getResponse(url): headers = {\u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.8 5 Safari/537.36\u0026#39;} data = requests.get(url = url, headers=headers).text return data url = \u0026#39;https://api.bilibili.com/x/web-interface/ranking/v2?rid=0\u0026amp;type=all\u0026#39; res = getDataFromFile() jsonData = json.loads(res) title = [] # 标题 author= [] # up🐷 view = [] # 播放量 danmu = [] # 弹幕数 coins = [] # 投币 share = [] # 分享 like = [] # 点赞 score = [] # 分数 favor = [] # 收藏 reply = [] # 评论 rank = [] # 排名 cnt = 0 for i in range(0, 104): temp = \u0026#39;\u0026#39; try: videoData = jsonData[\u0026#39;data\u0026#39;][\u0026#39;list\u0026#39;][i] score.append(videoData[\u0026#39;score\u0026#39;]) title.append(videoData[\u0026#39;title\u0026#39;]) author.append(videoData[\u0026#39;owner\u0026#39;][\u0026#39;name\u0026#39;]) videoStat = videoData[\u0026#39;stat\u0026#39;] danmu.append(videoStat[\u0026#39;danmaku\u0026#39;]) view.append(videoStat[\u0026#39;view\u0026#39;]) rank.append(videoStat[\u0026#39;his_rank\u0026#39;]) reply.append(videoStat[\u0026#39;reply\u0026#39;]) favor.append(videoStat[\u0026#39;favorite\u0026#39;]) coins.append(videoStat[\u0026#39;coin\u0026#39;]) share.append(videoStat[\u0026#39;share\u0026#39;]) like.append(videoStat[\u0026#39;like\u0026#39;]) cnt = cnt + 1 except: continue outfile = pd.DataFrame({\u0026#34;title\u0026#34;: title ,\u0026#34;author\u0026#34;: author, \u0026#34;rank\u0026#34;: rank, \u0026#34;score\u0026#34;: score, \u0026#34;view\u0026#34;: view, \u0026#34;coins\u0026#34;: coins, \u0026#34;favorite\u0026#34;: favor, \u0026#34;reply\u0026#34;: reply, \u0026#34;danmu\u0026#34;: danmu}) outfile.to_csv(\u0026#34;bilibili2.csv\u0026#34;, index = False) 数据分析 数据加载\nimport pandas as pd # csv文件读写分析 import numpy as np # 线性代数 import matplotlib.pyplot as plt # 制图 data = pd.read_csv(\u0026#39;./bilibili.csv\u0026#39;, index_col=\u0026#39;title\u0026#39;) # 评分 score = data[\u0026#39;score\u0026#39;] # 播放量 view = data[\u0026#39;view\u0026#39;] # 投币 coins = data[\u0026#39;coins\u0026#39;] # 收藏 favor = data[\u0026#39;favorite\u0026#39;] # 评论 reply = data[\u0026#39;reply\u0026#39;] # 点赞 like = data[\u0026#39;like\u0026#39;] # 弹幕数量 danmu = data[\u0026#39;danmu\u0026#39;] # 分享次数 share = data[\u0026#39;share\u0026#39;] 绘制图像，观察数据之前的关系         由图像可以得出，b站综合打分的评分和各个数据之前有一定的相关性，主要为正相关。\n多元线性回归 我们的目的是得到 $f(x_i) = w^{T} x_i + b $ 类似的，使用最小二乘法估计w和b\n利用求解公式 $ \\hat w^{} = (X^{T}X)^{-1}X^{T}y$\n# 计算系数矩阵w-hat w_hat = np.dot(np.dot(np.linalg.inv(np.dot(X.T, X)), X.T), Y) # 获取b矩阵 b = w_hat[-1] # 获取w系数矩阵 w = w_hat[:-1] 看查w的值\n[[ 0.53588246] [ 2.01063732] [ 5.79443124] [-4.91889223] [17.51523907] [-3.73019387] [ 0.89537493]] 这里发现w系数矩阵中出现了负值，经检查发现该项目对应的自变量为like和reply，即视频的点赞次数和评论数，这与实际情况是不符的，猜测是因为该自变量对结果的影响过小，导致预测出现了偏差，同时发现弹幕数量对视频评分的影响过大，远超于其他参数，显然与实际生活不符，并且作为对视频质量的估计，弹幕数也的确不能作为一个重要的参数。\n因此我们对弹幕数进行剔除重新进行拟合。\n# 获取自变量矩阵，剔除弹幕数 X = data.iloc[:,[3, 4, 5, 6, 8, 9]].values # 获取因变量矩阵 Y = data.iloc[:,2].values.reshape(-1,1) # 生成设计矩阵 om = np.ones(X.shape[0]).reshape(-1,1) X = np.hstack((X, om)) # 计算系数矩阵w-hat w_hat = np.dot(np.dot(np.linalg.inv(np.dot(X.T, X)), X.T), Y) # 获取b矩阵 b = w_hat[-1] # 获取w系数矩阵 w = w_hat[:-1] print(w) 得到w的值为\n[[ 0.60269881] [ 2.82157809] [ 5.35461617] [ 3.04630747] [-3.9125348 ] [ 0.33063835]] 观察发现此时各项参数对于评分的影响已经较为接近正常水平。但是share，视频分享数对于评分的影响仍为负值，依然根据上述猜测，share对于总分的影响过小，导致拟合的结果差，因此再次剔除share字段。\n# 获取自变量矩阵，剔除弹幕数，分享数 X = data.iloc[:,[3, 4, 5, 6, 9]].values # 获取因变量矩阵 Y = data.iloc[:,2].values.reshape(-1,1) # 生成设计矩阵 om = np.ones(X.shape[0]).reshape(-1,1) X = np.hstack((X, om)) # 计算系数矩阵w-hat w_hat = np.dot(np.dot(np.linalg.inv(np.dot(X.T, X)), X.T), Y) # 获取b矩阵 b = w_hat[-1] # 获取w系数矩阵 w = w_hat[:-1] X_test = data.iloc[:, [3, 4, 5, 6, 9]].values Y_predict = np.dot(X_test, w) + b 得到w矩阵为\n[[0.59149795] [2.85961313] [4.47955342] [0.34492927] [0.35243338]] 绘制预测值与实际值图像   \n观察预测值与实际值的差距，发现拟合的趋势基本吻合，但仍有较大的误差\n分析得出，该线性模型的拟合误差较为集中，集中在[0, 181348.81788162683]即平均误差之间。\n[0.59149795] [2.85961313] [4.47955342] [0.34492927] [0.35243338] 根据权重分析各个数据对总分的影响，可以发现，收藏对于视频总评分的影响占比最高，其次是硬币数，播放数，说明哔哩哔哩对与视频的质量高低评判有一定的综合考量，播放量属于可以由视频制作人通过其他方式刷取，但是收藏量是由用户对于视频质量的高低做出的决定，因而更具代表性，更有说服力。反观实际观看体验中，有些视频制作人会以视频收藏满几万后，更新下一期视频，因为该项对视频的收益影响最大，更能给视频制作人带来实际收益。\n本次线性回归的拟合可以较为准确的判断出各各数据对于视频评分的影响，但是对于视频评分的预测误差较大，但是仍能较准确的判断出视频评分所影响的视频排名，认为有如下原因：\n 数据量过少，导致拟合程度不足 评分规则非线形模型，应该更换模型 还有其他未考虑的因素 如果要更准确的对视频评分进行预测，应该综合分析数据的特性，或者采用机器学习等更优秀的手段来进行求解和预测，线性回归仍有一定的局限性。 ","date":"2021-07-02T14:05:48Z","permalink":"https://ez4zzw.github.io/p/bilibili%E8%A7%86%E9%A2%91%E7%BD%91%E7%AB%99%E6%8E%92%E8%A1%8C%E6%A6%9C%E8%AF%84%E5%88%86%E7%9A%84%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/","title":"Bilibili视频网站排行榜评分的线性回归分析"},{"content":"迭代法求解方程的根 求解方程的根，即$f(x)=0$的数值解等问题，对于经典的二次方程等函数我们可以直接进行求解，但是对于超越方程我们不能用常规方法进行求解。因此我们可以通过使用计算机实现某些求解算法进行计算。\n选取样例\n$f(x) =x^3 - x - 2$\n$\\frac{dy}{dx} = 3x^2-1$\n求解$f(x)$在[1, 2]上的零点\n二分法 在高中数学课本我们就接触过二分法求函数零点，根据零点存在性定理，可以保证我们得到符合要求的一个根，但是该方法局限性太大，只能求解区间内的一个根。\n大致流程如下\n先确定要求解的区间[x, y]，然后不断对区间进行二分，根据精度要求判断根是否合法，再根据中点值与端点值的符号是否相同缩小二分范围。\n$if \\ f(mid)\\times f(l) \u0026gt; 0$\n$let \\ l = mid$\n$or \\ r = mid$\nCode\nimport numpy as np import math as m def f(x): return x**3-x-2 def binary(x, y): res = 0 eps = 1e-3 h = 1e-3 l = x r = y while l \u0026lt;= r: mid = (l+r)/2 if abs(f(mid)-0) \u0026lt; eps: return mid if f(mid)*f(x) \u0026gt; 0: l = mid else: r = mid return -1 answer = binary(1.0, 2.0) print(np.around(answer, 4)) 运算结果为1.5215\n牛顿迭代法 牛顿迭代法的基本思想为将非线性方程线性化，选取一个初始点，做切线交与x轴一点，然后继续该操作，直到根收敛或者达到精度要求。\n基本流程为\n 取任意的迭代初始值$x_0$ 计算 $x_1 = x_0 - \\frac{f(x_0)}{f'(x_0)}$ 判断收敛性：如果$|x_1 - x_0|\u0026lt; \\epsilon \\ or |f(x_1)-0| \u0026lt; \\epsilon$ 令$x_0 = x_1$，保存上一步结果，继续迭代  Code\nimport numpy as np import math as m # f(x) = x**3 - x - 2 # df/dx = 3x**2 -1 def df(x): return 3*x**2 - 1 def f(x): return x**3 - x - 2 def newton(x): eps = 1e-7 x0 = x x1 = x0 - f(x0)/df(x0) while abs(x1-x0) \u0026gt; eps: t = x1 x1 = t - f(t)/df(t) x0 = t return x1 answer = newton(1.0) print(np.around(answer, 4)) 运算结果为1.5214\n","date":"2021-04-25T13:04:57Z","permalink":"https://ez4zzw.github.io/p/%E6%96%B9%E7%A8%8B%E6%B1%82%E6%A0%B9%E7%9A%84%E8%BF%AD%E4%BB%A3%E6%B3%95/","title":"方程求根的迭代法"},{"content":"求解线性方程组 在线性代数中，有一类经典问题，就是求解线性方程组，我们熟知的解法有高斯消元法，但是高斯消元法属于直接求解的方法，不适合编程计算，因此引入更适合计算机求解的迭代法。\n以线性方程组：\n$ \\left[ \\begin{matrix} 10 \u0026amp; -1 \u0026amp; -2 \\\n-1 \u0026amp; 10 \u0026amp; -2 \\\n-1 \u0026amp; -1 \u0026amp; 5 \\end{matrix} \\right] x = \\left[ \\begin{matrix} 7.2 \\\n8.3 \\\n4.2 \\end{matrix} \\right] $ 为例\nJacobi迭代法 考虑线性方程组$Ax=b$\n用L和U分别表示严格下三角矩阵和严格上三角矩阵\n可以利用迭代公式\n$x^{k+1}=D^{-1}(b-(L+U)x^{k}))$\n进行迭代求解，可以通过精度控制迭代次数，还需要控制迭代是否收敛，不然迭代次数再多也无法求解。\n迭代法需要给定解列向量的初值，因此初值的选取也很重要。\nimport numpy as np def Jacobi(A, B, N, x): # Ax=B N为迭代次数 # 获得对角矩阵的数组 D = np.diag(A) # 获得L+U矩阵，减去对角矩阵即可 # diagflat为D数组转为对角矩阵 R = A - np.diagflat(D) # R = L + U print(R/D) for i in range(N): # 迭代过程，可以直接/D表示逆矩阵 x = (B - np.dot(R, x))/D return x A = np.array([[10, -1, -2], [-1, 10, -2], [-1, -1, 5]] ) B = np.array([7.2, 8.3, 4.2]) # 设定迭代初始值 x = np.array([1, 1, 1]) answer = Jacobi(A, B, 30, x) print(answer) 求解结果为 x = [1.1, 1.2, 1.3]\nGauss Seidel迭代法 Gauss Seidel法使用了另一种迭代格式，获得了快的收敛速度\n首先我们利用迭代求解的特性，新得到的值总会比老值更优，因此使用新值来进行迭代，即\n$x^{k+1}=D^{-1}(b+Lx^{k+1}+Ux^k)$\n化简\n$x^{k+1}=(D-L)^{-1}(Ux^k+b)$\nimport numpy as np def GaussSeidel(A, B, N, x): # 下三角矩阵 L = np.tril(A) # 严格上三角矩阵 U = A - L # 获得对角矩阵 D = np.diagflat(np.diag(A)) LL = L - D # x^{k+1} = (D + L)^-1 (b - Ux^{k}) # 输出迭代矩阵 print(np.dot(np.linalg.inv(D-LL), U)) for i in range(N): # 使用linalg包中的inv函数求出L矩阵的逆矩阵 # 使用上述迭代公式求解 x = np.dot(np.linalg.inv(L), B - np.dot(U, x)) return x A = np.array([[10, -1, -2], [-1, 10, -2], [-1, -1, 5]] ) B = np.array([7.2, 8.3, 4.2]) # 设定迭代初始值 x = np.array([1, 1, 1]) answer = GaussSeidel(A, B, 30, x) print(answer) 解得x = [1.1, 1.2, 1.3]\n","date":"2021-04-25T00:38:16Z","permalink":"https://ez4zzw.github.io/p/%E8%BF%AD%E4%BB%A3%E6%B3%95%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/","title":"迭代法求解线性方程组"},{"content":"常微分方程初值问题 常微分方程描述了不同变量之间的变化关系，通过该关系我们可以确定变量之间的具体函数关系，但是微分方程不一定总是可解的，并且有些求解起来相当困难。给出积分曲线初始位置的状态，求解需要预测点的状态，为常微分方程的初值问题，我们可以在求解微分方程即的情况下对结果做出复合精度要求的预测。\n以$f(x) = \\sqrt{1+2x}$为例\n有$y'=\\frac{dy}{dx}=y-\\frac{2x}{y}$\n本文给出几种算法的原理与实现。\nEuler方法及其改进 从初始点开始，根据不同离散点的导数值对曲线进行预测，导数值可以通过对ODE的化简求解，做出一条折线图，最终曲线会逼近预测值。\n该方法有明显的缺点就是在每一步做出抉择时，只考虑了当前的状态，并没有考虑后面的状态，因此必然会造成较大的误差，因此采用下一个结点的导数值进行修正。\n具体流程如下\n选取一定的步长h，一般为区间的n等分\n预测下一个值$\\overline{y}_{i+1} = y_i + hf(x_i, y_i)$\n校正预测值$y_{i+1} = y_i + \\frac{h}{2}[f(x_i, y_i)+f(x_{i+1}, \\overline{y}_{i+1})]$\n改写成平均化形式\n$y_p = y_i +hf(x_i, y_i)$\n$y_c = y_i + hf(x_{i+1}, y_p)$\n$y_{i+1} = \\frac{1}{2} (y_p+y_c), i =0,1,2,3,\u0026hellip;,n-1$\nimport numpy as np # 常微分方程化简 def ode(x, y): return y - 2 * x / y def f(x): return np.sqrt(1+2*x) def Euler(bound, start): \u0026#39;\u0026#39;\u0026#39; bound : 预测边界值 start : 起始点 \u0026#39;\u0026#39;\u0026#39; h = 0.1 # 对步长h等分 n = int(bound/h) x = np.zeros(n) y = np.zeros(n) sample = np.zeros(n) for i in range(0, n): # 获取均分后的所有点 x[i] = 0+i*h # 生成标准值做对比 sample[i] = f(x[i]) y[0] = start for i in range(1, n): # 预测值 yp = y[i-1] + h*ode(x[i-1], y[i-1]) yc = y[i-1] + h*ode(x[i], yp) # 使用预测值求加权平均值 y[i] = (yp+yc)/2.0 return y, sample answer,sample = Euler(2, 1) print(answer) print(sample) 运行结果：\n标准值\n[1. 1.09544512 1.18321596 1.26491106 1.34164079 1.41421356 1.4832397 1.54919334 1.61245155 1.67332005 1.73205081 1.78885438 1.84390889 1.8973666 1.94935887 2. 2.04939015 2.0976177 2.14476106 2.19089023]\n预测值\n[1. 1.09590909 1.18409657 1.26620136 1.34336015 1.41640193 1.4859556 1.55251409 1.61647478 1.67816636 1.7378674 1.79581974 1.8522386 1.90732042 1.96124939 2.01420304 2.06635728 2.11789132 2.16899248 2.21986124]\nRunge-Kuta法 Runge-Kuta法在思想上与之前的方法大致相同，都是通过若干个斜率的加权平均值来做出下一步选择。此处只给出常用的四阶Runge-Kuta的处理方式。\n$K_1=f(x_i,y_i)$\n$K_2 =f(x_i + \\frac{h}{2}, y_i + \\frac{h}{2}K_1)$\n$K_3=f(x_i + \\frac{h}{2}, y_i + \\frac{h}{2}K_2)$\n$K_4=f(x_i + h, y_i + hK_3)$\n$y_{i+1}= y_i + \\frac{h}{6}(K_1+K_2+K_3+K_4)$\nimport numpy as np from matplotlib import pyplot as plt def ode(x, y): return y - 2 * x / y def f(x): return np.sqrt(1+2*x) def RungeKutta(bound, start): \u0026#39;\u0026#39;\u0026#39; bound : 计算边界 start : 初始值f(0) \u0026#39;\u0026#39;\u0026#39; h = 0.1 n = int(bound/h) x = np.zeros(n) y = np.zeros(n) sample = np.zeros(n) for i in range(0, n): x[i] = 0+i*h sample[i] = f(x[i]) y[0] = start for i in range(1, n): # 求各个点的斜率 k1 = ode(x[i-1], y[i-1]) k2 = ode(x[i-1] + h/2, y[i-1] + h/2*k1) k3 = ode(x[i-1] + h/2, y[i-1] + h/2*k2) k4 = ode(x[i-1] + h, y[i-1] + h * k3) # 对斜率求平均值并进行预测 y[i] = y[i-1] + h/6*(k1 + 2 * k2 + 2 * k3 + k4) plt.show() return y, sample y, sample = RungeKutta(2, 1) print(y) print(sample) 运行结果 ： 预测值\n[1. 1.09544553 1.18321675 1.26491223 1.34164235 1.41421558 1.48324222 1.54919645 1.61245535 1.67332466 1.73205637 1.78886107 1.84391692 1.89737622 1.9493704 2.00001382 2.0494067 2.09763752 2.14478481 2.1909187 ]\n标准值\n[1. 1.09544512 1.18321596 1.26491106 1.34164079 1.41421356 1.4832397 1.54919334 1.61245155 1.67332005 1.73205081 1.78885438 1.84390889 1.8973666 1.94935887 2. 2.04939015 2.0976177 2.14476106 2.19089023]\n","date":"2021-04-23T23:26:18Z","permalink":"https://ez4zzw.github.io/p/%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%88%9D%E5%80%BC%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A3%E6%96%B9%E6%B3%95/","title":"常微分方程初值问题求解方法"},{"content":"数值积分 应用背景：微积分的基本计算公式为经典的牛顿莱布尼茨公式，但是作为计算机来说，计算原函数等操作过于困难，因此需要其他方法进行优化，代替牛顿莱布尼茨公式进行计算，本文将分享两种求积公式及其代码实现。\n使用语言： Python-Numpy\n使用两种方法计算$f(x)=sin(x)$在[1,2]上的积分\n复化梯形的递推公式 由梯形公式改进，将区间[a, b]等分为n个小区间 $[x_i, x_{i+1}]$\n$\\int_{a}^{b}f(x)dx=\\sum_{i=0}^{n-1}\\int_{x_i}^{x_{i+1}}f(x)dx\\approx \\frac{h_i}{2}[f(x_i)+f(x_{i+1})]$\n根据梯形公式化简为区间端点值组合\n将求和公式展开，分离出左右端点\n得到最终的化简结果\n$T_n = \\frac{h}{2} [f(a)+2\\sum_{i=1}^{n-1}f(x_i)+f(b)]$\n但是该方法的步长太小的话会导致计算次数太大，步长太大又难以保证效率\n采用区间不断对分的方法，取$n = 2^k$，反复使用复合求积公式\n$T^{(k)}=\\frac{1}{2}T^{(k-1)}+\\frac{h_{k-1}}{2}\\sum_{i=0}^{2^{k-1}-1}f(a+ih_{k-1} + 0.5h_{k-1})$\n其中$h_{k-1} = \\frac{b-a}{2^{k-1}}$\nCode\nimport numpy as np def f(x): return np.sin(x) def Calc(): eps = 1e-7 Flag = True l = 1.0 r = 2.0 h = r - l t1 = 1.0*(h/2)*(1+f(r)) t2 = 0.0 while Flag: sum = 0 x = l + h/2 while x \u0026lt; r: sum += f(x) x += h t2 = t1/2 + h*sum/2 h /= 2.0 if abs(t2 - t1) \u0026lt; abs(eps): Flag = False t1 = t2 res = t2 return res answer = Calc() print(answer, 6) 0.9564492180077249\nRomberg 算法 基于梯形递推公式，将上一级递推公式的结果进行线性组合，得到Simpson公式，再对Simpson公式结果进行线性组合得出Cotes公式结果，最后对Cotes公式线性组合得出Romberg算法的递推公式\n该方法为Richardson外推法\n$T_{m}^{(k)}=\\frac{4^m T_{m-1}^{(k+1)} - T_{m-1}^{(k)}}{4^m - 1}$\nk为Romberg算法的阶数，Romberg算法具有收敛性，一般情况下我们取四阶 k = 3进行计算就可以满足精度要求\nimport numpy as np def f(x): return np.sin(x) # 计算梯形公式的结果 def trapezcomp(l, r, k): h = (r - l)/k x = l Sum = f(x) for i in range(1, k): x += h Sum += 2*f(x) return (Sum + f(r))*h*0.5 def romberg(x, y, n): \u0026#39;\u0026#39;\u0026#39; x : 积分下限 y : 积分上限 n : Romberg算法求解的阶数 \u0026#39;\u0026#39;\u0026#39; I = np.zeros((n, n)) for i in range(0, n): # 获得梯形公式的结果 I[i, 0] = trapezcomp(x, y, 2**i) for j in range(0, i): # 使用加速递推公式计算 I[i, j+1] = (4**(j+1)*I[i, j] - I[i-1, j])/(4**(j+1)-1) # 返回4阶Romberg算法的递推值  return I[n-1, n-1] answer = romberg(1.0, 2.0, 4) print(answer) 运行结果： 0.9564491426149814\n","date":"2021-04-23T20:18:59Z","permalink":"https://ez4zzw.github.io/p/%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86%E6%96%B9%E6%B3%95/","title":"数值积分方法"},{"content":"插值方法 插值属于数值分析领域中的一种方法，是一种通过已知的离散的数据点，来拟合原函数根据给定的自变量估算因变量的方法。\n常用的插值方法有很多，本文章给出三种常见的插值方法的实现。\n使用语言: Python\n使用下面的数据，预测函数在x=1处的值\nx = np.array([0.5, 0.6, 0.4, 0.7]) y = np.array([-0.6931, -0.5108, -0.9163, -0.3567]) 线性插值 线性插值及求一次多项式$p(x)$，满足$p(x_0), p(x_1) = y_1$ 可以根据点斜式方程求解 即\n$p(x) =y_0 \\frac{y_{1}-y_{0}}{x_1-x_0}(x-x_0)$ 还可以将公式整理成如下形式\n$p(x) = y_0 \\frac{x - x_1}{x_0 - x_1} + y_1 \\frac{x- x_0}{x_1 - x_0}$\n我们令这里的$l_0(x)=\\frac{x-x_1}{x_0 - x_1}, l_1(x)=\\frac{x-x_0}{x_1-x_0}$\n将其线性组合之后即为\n$p(x)=y_0 l_0(x)+y_1 l_1(x)$\n是Lagrange插值的特殊形式\n此处给出线性插值的代码实现：\nimport numpy as np def linear(x, y, x0): \u0026#39;\u0026#39;\u0026#39; x : 为横坐标数组 y : 为纵坐标数组 x0: 为需要预测点的横坐标 res: 预测结果 \u0026#39;\u0026#39;\u0026#39; res = y[1] + (y[1] - y[0])*(x0 - x[1])/(x[1] - x[0]) # 根据公式计算结果 return res x = np.array([0.5, 0.6, 0.4, 0.7]) y = np.array([-0.6931, -0.5108, -0.9163, -0.3567]) answer = linear(x, y, 1) print(np.around(answer, 4)) # 保留四位小数 Largrange插值 根据Lagrange插值基函数$l_k(x)$，其满足如下性质 当$i=k,l_k(x_i)=1$\n当$i\\not ={k}, l_k(x_i) = 0$\n其中$l_k(x) = \\prod_{i=0,i \\not ={k}}^{n} \\frac{x-x_i}{x_k-x_i}$\n可以得到$p(x)=y_0 l_0(x) + y_1 l_1(x) + \u0026hellip; + y_n l_n(x)$\n$p(x)$满足$p(x_i)=y_i, i = 0,1,\u0026hellip;,n$\n即根据插值结点确定的方程，可以使得$p(x_i)=y_i$，是一种可行的插值方法，极大的提高了插值精度。\n并且当只有两个插值结点时，Lagrange插值就退化成了线性插值，当有三个结点时，退化成抛物线插值。\nimport numpy as np from matplotlib import pyplot as plt def largrange(x, y, x0): \u0026#39;\u0026#39;\u0026#39; x : x数组 y : y数组 x0: 预测点横坐标 res: 预测结果 \u0026#39;\u0026#39;\u0026#39; n = len(x) res = 0 for i in range(n): param = np.append(x[:i], x[(i+1):]) # 获得除去xi的所有横坐标 numerator = (x0 - param).prod() # 分子，使用prod求出矩阵中所有元素的积 denominator = (x[i] - param).prod() # 计算分母 res += y[i]*numerator/denominator # 根据公式计算当前步骤对答案的贡献 return res x = np.array([0.5, 0.6, 0.4, 0.7]) y = np.array([-0.6931, -0.5108, -0.9163, -0.3567]) answer = largrange(x, y, 1) print(np.around(answer, 4)) 运行结果： 0.0634\nNewton插值 我们引入差商的概念， 设有函数$f(x), x_0,\u0026hellip;,x_n$\n$f[x_i, x_j] = \\frac{f(x_j)-f(x_i)}{x_j - x_i}$\n称为$f(x)$关于点$x_i, x_j$的一阶差商\n$f[x_i, x_j, x_k] = \\frac{f[x_j, x_k] - f[x_i, x_j]}{x_k - x_i}$\n称为$f(x)$关于点$x_i， x_j， x_k$二阶差商\n我们可以得到差商的一般定义，对于k阶差商\n$f[x_0, x_1, \u0026hellip;, x_k] = \\frac{f[x_1, \u0026hellip;, x_k] - f[x_0, \u0026hellip;, x_{k-1}]}{x_k - x_0}$ 计算差商可以通过差商表来计算\n   $x_i$ $f(x_i)$ 一阶差商 二阶差商 三阶差商 \u0026hellip; n阶差商     $x_0$ $f(x_0)$        $x_1$ $f(x_1)$ $f[x_0, x_1]$       $x_2$ $f(x_2)$ $f[x_1, x_2]$ $f[x_0, x_1, x_2]$      $x_3$ $f(x_3)$ $f[x_2, x_3]$ $f[x_1, x_2, x_3]$ $f[x_0, x_1, x_2, x_3]$     \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip;    $x_n$ $f(x_n)$ $f[x_{n-1}, x_{n}]$ $f[x_{n-2}, x_{n-1}, x_{n}]$ $f[x_{n-3}, x_{n-2}, x_{n-1}, x_{n}]$  $f[x_0, x_1, \u0026hellip;, x_n]$    将对角线上的差商值用来构造插值函数\n$f(x) = f(x_0) + f[x_0, x_1](x- x_0) + f[x_0, x_1, x_2](x - x_0)(x - x_1) + \u0026hellip; + f[x_0, \u0026hellip;, x_n](x - x_0)\u0026hellip;(x - x_{n-1}) + f[x,x_0,x_1,x_2,\u0026hellip;,x_n](x - x_0)\u0026hellip;(x - x_{n})$\n其中$R(x) = f[x,x_0,x_1,x_2,\u0026hellip;,x_n](x - x_0)\u0026hellip;(x - x_{n})$为插值余项\n综上，牛顿插值的最终表达式为\n$R(x) = N(x)+R(x)$\n牛顿插值的插值基函数有可继承的特点，可以优化计算方法\n直接利用上一次的计算结果增量更新\nimport numpy as np # 计算差商表第j列的元素 def GetColumRes(arr, j): n = len(arr[:,0]) colum = np.zeros(n) for i in range(j-1, n): colum[i] = (arr[i, j-1] - arr[i-1, j-1])/(arr[i, 0] - arr[i-j+1, 0]) return colum # 计算差商 def CalculateDividedDiffernces(x, y): n = len(x) arr = np.zeros((n, n+1)) arr[0:n, 0] = x arr[0:n, 1] = y for i in range(2, n+1): # 获得差商表第i列的元素 arr[:, i] = GetColumRes(arr, i) print(arr) return arr def newton(x, y, x0): res = y[0] n = len(x) factor = 1 DD = CalculateDividedDiffernces(x, y) for i in range(1,n): # factor因数迭乘 factor *= (x0-x[i-1]) # 取出对角线上的元素进行计算 res += DD[i, i+1]*factor return res x = np.array([0.5, 0.6, 0.4, 0.7]) y = np.array([-0.6931, -0.5108, -0.9163, -0.3567]) answer = newton(x, y, 1) print(np.around(answer, 4)) 运行结果：\n差商表\n[ 0.5 -0.6931 0. 0. 0. ]\n[ 0.6 -0.5108 1.823 0. 0. ]\n[ 0.4 -0.9163 2.0275 -2.045 0. ]\n[ 0.7 -0.3567 1.86533333 -1.62166667 2.11666667]\n运行结果 0.0634\n","date":"2021-04-19T22:22:57Z","permalink":"https://ez4zzw.github.io/p/%E4%B8%89%E7%A7%8D%E6%8F%92%E5%80%BC%E6%96%B9%E6%B3%95%E5%8F%8A%E5%AE%9E%E7%8E%B0/","title":"三种插值方法及实现"},{"content":"学校重构之后的OJ终于进入了前后端对接的阶段，经过了一周的紧张对接环境，项目依然是(正在稳定推进的阶段)，和前端对接口的一周里，我感觉到自己之前工作的不足，在此做出反思，以后要改掉这些错误。同时在和运维一起部署的过程中，也发现了许许多多的问题，在此一并记录一下。\nAccess to Judger Ana In Docker 因为OJ要防止恶意代码的提交，解决办法就是使用docker，为了让评测机稳定于是又要在docker里跑一个docker。 直接docker run评测机，用了一下judge_test的模块，发现返回的结果全是AC，这就非常奇怪了。问了一下hr发现ana是用grpc通信的，好，没有学过，于是开始看怎么测试grpc是否正常，初步定位问题是没接上。也去docker里配了一下环境，加了工作目录，放行端口，发现还是不行。当hr进入服务器的时候，才发现真正的问题所在。直接docker pull的时候是跑的master分支的镜像，而新评测机接口是在另一个分支的。于是把锅甩给了嘎嘎豪。\nNPM throw error 后端采用了go语言的gin+gorm框架搭建，直接go build然后丢到后台守护进程，前端使用了vue框架，要先用npm build一下，但是我本意是想直接npm run serve的，无奈npm一直疯狂报错。最初我也是打算现在本地run serve然后只测试后台的，但是npm先是依赖问题没有解决，最后重装了全局的依赖之后发现报错有个字段为darwin-arm64，看到这个我就感觉不对劲，可能是M1芯片没有合适的包可以下载，于是才决定丢到服务器上。在服务器上也是遇到了依赖的问题，直接尝试删除所有包，包括全局包，发现一个报错，大概就是说npm要没钱了，快来funding，好家伙，我直接npm uninstall * --no-fund删除了所有依赖，然后重新npm install，跑完之后在此run serve，显然还是不行，问了王哥之后他给出了一个解决办法，先build然后用nginx反代到build之后生成的dist文件夹中。于是开始build，很不错，这回没有报错。于是开始了nginx反代。\nNginx 服务器没有绑定域名，因此直接将服务器的某个端口直接映射到前端渲染出来的dist文件夹中去，需要现在安全组放行端口，这里就不得不提一下宝塔界面了，最初接触服务器的时候感觉宝塔确实很方便，今天运维也吐槽了一下，有些地方宝塔反而做复杂了，我就感觉上传或者下载文件比较方便，懒得用ftp。还不得不提yum包管理器是我用过最难用的，不如pacman，也没apt包全，但是总不能在服务器上跑arch吧 Orz。 在宝塔上装了Nginx，开始做反代。 先是监听一下888端口,并反代/请求到dist文件夹,设置首页为index.html\nserver { listen 888; index index.html index.htm index.php; root /root/dev/OnlineJudge/front_end/dist; } 好，重载一下nginx的配。 咦，发现403 forbidden，运维猜测是nginx没有权限访问那个目录。 这就开始打算直接chmod 777了，仔细一看发现，没改nginx配置里的user。\nuser root root; 正常情况下建议分一个用户单独给nginx。 然后发现访问首页是空白内容，打开F12看看，发现是js和css的请求全阻塞了，又去看了一眼nginx的配置，发现正则匹配的js和css文件目录不对。\nlocation ~ .*\\.js?$ { root /root/dev/OnlineJudge/front_end/dist; } location ~ .*\\.css?$ { root /root/dev/OnlineJudge/front_end/dist; } 这里要注意，一开始我是分别代理到/dist/js和/dist/css文件夹的，这样是不对的，因为请求的uri里是带有js和css字段的，于是就造成了路径不对，成了/js/js/**。 至此，首页可以成功进入了。 开始测试喜闻乐见的登录环节，发现请求没发出去，前端的请求之前是发送到远程服务器的，现在应该是访问本机localhost，于是进行代理转发请求\nlocation /api { proxy_pass http://127.0.0.1:5000; } 终于可以登录了。到了八点多，感觉要下班了，又发现后台登录不进去了，又发现是只有我自己的chrome登录不进去，看日志的报错是interface提取的时候出问题了，uint和int之间产生了冲突，但是感觉事情没有那么简单，定位到出错的代码之后，发现异常是用_接收的，于是又对id打了log，再次运行。 这个id怎么这么熟悉。原来是前端的session里的id，看来是因为前台后台共用了session，导致id混用了。\nEnd 此时已经到了晚上八点多了，看似已经解决了不少bug，但是很多问题都是和OJ无关的配置问题，真正的debug才刚刚开始。\n 项目正在稳定的向前推进。\n","date":"2021-04-03T22:22:14Z","permalink":"https://ez4zzw.github.io/p/oj%E9%83%A8%E7%BD%B2debug%E8%AE%B0%E5%BD%95/","title":"OJ部署debug记录"},{"content":"对于git，很早很早就在用了，但是还没有系统整理过，并且有些命令使用时需要注意的事项，在此也一并标出。\nAbout Git git是一个分布式版本控制工具，如果你是一个程序猿，那你必须要学会如何使用git来管理你的代码或者项目。 可能更多人所熟知的是GitHub，顾名思义，按照英语的命名特点，GitHub就是所有git上传的枢纽，汇聚到一起，你可以开源你的代码，指定一款开源协议共享给所有需要的人，也可以将仓库设为私有，只有自己或者受到邀请的人可见或者进行编辑。 除了GitHub，世界上还有很多这种代码托管平台，比如国内的gitee,coding等，国外还有gitlab等平台提供代码托管服务。\nSetup 在一个目录中，你可以使用git init来初始化这个目录，git会把这个文件夹变为一个git目录，\n\u0026gt; GitTest git init Initialized empty Git repository in /Users/username/GitTest/.git/ 使用git remote add origin {your repo url} 即可添加远程的仓库地址。\nCommit \u0026amp;\u0026amp; Push 对于一个采用迭代式开发或者其他开发模式的项目来说，都避免不了后续对代码进行修改或者添加一些新的文件，对于每一次这样的操作，都要对添加或者修改的文件指定一个commit。 例如：修改了项目功能中的bug，文件名字为a.cpp 可以使用\ngit add a.cpp git commit -m \u0026quot;fix: the bug in xxx\u0026quot; 这样就可以将此次更改添加到提交的队列中 如果使用git add .，git将添加所有监控的文件到缓冲区 再使用git push就可以将修改添加到远程仓库中\n对与一个团队而言，有标准规范的commit格式是很重要的，例如以下格式\nfeat: 新功能feature fix: 解决bug add: 添加模块 update: 更新模块 ... 等等 Dangerous Pull ing 如果是多人协作开发，那么必然会导致本地文件之间存在着不一致，为了解决这个问题，可以使用git pull，执行该命令后将同步仓库中存在并且与本地不同的文件。 这个操作看似简单，但是有时候如果使用了\u0026ndash;force强制执行的话，会覆盖掉本地的文件，属于非常危险的操作，所以无论在什么时候使用\u0026ndash;force之前都要思考清楚自己在干什么。\nBranch 我觉得git很强大的一个功能就是对分支的管理，在不同分支中切换可以让项目的代码得到更有效的管理，例如在main主分支中保存可以稳定运行的版本，在另一个dev分支中保存正在开发的非稳定版，后续改进之后可以将dev分支合并到main分支中去。 如果更新过后的主分支依然出现问题，也是可以通过回滚的方式回到之前某个稳定的版本。 分支的创建也非常简单\ngit branch name git checkout name 切换后git所有的操作将在新的分支进行\n.gitignore 顾名思义，肯定是让git去忽略某些项目，比如文件夹，或者是单个文件，添加到gitignore之后git将不在追踪这些文件的变化，因此我们可以将例如npm庞大的node_modules这种文件夹添加到其中，或者是编译器调试产生的临时文件，优化仓库的存储结构。\ngit status 使用该命令看查目前项目的改动\nOn branch dev Untracked files: (use \u0026quot;git add \u0026lt;file\u0026gt;...\u0026quot; to include in what will be committed) b.cpp nothing added to commit but untracked files present (use \u0026quot;git add\u0026quot; to track) git监控到了文件b.cpp的产生，我们将b.cpp添加到.gitignore中\nOn branch dev nothing to commit, working tree clean 再次使用git status看查，发现b.cpp已经不再被监控了，在.gitignore中还可以使用文件夹名忽略整个文件夹的项目，或者使用通配忽略包含特定后缀名的文件等。\nEnd 随着开发工具的现代化，很多时候我们已经用不到这些git命令了，很多繁琐的命令早已被图形化的界面取代，但不乏还有git爱好者们做出的努力，如lazygit等工具。 当你接收一台崭新的服务器时，这些命令又显得格为重要了。因此，在简便的工具的包裹下，他们背后的原理才是最值得我们去了解的，就如同学习汇编语言一样，给力我们另一种看待程序的方式。 很早就像总结一下git了，拖了这么久终于写完了，后续还想再添加一些更具体的内容，希望能给初入git的同学一些启发。\n","date":"2021-04-02T22:33:25Z","permalink":"https://ez4zzw.github.io/p/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"Git学习笔记"},{"content":"最近写了一个go项目，需要部署到服务器进行测试，如果只是go run main.go难免也太麻烦了点，于是学习了项目部署的相关知识。 项目的部署有多种方式，Jenkins,nginx等方式，本文只讲解一下简单的shell脚本部署。\n系统信息 系统信息: CentOS Linux release 8.3.2011 x86_64 Go version: go version go1.14.12 linux/amd64\n几条命令的介绍 nohup nohup命令的全称为no hang up不挂起，可以在系统后台不挂断的运行命令，退出终端后程序也会正常运行。 语法格式： nohup ./xxx \u0026gt; xxx.log 2\u0026gt;\u0026amp;1 \u0026amp; 解释： \u0026gt; xxx.log表示将输出重定向至该文件，可以记录运行时的日志 2\u0026gt;\u0026amp;1将标准错误2重定向到标准输出\u0026amp;1，然后标准输出\u0026amp;1再被重定向至xxx.log文件\ngit pull git pull origin dev 为了方便项目的及时更新，使用改名了保证运行时与上游仓库的代码保持一致。\nps ps命令为 process status,可以查看系统当前的进程状态\n例如\n~\u0026gt; ps PID TTY TIME CMD 255873 pts/0 00:00:02 zsh 258517 pts/0 00:00:00 sh 258519 pts/0 00:00:00 OnlineJudge 263021 pts/0 00:00:00 ps 我们将用ps命令与grep等命令筛选出项目的pid ps命令有很多参数选择，这里介绍一下用到的两条命令:\nps -e 列出所有进程 ps -f 显示进程的全部信息 grep grep命令可以查找文本中符合条件的字符串，用于匹配进程的名称， 还可以匹配文本中的各种信息，本文不再具体展开，后续打算更一篇具体记录Linux命令的博客。\nawk 用于处理文本提取信息，将使用grep查询到的进程信息提取出pid 查询到的结果为 root 263948 263946 0 12:49 pts/0 00:00:00 ./OnlineJudge 我们只需要第二项的pid，使用 awk {print $2} 即可提取出进程的pid 263948\nkill kill pid杀死进程\nShell脚本 echo -e \u0026#34;*** Online_Judge ***\\n\u0026#34; echo -e \u0026#34;*** 检查上游代码中 ***\\n\u0026#34; git pull origin dev echo -e \u0026#34;*** 编译中 ***\\n\u0026#34; go build chmod -R 777 OnlineJudge pid=`ps -ef|grep OnlineJudge|grep -v grep|awk \u0026#39;{print $2}\u0026#39;` echo -e \u0026#34;$pid\\n\u0026#34; kill $pid \u0026amp;\u0026amp; nohup ./OnlineJudge \u0026gt; OnlineJudge.log 2\u0026gt;\u0026amp;1 \u0026amp; pid2=`ps -ef|grep OnlineJudge|grep -v grep|awk \u0026#39;{print $2}\u0026#39;` echo -e \u0026#34;项目部署成功***进程ID为:$pid2\u0026#34; 将脚本保存至项目目录，赋予执行权限 chmod +x setup.sh 执行脚本\n➜ git:(dev) ✗ ./setup.sh *** Online_Judge *** *** 检查上游代码中 *** From url * branch dev -\u0026gt; FETCH_HEAD Already up to date. *** 编译中 *** *** 添加权限 *** 添加权限成功 *** kill进程 *** 258519 ./setup.sh: line 18: 258519 Terminated nohup ./OnlineJudge \u0026gt; OnlineJudge.log 2\u0026gt;\u0026amp;1 项目部署成功***进程ID为:263948 至此项目即可部署成功 上述shell中的视个人情况而修改\nReference Linux命令大全 如何优雅的通过Shell脚本一键部署GO项目到服务器？ \n","date":"2021-03-30T12:23:42Z","permalink":"https://ez4zzw.github.io/p/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1go%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%83%A8%E7%BD%B2/","title":"记录一次Go项目的部署"},{"content":"简介 本学期选了汇编语言这门选修课，我认为还是有很大的学习价值的，虽然学习的还是年代久远的8086CPU指令集，但对后续接触更多汇编语言还是有很大帮助，方便我们调试程序，多了一种查错的方式。 其实关于调试自己很久之前就想学了，高中的时候看紫书，发现lrj老师讲了一段的gdb调试方法，当时感觉一点都看不懂，现在借此机会学习一下gdb的调试。 本文除了将总结一些汇编语言学习过程中的笔记之外，还计划穿插一些cs213/CSAPP 的内容以及bomb lab的解析。\n准备工作 dos系统现在以及年代久远，想使用8086CPU指令集调试的话需要借助DosBox来实现。 DosBox官网\n由于macOS下没有DOSbox需要的调试工具，因此下载之后需要挂载debug.exe等Windows下的调试工具 在DOSbox中输入\nmount C ~/dos C: debug 即可进入debug模式\n实验1 前置知识 几条汇编指令\nmov 目标操作对象,源操作数 add 目标操作对象,源操作数 jmp 寄存器 //修改IP寄存器的值 or jmp CS:IP eg: jmp ax == (let IP = ax) jmp 2AE3:3 == let CS = 2AE3H and let IP = 0003H sub ax,bx ax = ax - bx inc and dec inc 操作对象 eg: inc ax == ax+=1 dec ax == ax-=1 注意：不可用mov指令修改段寄存器的值。（代码段寄存器CS，指令指针寄存器IP） CPU中识别CS:IP为执行指令 操作对象可以是寄存器，也可以是地址\nDebug命令\nr: 看查寄存器内容，或者修改寄存器内容 d: 看查内存内容 e: 改写内存内容 u: 将机器指令翻译为汇编指令 t: 执行下一条汇编指令 a: 写入汇编指令 编译指令\nmasm test link test.obj debug test.exe lab1 MOV WORD PTR [1100],3445 MOV WORD PTR [1102],5678 MOV WORD PTR [1106],6732 MOV AX,[1100] SUB AX,[1102] ADD AX,[1106] MOV [1104],AX HLT //使CPU停止工作 MOV\tAX,1234 MOV\t[1000],AX MOV\tBX,1002 MOV\tBYTE PTR[BX],20 MOV\tDL,39 INC\tBX MOV\t[BX],DL DEC\tDL MOV\tSI,3 MOV\t[BX+SI],DL MOV\t[BX+SI+1],DL MOV\tWORD PTR[BX+SI+2],2846 ","date":"2021-03-16T10:29:27Z","permalink":"https://ez4zzw.github.io/p/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/","title":"汇编语言笔记"},{"content":"本文随机更新机组笔记\nCH2数据表示 定点数与浮点数 定点数 小数点的位置固定不变，有两种形式，定点小数和定点整数. 定点整数要求小数点在数据最低有效数位之后。 $00101001.$ 定点小数要求小数点在数据最高有效数位之前。 $0.1111111$\n浮点数 基数为2的数F，浮点表示为 $F = M \\times 2^E$ 其中M为尾数，E为阶码。尾数为带符号的纯小数，阶码为带符号的纯整数。按照上式表示的数字既可以是纯整数，也可以是纯小数，因此小数点位置不固定，所以称为浮点数。\n在计算机中，常用的一种浮点数表示方法为\n   数符 阶符 阶码数值部分 尾数数值部分     1 1 k n    阶码和尾数的数值范围为\n   阶码与尾数 数值 阶码与尾数 数值     阶码最小值 $-2^k$ 阶码最大值 $2^k-1$   尾数最小负值 $-1$ 尾数最大负值 $-2^{-n}$   尾数最小正值 $+2^{-n}$ 尾数最大正值 $+(1-2^{-n})$    因此可以得到浮点数表示的数值范围： 最小负数:$-2^{2^k-1}=-2^{阶码最大值}$\n最大负数:$-2$\n因此浮点数编码位数位 $m=(n+1)+(k+1)$\n补码 补码的特点：\n  n位补码表示的整数数值范围为$[-2^{n-1},2^{n-1}-1]$\nn位补码表示的小数数值范围为$[-1,1-2^{-n+1}]$\n  在补码中0的表示是唯一的\n  变形码，当模数为4时，可以形成双符号位补码，11表示负，00表示正，当两个符号位不同时表示运算溢出，又叫做变形补码。待更\n  求补运算，处理器中有求补指令，其功能是对操作数取负数(所有位变反+1)\n  简化加减法 $[X+Y]_补=_补+[Y]_补$\n  移码 当一个数字的正数所对的二进制与负数所对的二进制直接比较大小时，会出现负数所对的二进制更大的情况。例如对于十进制数31\n$10011111_{-31} \u0026gt; 01100001_{31}$\n如果对负数补码上加上一个偏移量，再进行比较即可反应实际情况。\n定义为: 对于包括符号位在内的n位字长，在其真值上加上$2^{n-1}$ $[X]_移 =2^{n-1}+X$\n特点： $[X]_移\u0026lt;符号为取反\u0026gt;[X]_补$\n纠错码 若有n位数据，添加k位校验位，共有n+k位编码\n 海明距离： $d = |x-y|=\\sum_{i=0}^{m-1}|x_i-y_i|$\n 可以使用位运算异或求解，获得海明距离\n奇偶校验码  奇校验：设 $X = x_0x_1x_2x_3x_4\u0026hellip;x_{n-1}$ 是一个n位字，在最高位添加一位奇校验c使得 $X'=cx_0x_1x_2x_3x_4\u0026hellip;x_{n-1}$ 有 $c \\oplus x_1\\oplus \u0026hellip; \\oplus x_{n-1} = 1$\n 偶校验则相反，只能判断是否出错，无法纠错\n海明校验码  对于16位数据，用 $D_{16}-D_{0}$ 分别表示高位到低位，要使其拥有1位纠错功能，则需要在有效信息中添加5个校验位，H4～H0 此时海明码的码长为 $m=n+k=16+5=21$\n 循环冗余校验码 大概就是用一个性能比较好的生成多项式构造一个编码，利用模2除法的余数进行校验，而且纠错性能不是100%，先Pass\n运算方法和运算器 加减运算 利用补码的性质，可以将运算转化为补码的加法。\n$[X+Y]_补=[X]_补+[Y]_补$\n这里有一个需要区分的概念，求补运算和求补码的区别\n 求补：对一个正数求补，令其包括符号位在内的各位取反再加1，即可得到该数的负数，若对该负数再求补，可以得到原来的正数。\n $[[X]_补]_求=[-X]_补$\n同理有\n$[[-X]_补]_求=[X]_补$\n可以总结出补码减法的运算法则为\n$[X-Y]_补 = [X]_补+[-Y]_补 =[X]_补+[[Y]_补]_求$\n因此可以将减法转化为加法运算\n溢出判断 只有两个符号相同的数字相加，或者符号相异的数相减才有可能发生溢出。 若分别用xyz表示三个数字的符号位，可得标准最小项 $\\overline{x} \\cdot \\overline{y} \\cdot z+x\\cdot y\\cdot \\overline{z}$ 只有该式为真时，将发生溢出。\n双符号位判定 每个数字有两个符号位，其中00表示正数，11表示负数 令OF OverflowFlag表示溢出符号 $S_1,S_2$ 分别表示运算结果的两符号， 有 $OF = S_1 \\oplus S_2$\n进位符号判定 $令 C_{n-1}表示最高数值位产生的进位，C_n表示符号位产生的进位$ 即有 $OF = C_{n-1}\\oplus C_n$\n一位全加器 计算每一位逻辑 $Z_i=X_i\\oplus Y_i \\oplus C_i$ 进位信号通过递推产生 可以设计出简单的行波式进位加法器，从最低位开始传递进位信号，是异步时序电路，因此运算速度比较慢。\n在位数已知的情况下，可以设计电路一次性计算出所有的进位信号，比较理想的情况是以四个位数为一组，该电路增长量级太大，如果需要更多位数可以利用多个该电路组合使用，组成组内并行组间串行进位加法器。\n","date":"2021-03-15T19:53:04Z","permalink":"https://ez4zzw.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/","title":"计算机组成原理笔记"},{"content":"文章总结自KaTex Support 待更新\nKATEX Support\nKATEX测试 $$ \\frac{\\sum_{i=1}^Nf(x_i)}{\\int_1^\\infin \\frac{1}{e^x}} $$\n","date":"2021-03-14T20:50:48+08:00","permalink":"https://ez4zzw.github.io/p/katex%E6%B5%8B%E8%AF%95%E5%8F%8A%E5%85%B6%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/","title":"Katex测试及其语法总结"},{"content":"从hexo到hugo 从高中开始就采用hexo+GitHub Pages的方式搭建博客，hexo确实很强大，但是由于需要借助node的原因，用起来总是没那么舒服，尤其是在换了电脑之后，配置环境比较麻烦，npm install也比较臃肿，于是决定采用hugo。\nhugo是一个使用go语言开发的博客框架，由于是go编写的，所以渲染速度总的来说比hexo快不少，而且安装起来也很简单，也有不少美观的主题，方便部署到各个平台。\n环境配置 系统环境：macOS arm64 (M1 Silicon) Go Version: go1.16beta1 darwin/arm64 homebrew版本：3.0.5\n我是用的为arm平台的golang，没有测试过用intel平台的go版本进行配置\n安装hugo brew install hugo 创建一个新网站 hugo new site blog 添加一个主题 git init // 初始化git git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack //主题下载 添加篇文章 我的主题文章保存在了content文件夹中的post目录\nhugo new /post/first.md 本地进行渲染预览 hugo server -D 之后可以通过打开localhost:1313来进行预览\n部署到GitHub仓库 hugo -D cd public git init git add . git commit -m \u0026quot;first commit\u0026quot; git remote add origin https://github.com/yourname/yourname.github.io git push origin master ","date":"2021-03-13T23:28:31+08:00","permalink":"https://ez4zzw.github.io/p/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%AE%B0%E5%BD%95/","title":"博客迁移记录"},{"content":"Luogu3964\nDescription 草原上住着一群小松鼠，每个小松鼠都有一个家。时间长了，大家觉得应该聚一聚。但是草原非常大，松鼠们都很头疼应该在谁家聚会才最合理。 每个小松鼠的家可以用一个点$(x,y)$表示,两个点的距离定义为点 $(x,y)$ 和它周围的8个点 $(x-1,y)，(x+1,y),(x,y-1)，(x,y+1)$ $(x−1,y+1),(x-1,y-1),(x+1,y+1),(x+1,y-1)$距离为1。输出一个整数，表示松鼠为了聚会走的路程和最小是多少。\nSolution 观察题目发现，松鼠家之间的距离为切比雪夫距离，可以通过转换成曼哈顿距离求解，即问题转换为给出平面中的N个点，求一个点到其他所有点的曼哈顿距离之和最小是多少。 如果选定的点为第j个 答案即为$\\sum_{i=1}^{N}dis(i,j)$,dis表示两个点的曼哈顿距离 将两个坐标拆开计算，可以得到 $ans_x = \\sum_{i=1}^Ndis(j,i)$ $dis(1,j)+dis(2,j)+dis(3,j) +\u0026hellip;+dis(n,j)$ 将横坐标按照升序排序 $(x_j-x_1)+(x_j-x_2)+(x_j-x_3)+\u0026hellip;+(x_j-x_{j-1})+(x_{j+1}-x_j)+\u0026hellip;+(x_n-x_j)$\n$\\sum_{i=1}^{j-1}(x_j-x_i)+\\sum_{i=j+1}^{N}(x_i-x_j)$\n$(j-1)*x_j-\\sum_{i=1}^{j-1}x_i + \\sum_{i=j+1}^Nx_i-(N-j)*x_j$\n$\\sum_{i=1}^Nx_i-2\\sum_{i=1}^jx_i-x_j*(n-2*j)$ 于是可以使用前缀和优化，坐标排序后预处理前缀和 在每次进行计算时在有序坐标数组中找到对应的下标 精度问题可以先把坐标都扩大二倍，最后令答案处以2\nCode #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;map\u0026gt;#include \u0026lt;set\u0026gt;#define debug cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl #define ll long long const int MAXN = 1e5 + 10; const int MOD = 1e9 + 7; using namespace std; int N; struct point { ll x, y; } a[MAXN]; ll x[MAXN]; ll prex[MAXN]; ll y[MAXN]; ll prey[MAXN]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin \u0026gt;\u0026gt; N; for (int i = 1; i \u0026lt;= N; i++) { int xx, yy; cin \u0026gt;\u0026gt; xx \u0026gt;\u0026gt; yy; x[i] = a[i].x = (xx + yy); y[i] = a[i].y = (xx - yy); } sort(x+1, x+N+1); sort(y+1, y+N+1); for (int i = 1; i \u0026lt;= N; i++) { prex[i] = prex[i-1] + x[i]; prey[i] = prey[i-1] + y[i]; } ll ans = __LONG_LONG_MAX__; for (int i = 1; i \u0026lt;= N; i++) { ll temp; int lx = lower_bound(x+1,x+N+1,a[i].x) - x; int ly = lower_bound(y+1,y+1+N,a[i].y) - y; temp = (prex[N]-2*prex[lx]-a[i].x*(N-2*lx)) +(prey[N]-2*prey[ly]-a[i].y*(N-2*ly)); // cout \u0026lt;\u0026lt; \u0026#34; list = \u0026#34;\u0026lt;\u0026lt; a[i].x \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; a[i].y \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; temp \u0026lt;\u0026lt; endl;  ans = min(ans, temp); } cout \u0026lt;\u0026lt; (ans/2); return 0; } ","date":"2020-10-11T19:45:39Z","permalink":"https://ez4zzw.github.io/p/luogu3964-%E6%9D%BE%E9%BC%A0%E8%81%9A%E4%BC%9A/","title":"Luogu3964-松鼠聚会"},{"content":"51nod3143\nDescription n位战士即将奔赴战场，他们每个人都有一个攻击值ai和一个防御值bi，现在你想设计一种装备给这n位战士，如果这件装备的攻击值为A，防御值为B，那么对于第i位战士这件装备的不匹配度为$max(|A−a_i|,|B−b_i|)$ A，B都是正整数，要让所有战士的不匹配度之和最小，求出最小的不匹配度之和$2\\le N \\le 100000$\nSolution 题意中很明显是切比雪夫距离，可以将其转换为曼哈顿距离 对于点$(x,y)$,转换为$(\\frac{x+y}{2},\\frac{x-y}{2})$ 然后可以求出转换后横坐标和纵坐标的中位数，再以这个中位数为基准，将四周3*3的范围内的点都进行计算，去最小值。 由于涉及除法，可能会发生精度丢失，可以将所有坐标都扩大二倍，最后让答案除以2 同时要注意，这里的A，B都是整数，也就是说我们进行计算的点必须也是整数点，可以通过奇偶关系来判断。答案只用A，B为整数点转换过来的点进行计算。\nCode #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;map\u0026gt;#include \u0026lt;set\u0026gt;#define debug cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl #define ll long long const int MAXN = 1e5 + 10; const int MOD = 1e9 + 7; using namespace std; struct point { ll a, b; } arr[MAXN]; int dx[] = {0, 1, -1, 0, 0, 1, 1, -1, -1}; int dy[] = {0, 0, 0, 1, -1, 1, -1, 1, -1}; ll x[MAXN]; ll y[MAXN]; int main() { ios::sync_with_stdio(false); cin.tie(0); int N; cin \u0026gt;\u0026gt; N; int xx, yy; for (int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; xx \u0026gt;\u0026gt; yy; x[i] = arr[i].a = (xx + yy); y[i] = arr[i].b = (xx - yy); } sort(x+1,x+N+1); sort(y+1,y+N+1); int A, B; ll ans = __LONG_LONG_MAX__; if (N\u0026amp;1) { A = x[N/2+1]; B = y[N/2+1]; } else { A = x[N/2+1]; B = y[N/2+1]; } ll ans2 = 0; for (int i = 0; i \u0026lt;= 8; i++) { int tx = A + dx[i]; int ty = B + dy[i]; if ((tx-ty)%2==1 || ((tx+ty))%2==1) continue; ll temp = 0; for (int j = 1; j \u0026lt;= N; j++) { temp += abs(arr[j].a-tx) + abs(arr[j].b-ty); } ans = min(ans, temp); } cout \u0026lt;\u0026lt; ans/2; return 0; } ","date":"2020-10-11T19:45:25Z","permalink":"https://ez4zzw.github.io/p/51nod3143-%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB%E4%B8%8E%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB/","title":"51nod3143-切比雪夫距离与曼哈顿距离"},{"content":"Description P2709 小B 有一个长为n的整数序列$a$，值域为$[1,k]$。 他一共有m个询问，每个询问给定一个区间$[l,r]$ 求：$\\sum_{i=1}^k c_i^2$ 其中 $c_i$ 表示数字 $i$ 在$[l,r]$ 中的出现次数。 小B请你帮助他回答询问。\nSolution 莫队算法板子题 mark\nCode #include \u0026lt;cstdio\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;map\u0026gt;#include \u0026lt;set\u0026gt;#define mem(a,b) memset(a,b,sizeof(a)) #define debug cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl #define ll long long const int MAXN = 5e4 + 10; const int MOD = 1e9 + 7; using namespace std; struct Q{ int l, r, k; } q[MAXN]; int N, M, K; int pos[MAXN], a[MAXN], cnt[MAXN]; ll ans[MAXN]; ll res; inline void Add(int n) { cnt[a[n]]++; res += 2ll*cnt[a[n]] - 1; } inline void Sub(int n) { cnt[a[n]]--; res -= 2ll*cnt[a[n]] + 1; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M \u0026gt;\u0026gt; K; int siz = sqrt(N); for (int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; a[i]; pos[i] = i/siz; } for (int i = 1; i \u0026lt;= M; i++) { cin \u0026gt;\u0026gt; q[i].l \u0026gt;\u0026gt; q[i].r; q[i].k = i; } sort(q+1,q+M+1,[](Q x, Q y){ return pos[x.l] == pos[y.l] ? x.r \u0026lt; y.r : pos[x.l] \u0026lt; pos[y.l]; }); int l = 1, r = 0; for (int i = 1; i \u0026lt;= M; i++) { while (q[i].l \u0026lt; l) Add(--l); while (q[i].r \u0026gt; r) Add(++r); while (q[i].l \u0026gt; l) Sub(l++); while (q[i].r \u0026lt; r) Sub(r--); ans[q[i].k] = res; } for (int i = 1; i \u0026lt;= M; i++) { cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; endl; } return 0; } ","date":"2020-10-07T22:04:49Z","permalink":"https://ez4zzw.github.io/p/%E8%8E%AB%E9%98%9F-%E5%B0%8Fb%E7%9A%84%E8%AF%A2%E9%97%AE%E6%B4%9B%E8%B0%B7p2709/","title":"莫队-小B的询问洛谷P2709"},{"content":"Description 兔八哥躲藏在树林旁边的果园里。果园有M × N棵树，组成一个M行N列的矩阵，水平或垂直相邻的两棵树的距离为1。兔八哥在一棵果树下。 猎人背着猎枪走进了果园，他爬上一棵果树，准备杀死兔八哥。 如果猎人与兔八哥之间没有其它的果树，猎人就可以看到兔八哥。 现己知猎人和兔八哥的位置，编写程序判断兔子所在的位置是否安全. 输入：　第一行为n，表示有n(n ≤ 100,000)组数据，每组数据的第一行为两个正整数ax和ay，表示猎人的位置，第二行为两个正整数bx和by，表示兔八哥的位置(1 ≤ ax, ay, bx, by ≤ 100,000,000)。 输出： 共有n行，每行为“yes”或“no”表示兔八哥的位置是否安全。\nSolution 容易想到，兔八哥和猎人只要连线上无整数点即可，可以转化成$|a_x - b_x| 和 |a_y - b_y|$互质，即$gcd(|a_x - b_x|,|a_y - b_y|)=1$\nCode #include\u0026lt;bits/stdc++.h\u0026gt;#define mem(a,b) memset(a,b,sizeof(a)) typedef long long ll; typedef unsigned long long ull; using namespace std; inline int gcd(int a, int b) { return b == 0 ? a : gcd(b,a%b); } int main() { //freopen(\u0026#34;test.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); \tios::sync_with_stdio(false); cin.tie(0); int N; cin \u0026gt;\u0026gt; N; while (N--) { int ax, ay, bx, by; cin \u0026gt;\u0026gt; ax \u0026gt;\u0026gt; ay; cin \u0026gt;\u0026gt; bx \u0026gt;\u0026gt; by; int xx = abs(ax - bx); int yy = abs(ay - by); if (gcd(xx,yy) != 1) { cout \u0026lt;\u0026lt; \u0026#34;yes\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;no\u0026#34; \u0026lt;\u0026lt; endl; } } return 0; } ","date":"2020-10-07T22:04:23Z","permalink":"https://ez4zzw.github.io/p/gcd-%E5%85%94%E5%85%AB%E5%93%A5%E4%B8%8E%E7%8C%8E%E4%BA%BA/","title":"GCD-兔八哥与猎人"},{"content":"Description HDU 2566 假设一堆由1分、2分、5分组成的n个硬币总面值为m分，求一共有多少种可能的组合方式（某种面值的硬币可以数量可以为0）。\nSolution 坑题，没给数据范围，只能瞎猜，一发搜索挂掉发现无法去重，但是考虑到该问题满足从1开始分配并无后效性，可以直接递推（类似背包），三种物品可选任意次\nCode #include\u0026lt;bits/stdc++.h\u0026gt;#define mem(a,b) memset(a,b,sizeof(a)) typedef long long ll; typedef unsigned long long ull; using namespace std; int main() { //freopen(\u0026#34;test.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); \tios::sync_with_stdio(false); int N, M; int ans;\tint dp[2000][2000]; int n[] = {1,2,5}; cin.tie(0); int T; cin \u0026gt;\u0026gt; T; while (T--) { cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; mem(dp,0); dp[0][0] = 1; for (int i = 0; i \u0026lt; 3; ++i) { for (int j = 1; j \u0026lt;= N; ++j) { for (int k = n[i]; k \u0026lt;= M; ++k) { dp[j][k] += dp[j-1][k-n[i]]; } } } cout \u0026lt;\u0026lt; dp[N][M] \u0026lt;\u0026lt; endl; } return 0; } ","date":"2020-10-07T22:04:23Z","permalink":"https://ez4zzw.github.io/p/%E7%BB%9F%E8%AE%A1%E7%A1%AC%E5%B8%81-%E9%80%92%E6%8E%A8/dp/","title":"统计硬币-递推/DP"},{"content":"中缀表达式求值 对于表达式求值，我们通常用栈来操作。 常用的做法是先转换为后缀表达式，再利用栈来求值。 步骤如下：\n 开一个栈一个储存运算符，再开一个结构存后缀表达式，可以选择string数组 每遇到一个数字，将其加入到后缀表达式种 遇到左括号，加入到符号栈种 遇到右括号，不断将栈顶元素添加到后缀表达式中，直到遇到左括号，然后弹出左括号 遇到普通运算符，只要栈顶符号的优先级不低于新符号，就不断取出栈顶元素存到后缀表达式，然后将新符号入栈，优先级顺序为乘除\u0026gt;加减\u0026gt;左括号 依次取出符号栈中剩余元素，加入到后缀表达式中 将得到的后缀表达式求值  Note 代码在取栈顶元素时容易出错，需要注意对栈为空时的判断\nCode #include \u0026lt;cstdio\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;stack\u0026gt;#include \u0026lt;map\u0026gt;#include \u0026lt;set\u0026gt;#define mem(a,b) memset(a,b,sizeof(a)) #define debug cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl #define ll long long const int MAXN = 1e4 + 10; const int MOD = 1e9 + 7; using namespace std; stack\u0026lt;int\u0026gt; stnumber; stack\u0026lt;char\u0026gt; stsign; stack\u0026lt;int\u0026gt; ans; struct node { string s=\u0026#34;\u0026#34;; } a[MAXN]; int oder(char c) { if (c == \u0026#39;+\u0026#39; || c == \u0026#39;-\u0026#39;) return 1; else if (c == \u0026#39;*\u0026#39; || c == \u0026#39;/\u0026#39;) return 2; return 0; } int toInt(string ss) { int res = 0; for (int i = 0; i \u0026lt; ss.length(); i++) { res = res*10 + ss[i] - \u0026#39;0\u0026#39;; } return res; } int calc(int aa, int bb, char op) { switch (op) { case \u0026#39;+\u0026#39;: return aa + bb; break; case \u0026#39;/\u0026#39;: return bb / aa; break; case \u0026#39;*\u0026#39;: return aa*bb; break; case \u0026#39;-\u0026#39;: return bb - aa; break; default: break; } } bool isnum(char si) { if (si \u0026lt;= \u0026#39;9\u0026#39; \u0026amp;\u0026amp; si \u0026gt;= \u0026#39;0\u0026#39;) return true; return false; } int cur = 0; int main() { ios::sync_with_stdio(false); cin.tie(0); int N; cin \u0026gt;\u0026gt; N; string s; cin \u0026gt;\u0026gt; s; N = s.length(); int len = 0; for (int i = 0; i \u0026lt; N; i += len) { len = 0; if (isnum(s[i])) { string t = \u0026#34;\u0026#34;; for (int j = i; j \u0026lt; N; j++) { if (isnum(s[j])) { t += s[j]; len++; } else { break; } } a[++cur].s = t; } else { if (s[i] == \u0026#39;(\u0026#39;) stsign.push(s[i]); else if (s[i] == \u0026#39;)\u0026#39;) { while (stsign.top() != \u0026#39;(\u0026#39;) { char op = stsign.top(); stsign.pop(); a[++cur].s += op; } stsign.pop(); } else { char op = s[i]; if (!stsign.empty()) while (!stsign.empty() \u0026amp;\u0026amp; oder(stsign.top()) \u0026gt;= oder(op)) { a[++cur].s += stsign.top(); stsign.pop(); //if (stsign.empty()) break;  } stsign.push(op); } len = 1; } } while (!stsign.empty()) { char op = stsign.top(); stsign.pop(); a[++cur].s += op; } // for (int i = 1; i \u0026lt;= cur; i++) {  // cout \u0026lt;\u0026lt; a[i].s \u0026lt;\u0026lt; endl;  // }  for (int i = 1; i \u0026lt;= cur; i++) { int temp; if (isnum(a[i].s[0])) { temp = toInt(a[i].s); ans.push(temp); } else { int aa = ans.top(); ans.pop(); int bb = ans.top(); ans.pop(); ans.push(calc(aa, bb, a[i].s[0])); } } cout \u0026lt;\u0026lt; ans.top(); return 0; } ","date":"2020-10-07T22:03:17Z","permalink":"https://ez4zzw.github.io/p/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/","title":"中缀表达式求值"},{"content":"Description 给出整数$n,k$,计算$G(n,k)=\\sum\\limits_{i=1}^n=k \\ mod \\ i$,$1\u0026lt;=n,k\u0026lt;=1e9$\nSolution 将k mod i展开可以得到$k - i*\\lfloor \\frac{k}{i} \\rfloor$ 将求和式子展开可以得到$ \\sum\\limits_{i=1}^n = n*k-\\sum\\limits_{i=1}^n i * \\lfloor\\frac{k}{i} \\rfloor $ 利用整除分块，可以发现，对于相同的$\\lfloor\\frac{k}{i} \\rfloor$，即每个区间$l 到 r$，每次只需要再对i求和即可 即每次计算$(r-l+1)*\\lfloor \\frac{k}{i} \\rfloor * (l+r)/2$\nNote 在分块的时候误写为r=N/(N/i)导致调试耽误大量时间，而且交了四发才发现\nfor (ll l = 1, r; l \u0026lt;= N; l = r + 1) { if (l \u0026gt; K) { break; } r = min(N, K/(K/l)); ans -= (r - l + 1)*(K/l)*(l + r)/2; } Code //https://www.luogu.com.cn/problem/P2261 #include \u0026lt;cstdio\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;map\u0026gt;#include \u0026lt;set\u0026gt;#define mem(a,b) memset(a,b,sizeof(a)) #define debug cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl #define ll long long const int MAXN = 1e2 + 10; const int MOD = 1e9 + 7; using namespace std; ll ans = 0; void solve(ll N, ll K) { ans = N*K; for (ll l = 1, r; l \u0026lt;= N; l = r + 1) { if (l \u0026gt; K) { break; } r = min(N, K/(K/l)); ans -= (r - l + 1)*(K/l)*(l + r)/2; } cout \u0026lt;\u0026lt; ans; } int main() { ios::sync_with_stdio(false); cin.tie(0); ll N, K; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; K; solve(N, K); return 0; } ","date":"2020-10-07T21:47:20Z","permalink":"https://ez4zzw.github.io/p/%E4%BD%99%E6%95%B0%E6%B1%82%E5%92%8C-%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/","title":"余数求和-整除分块"},{"content":"Description 求平面上n个点构成的平行四边形个数。 输入 一行一个数n。 接下来n行，每行两个数x,y，表示这个点的坐标为(x,y)。 保证任意两点不重合，任意三点不共线。 输出 一行一个整数表示平行四边形个数。\nSolution 按照平行四边形的性质，两组顶点的中点重合，可以统计出每组顶点的中点，再统计每个顶点的个数，排列组合一下\nNote 第一发对于顶点的统计出锅了，排序条件写错，提交都要检查排序\n","date":"2020-05-13T22:05:25Z","permalink":"https://ez4zzw.github.io/p/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95-%E5%B9%B3%E8%A1%8C%E5%9B%9B%E8%BE%B9%E5%BD%A2/","title":"计算几何-平行四边形"},{"content":"Description 请输出$Fib(n) mod 10000$ $n \\leq 1000000000$\nSolution 由于$n$的范围在$1e9$直接递推铁TLE，考虑矩阵快速幂 Fibonacci数列有如下性质 通过多次迭代 算是个板子题吧，记得在WUST新生赛做过一道想矩阵快速幂的题，然而正解是找规律QAQ，在此贴个板子。\nCode #include \u0026lt;cstdio\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;string\u0026gt;typedef long long LL; const int MOD = 1e4; using namespace std; struct Matrix{ LL m[2][2]; void print(){ for (int i = 0; i \u0026lt; 2; i++) { for (int j = 0; j \u0026lt; 2; j++) cout \u0026lt;\u0026lt; m[i][j] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl;\t} } } base, ans; Matrix times(Matrix a, Matrix b) { Matrix ans; ans.m[0][1] = ans.m[0][0] = ans.m[1][0] = ans.m[1][1] = 0; for (int i = 0; i \u0026lt; 2; i++) { for (int j = 0; j \u0026lt; 2; j++) { for (int k = 0; k \u0026lt; 2; k++) ans.m[i][j] = (ans.m[i][j] + a.m[i][k]*b.m[k][j])%MOD; } } return ans; } void Matrixpow(LL x) { base.m[0][0] = base.m[1][0] = base.m[0][1] = 1; base.m[1][1] = 0; ans.m[0][0] = ans.m[1][1] = 1; ans.m[0][1] = ans.m[1][0] = 0; while (x) { if (x\u0026amp;1){ ans = times(ans, base); } x \u0026gt;\u0026gt;= 1; base = times(base, base); } } LL N; int main(){ while (cin \u0026gt;\u0026gt; N) { if (N == -1) break; if (N == 0) { cout \u0026lt;\u0026lt; \u0026#34;0\u0026#34; \u0026lt;\u0026lt; endl; continue; } Matrixpow(N); cout \u0026lt;\u0026lt; ans.m[0][1] % MOD \u0026lt;\u0026lt; endl; }\treturn 0; } ","date":"2019-12-13T18:58:24Z","permalink":"https://ez4zzw.github.io/p/fibonacci-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/","title":"Fibonacci 矩阵快速幂"},{"content":"Description 有$n$个木棍，长度为$1,2,3\u0026hellip;n$，现在要从中删掉一些木棍，使得剩下的木棍不能构成三角形，使删掉木棍的数量最少。T组数组，$T \\leq 20$ $n \\leq 20$\nSolution 由于数据范围很小，可以直接暴力求解，依次选取两个数$a,b(a\u0026lt;b)$相加，要知道不能有任何一个数小于这个值，直接删掉$(a,a+b)$范围中的数即可 如果$n$的范围是$1e9$呢？ 通过找规律发现我们剩下的数是这样的 $1,2,3,5,8,13,21\u0026hellip;$ 这是Fibonacci数列!!!! 所以我们只需要找到$\\leq n$的Fibonacci数有几个，减去就是答案 可以直接lower_bound注意处理极限数据！！！即$n==1||n==2$的情况 也可手写二分，但是二分貌似常数有点大，又考虑到第$88$个Fibonacci数就爆掉$1e9$了，所以直接便利也完全没问题\nCode 暴力版本 #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;queue\u0026gt;using namespace std; bool vis[23]; int main() { int T; cin \u0026gt;\u0026gt; T; for (int i = 1; i \u0026lt;= T; i++) { int N, ans = 0; cin \u0026gt;\u0026gt; N; memset(vis, false, sizeof(vis)); for (int j = 1; j \u0026lt;= N - 1; j++) if (!vis[j]) { for (int k = j + 1; k \u0026lt;= N; k++) { if (!vis[k]) { for (int l = k + 1; l \u0026lt;= j + k - 1; l++) if (!vis[l] \u0026amp;\u0026amp; l \u0026lt;= N) vis[l] = true, ans++; break; } } } printf(\u0026#34;Case #%d: %d\\n\u0026#34;, i, ans); } return 0; } 二分+Fib #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;queue\u0026gt;typedef unsigned long long uLL; typedef long long LL; const LL MOD = 1e18; using namespace std; LL f[100]; int main() { f[0] = 1; f[1] = 1; for (int i = 2; i \u0026lt;= 80; i++) f[i] = f[i - 1] + f[i - 2]; int T; cin \u0026gt;\u0026gt; T; for (int i = 1; i \u0026lt;= T; i++){ LL N; cin \u0026gt;\u0026gt; N; if (N == 1 || N == 2) { printf(\u0026#34;Case #%d: 0\\n\u0026#34;, i); continue; } int l = 1, r = 80; /*手写二分查找 while (l \u0026lt;= r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (f[mid] \u0026lt;= N) l = mid + 1; else r = mid - 1; } int pos = l; */ int pos = lower_bound(f, f + 80, N) - f; if (f[pos] != N) pos--; printf(\u0026#34;Case #%d: %d\\n\u0026#34;, i, N - pos); } return 0; } ","date":"2019-12-13T18:58:14Z","permalink":"https://ez4zzw.github.io/p/triangle-fibonacci-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","title":"Triangle Fibonacci+二分查找"},{"content":"Description 在杨辉三角中，从第一行第一列$(0,0)$开始，每次可选择向正下方走或向右下方走，走到第$n$行时不能超过第$n$行第$k$个元素，询问所经过路径的值的和的最小值$mod(p)$，一共有T组询问，$T \\leq 100000$， $0 \\leq k \\leq n \\leq 1e9$, 保证$p$是质数， 其中$p \u0026lt; 1e4$\nSolution 名字虽然是DP，但是可以找出最优方案。 优先考虑$k \\leq \\frac{n}{2}$的情况，先向下走$n-k$步到达$(n-k-1,0)$ 再一路沿着右下方走，直到到达底部，即有$C_{n-k}^{0}+C_{n-k+1}^{1}+C_{n-k+2}^{2}+\u0026hellip;+C_{n}^{k}=C_{n+1}^{k}$ 通过变换$C_{n-k}^{0} = C_{n-k+1}{0}$ 再通过公式$C_{n}^{m}=C_{n-1}^{m}+C_{n-1}^{m-1}$可将上述公式合并 得到$C_{n+1}^{k}$ 所以答案为$C_{n+1}^{k}+n-k$ 当$k \u0026gt; \\frac{n}{2}$时，根据对称性，令$k=n-k$即可转化成上一种情况 又发现题目涉及组合数取模，所以要用到**费马小定理**\n 费马小定理: 假如$a$是一个整数，$p$是一个质数，且$gcd(a,p)=1$，即$a,p$互质，那么有$a^{p−1}≡1(modp)$\n 已知$a^{p-1}≡1$，可以得到$a \\cdot a^{p-2}≡1$，我们称$a$和$a^{p-2}$为在$mod(p)$意义下的乘法逆元 然而这只解决了除法取模的问题，注意到$n$的范围在$1e9$直接计算组合数又是铁套老鹅(TLE)，于是借助Lucas定理\n对于质数$p$,有$C_n^m\\ mod \\ p = C_{\\lfloor \\frac{n}{p} \\rfloor}^{\\lfloor \\frac{m}{p} \\rfloor} \\cdot C_{n\\ mod\\ p}^{m\\ mod\\ p} \\ mod \\ p$\n可知$n\\ mod\\ p$和$m\\ mod\\ p$一定是小于$p$的数，可直接求解，其余部分继续用Lucas定理求解，当$m=0$的时候返回$1$\nlong long Lucas(long long n, long long m, long long p) { if (m == 0) return 1; return (C(n % p, m % p, p) * Lucas(n / p, m / p, p)) % p; } 有了这些工具之后就可以预处理阶乘和逆元了\nCode #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;queue\u0026gt;typedef long long LL; const int MAXN = 10000; using namespace std; LL N,K,MOD; bool isnotp[MAXN + 10]; LL pri[1500], num = 0;//素数表 int f[1300][MAXN];//阶乘 int inv[1300][MAXN];//逆元  inline void Euler() { isnotp[1] = true; memset(isnotp, false, sizeof(isnotp)); for (int i = 2; i \u0026lt;= MAXN; i++) { if (!isnotp[i]) pri[++num] = i; for (int j = 1; j \u0026lt;= num \u0026amp;\u0026amp; i*pri[j] \u0026lt;= MAXN; j++) { isnotp[i*pri[j]] = true; if (i%pri[j]==0) break; } } } LL fffpow(LL x, LL y, LL pp) { LL sum = 1; LL a = x; while (y) { if (y\u0026amp;1) { sum = (sum*a) % pp; } a = (a*a)%pp; y\u0026gt;\u0026gt;=1; } return (sum)%pp; } int cnt = 0; inline LL Lucas(int N,int M,int o) { LL a,b,ans=1; while(N \u0026amp;\u0026amp; M) { a = N%pri[o]; b = M%pri[o]; if(a \u0026lt; b)return 0; ans = ans*f[o][a]%pri[o]*inv[o][b]%pri[o]*inv[o][a-b]%pri[o]; N /= pri[o]; M /= pri[o]; } return ans; } int main() {\tEuler(); for(int i = 1; i \u0026lt;= num; i++) { f[i][0] = f[i][1] = 1; inv[i][0] = inv[i][1] = 1; for(int j = 2;j \u0026lt; pri[i]; j++) { f[i][j] = f[i][j-1]*j % pri[i]; inv[i][j] = fffpow(f[i][j], pri[i]-2, pri[i]); } } while (cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; K \u0026gt;\u0026gt; MOD) { LL ans; if(K \u0026gt; N/2) K = N - K; int l = 1, r = 1229; while(l \u0026lt;= r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if(MOD \u0026lt; pri[mid]) r = mid - 1; else l = mid + 1; } ans = (Lucas(N + 1, K, l - 1) + N - K)%MOD; printf(\u0026#34;Case #%d: %lld\\n\u0026#34;, ++cnt, ans);\t} return 0; } ","date":"2019-12-13T18:57:13Z","permalink":"https://ez4zzw.github.io/p/dp-%E7%B4%A0%E6%95%B0%E7%AD%9B-lucas%E5%AE%9A%E7%90%86-%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/","title":"DP? 素数筛+Lucas定理+费马小定理"},{"content":"Description 小兔的叔叔从外面旅游回来给她带来了一个礼物，小兔高兴地跑回自己的房间，拆开一看是一个棋盘，小兔有所失望。不过没过几天发现了棋盘的好玩之处。从起点$(0，0)$走到终点$(n,n)$的最短路径数是$C_{2n}^{n}$,现在小兔又想如果不穿越对角线(但可接触对角线上的格点)，这样的路径数有多少?小兔想了很长时间都没想出来，现在想请你帮助小兔解决这个问题，对于你来说应该不难吧! $n \\leq 35$\nSolution 由于规定不能超过对角线，可用分治的思想，只考虑沿对角线分隔开的三角形的情况，对于一个三角形中，求从$(0，0)$走到终点$(n,n)$的最短路径，观察发现无论怎么走，设到达某一点时向上走了$i$步，向右走了$j$步，都有$i \\leq j$这也能通过线性规划相关知识证明。不难发现只是一个类括号匹配问题，可用$Catalan$数求解，计算$C(n)$后即是在一个三角形中的解，答案是$2C(n)$\n$C(n) = \\sum_{i=0}^{n-1} C(i) \\cdot C(n-i-1)$ 通项公式$C(n)=\\frac{C_{2n}^{n}}{n+1}$\n预处理$C(n)$即可\nCode #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;queue\u0026gt;typedef long long LL; using namespace std; LL C[100]; int main() { C[0] = 1; C[1] = 1; for (int i = 2; i \u0026lt;= 80; i++) { LL t = 0; for (int j = 0; j \u0026lt; i; j++) t += C[j]*C[i - j - 1]; C[i] = t; } LL N; int cnt = 1; while (cin \u0026gt;\u0026gt; N) { if (N == -1) break; cout \u0026lt;\u0026lt; cnt++ \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; N \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; C[N]*2 \u0026lt;\u0026lt; endl; } return 0; } ","date":"2019-12-13T18:56:57Z","permalink":"https://ez4zzw.github.io/p/%E5%B0%8F%E5%85%94%E7%9A%84%E6%A3%8B%E7%9B%98-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/","title":"小兔的棋盘 组合数学"},{"content":"Day -N 快新生赛了啊啊啊啊，半个多月没碰算法题了，一直在搞ToKen的前端任务，还在搞服务器的事，感觉要凉凉。\nDay 1 嗯，就只有Day1. 早上起的很晚，八点半才从床上爬起来，起来之后第一件事是看我的USB-HUB发货没有!!!都好几天了，一个USB接口坏了，机械键盘没法用啊，想去买usb转type-c线的想了想还是再等等吧ε=ε=ε=┏(゜ロ゜;)┛ 下楼去堕落一条街吃了早饭。 中午吃完饭回来买了杯奶茶丫丫精，发现喝完了有点撑得慌~~~~然后就等12.30了。 比赛开始赶紧去找签到题。\nA题 emmmmm像是的数学题，递推，一看数据范围感觉不可做。\nB题 这题面稍微有点问题啊。室友就以为是按顺序组合起来的，虽然感觉仔细想想也想出来是求和的，直接DFS走了？？？不存在的，这里有个老年人sum没重置，debug一万年啊，最后才发现sum每次没有赋初值ε=ε=ε=┏(゜ロ゜;)┛\nC题 签到题\nD题 一开始没看清题意，直接while求Σa*0.1一直到不影响答案为止，算到了1e-5，第一发不知道咋WA了，两发才过。\nE题 博弈论，不可做\nF题 并查集。但是！！老年人在这里又拉胯了！！！要输出没有感染的人，我输出了一万年感染的人，交了五六发？？？\nJ题 模拟题。\nＨ题 贪心交了一发没过，分类讨论情况可能会很多，没敢用搜索。\nI题 博弈论sg==就会三种博弈的蒟蒻枯了。听WHU的巨巨说记忆化搜索也能过。\nJ题 计算几何。我认输。在线处理当成直线做的，没考虑到路程是个线段，debug一万年，最后还有半个小时封板的时候放弃了QAQ\nK题 模拟题，我充分意识到半个小时可能写不出来了，想去debug一下J题吧\n后记 最后五题榜19。校内 榜二。WHU和HUST的巨巨们霸榜啊orz。\n进队了orz\n其实感觉中间耽误了好多时间啊，低级错误，不然可能会在开出两题，just可能。orz\nJ题一大遗憾。也是给自己个教训吧。\n至此 成为WHUTer之后，又成为了ToKener，又成为了ACMer。 专心训练和学习啦。 逃ε=ε=ε=┏(゜ロ゜;)┛：蒟蒻 蒟蒻 蒟蒻\n","date":"2019-11-16T21:48:04Z","permalink":"https://ez4zzw.github.io/p/whut%E6%96%B0%E7%94%9F%E8%B5%9B%E6%B8%B8%E8%AE%B0/","title":"WHUT新生赛\"游记\""}]