<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Storage on Coding_Panda&#39;s Blog</title>
        <link>https://blog.ipandai.club/tags/storage/</link>
        <description>Recent content in Storage on Coding_Panda&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Tue, 11 Oct 2022 13:44:49 +0800</lastBuildDate><atom:link href="https://blog.ipandai.club/tags/storage/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>【存储系统】文件系统</title>
        <link>https://blog.ipandai.club/p/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link>
        <pubDate>Tue, 11 Oct 2022 13:44:49 +0800</pubDate>
        
        <guid>https://blog.ipandai.club/p/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid>
        <description>&lt;h1 id=&#34;0x00-基本概念&#34;&gt;0x00 基本概念&lt;/h1&gt;
&lt;p&gt;文件的基本概念， 包含信息的比特流/块，计算机往往需要处理远高于主存容量的数据，需要使用文件来保存；文件的生命周期更长，不能存储在堆栈中；对文件的数据/信息对外进行分享的媒介。可以用于进程间的信息共享，自由性和容量上都优于共享内存的方式。&lt;/p&gt;
&lt;h2 id=&#34;文件系统的功能&#34;&gt;文件系统的功能&lt;/h2&gt;
&lt;p&gt;Namespace 命名空间&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件目录的建立、维护和检索（目录树）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;存储管理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空间管理：存储空间的分配和管理（管理空闲的块）&lt;/li&gt;
&lt;li&gt;文件块管理：逻辑地址与存储物理地址的映射（logical offset—Physical Block number）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据保护&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件出现坏块&lt;/li&gt;
&lt;li&gt;灾备&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可靠性/一致性&lt;/p&gt;
&lt;h1 id=&#34;0x01-用户视角&#34;&gt;0x01 用户视角&lt;/h1&gt;
&lt;h2 id=&#34;文件目录操作&#34;&gt;文件目录操作&lt;/h2&gt;
&lt;p&gt;文件操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Create/Delete&lt;/li&gt;
&lt;li&gt;Open/Close 返回File Handle&lt;/li&gt;
&lt;li&gt;Read/Write&lt;/li&gt;
&lt;li&gt;Append 追加写入&lt;/li&gt;
&lt;li&gt;Seek 移动文件指针 offset&lt;/li&gt;
&lt;li&gt;Getattr/Setattr 读取/修改inode中保存的文件信息&lt;/li&gt;
&lt;li&gt;Rename&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目录操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Createdir/rmdir&lt;/li&gt;
&lt;li&gt;Link 软链接、硬链接 讲目录项目指向文件的inode&lt;/li&gt;
&lt;li&gt;Unlink&lt;/li&gt;
&lt;li&gt;Readdir 读取子目录以及目录项&lt;/li&gt;
&lt;li&gt;Rename&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;文件目录的构成&#34;&gt;文件目录的构成&lt;/h2&gt;
&lt;p&gt;文件的组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件内容，字节序列&lt;/li&gt;
&lt;li&gt;文件的元数据metadata，文件控制块，Unix系统中称为inode(index node)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目录的组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本质是一种特殊的文件，内容是子目录、文件等目录项目&lt;/li&gt;
&lt;li&gt;目录也有inode&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;file-handle&#34;&gt;File Handle&lt;/h2&gt;
&lt;p&gt;创建原文件的一个实例对象，对其进行读写，Offset可以共享给两个File Handle，也可以每个File Handle独有各自的Offset。&lt;/p&gt;
&lt;p&gt;Linux VFS中为文件描述符fd，对应一个File Object，包含文件的信息，文件系统管理dentry、inode的缓存，用于查找文件在磁盘上的位置。关于&lt;strong&gt;Linux VFS&lt;/strong&gt;的内容，计划再单独开个博客记录一下。&lt;/p&gt;
&lt;h2 id=&#34;file-control-block-inode&#34;&gt;File Control Block (Inode)&lt;/h2&gt;
&lt;p&gt;每个文件唯一的id，包含以下结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Block的信息，文件在磁盘上的位置&lt;/li&gt;
&lt;li&gt;数据大小&lt;/li&gt;
&lt;li&gt;Ctime创建时间，utime更新时间，access time最后一次访问时间&lt;/li&gt;
&lt;li&gt;所有者信息，ACL(access control lists)访问控制&lt;/li&gt;
&lt;li&gt;链接情况统计&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;dirent---directory-entry&#34;&gt;Dirent - Directory Entry&lt;/h2&gt;
&lt;p&gt;目录项纪录子文件和子目录的名称&lt;/p&gt;
&lt;p&gt;每个目录项的结构&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;大小&lt;/th&gt;
&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;__le32&lt;/td&gt;
&lt;td&gt;4bytes&lt;/td&gt;
&lt;td&gt;Inode&lt;/td&gt;
&lt;td&gt;inode编号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;__le16&lt;/td&gt;
&lt;td&gt;2bytes&lt;/td&gt;
&lt;td&gt;Rec_len&lt;/td&gt;
&lt;td&gt;目录项的长度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;__u8&lt;/td&gt;
&lt;td&gt;2bytes&lt;/td&gt;
&lt;td&gt;Name_len&lt;/td&gt;
&lt;td&gt;文件名长度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;__u8&lt;/td&gt;
&lt;td&gt;2bytes&lt;/td&gt;
&lt;td&gt;File_type&lt;/td&gt;
&lt;td&gt;文件类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char[EXT2_NAME_LEN]&lt;/td&gt;
&lt;td&gt;最大255个字符&lt;/td&gt;
&lt;td&gt;Name&lt;/td&gt;
&lt;td&gt;文件名&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;所有目录都包含的目录项包括当前目录和上级目录:&lt;code&gt;.&lt;/code&gt;,&lt;code&gt;..&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;要对文件名进行4字节对齐，后面补&lt;code&gt;\0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;所有目录项顺序拼接组成目录信息，在进行查询时可以使用rec_len来计算偏移量，便于查找目录中的文件（顺序遍历）&lt;/p&gt;
&lt;h2 id=&#34;目录树&#34;&gt;目录树&lt;/h2&gt;
&lt;p&gt;目录树的结构如下图所示，每个目录都有自己的inode，同时还有direntry，对其中的子目录可以构建子树，文件可以建立文件子节点&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.ipandai.club/image-20221011191955170.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221011191955170&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;根据Pathname查找文件的过程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从根目录&lt;code&gt;/&lt;/code&gt;开始查询，解析出要查询的项目&lt;/li&gt;
&lt;li&gt;获取当前目录的目录项（可能在内存中，也可能要向磁盘请求）&lt;/li&gt;
&lt;li&gt;比对相应的纪录是否存在于目录项中，比对成功则获取其inode&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查找过程中需要考虑的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;检查权限：在每级目录查找时，需要检查是否有对当前目录进行访问的权限，然后才能继续进行操作&lt;/li&gt;
&lt;li&gt;检测是否为软链接/符号链接(Symbolic link)：目录项可能指向同一个inode，防止出现循环链接&lt;/li&gt;
&lt;li&gt;检测是否挂载了其他文件系统，文件名可以是挂在文件系统的挂载点，若出现此类情况需要进入新的文件系统进行查找&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;access-control-lists-访问控制&#34;&gt;Access Control Lists 访问控制&lt;/h2&gt;
&lt;p&gt;基本ACL纪录内容：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;记录类型&lt;/th&gt;
&lt;th&gt;格式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Owner&lt;/td&gt;
&lt;td&gt;user::rwx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Owning Group&lt;/td&gt;
&lt;td&gt;group::rwx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Others&lt;/td&gt;
&lt;td&gt;other::rwx&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;rwx为掩码形式，使用三位八进制，&lt;code&gt;777&lt;/code&gt;为可读可写可执行，系统调用为&lt;code&gt;chmod&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在文件系统中有扩展ACL，记录内容为：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;记录类型&lt;/th&gt;
&lt;th&gt;格式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Owner&lt;/td&gt;
&lt;td&gt;user::rwx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Named User&lt;/td&gt;
&lt;td&gt;user:name:rwx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Owning Group&lt;/td&gt;
&lt;td&gt;group::rwx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Named Group&lt;/td&gt;
&lt;td&gt;group:name:rwx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Mask&lt;/td&gt;
&lt;td&gt;mask::rwx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Others&lt;/td&gt;
&lt;td&gt;other::rwx&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;对于文件的访问权限通过Named User，Owning Group和Named Group进行授权，同时可以使用Mask设置掩码对权限进行控制，例如有权限&lt;code&gt;r-x&lt;/code&gt;，对于Mask:&lt;code&gt;mask::rw-&lt;/code&gt;，最终的操作权限为&lt;code&gt;r--&lt;/code&gt;，将掩码和权限进行与操作&lt;/p&gt;
&lt;p&gt;不同文件系统有对ACL不同的扩展和实现&lt;/p&gt;
&lt;h2 id=&#34;example&#34;&gt;Example&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;int fd = open(&amp;quot;/foo/bar.txt&amp;quot;, RO)&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;查找文件的inode
&lt;ol&gt;
&lt;li&gt;在根目录查找foo目录&lt;/li&gt;
&lt;li&gt;读取foo目录的内容&lt;/li&gt;
&lt;li&gt;在foo目录中查找bar&lt;/li&gt;
&lt;li&gt;每次查询先在缓存中进行查找&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;为inode创建vnode结构
&lt;ol&gt;
&lt;li&gt;判断inode是否在inode cache中，若不在则需要从磁盘中请求&lt;/li&gt;
&lt;li&gt;请求后创建vnode缓存&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;初始化File Object&lt;/li&gt;
&lt;li&gt;生成fd，填充数据信息&lt;/li&gt;
&lt;li&gt;返回fd给进程&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;0x02-实现角度&#34;&gt;0x02 实现角度&lt;/h1&gt;
</description>
        </item>
        <item>
        <title>【存储系统】多硬盘存储系统</title>
        <link>https://blog.ipandai.club/p/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E5%A4%9A%E7%A1%AC%E7%9B%98%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</link>
        <pubDate>Wed, 05 Oct 2022 16:54:42 +0800</pubDate>
        
        <guid>https://blog.ipandai.club/p/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E5%A4%9A%E7%A1%AC%E7%9B%98%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</guid>
        <description>&lt;h1 id=&#34;0x00-多硬盘系统&#34;&gt;0x00 多硬盘系统&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.ipandai.club/image-20221005193755942.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221005193755942&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;对多硬盘系统可靠性的度量，上图从&lt;code&gt;故障产生&lt;/code&gt;，&lt;code&gt;故障产生程序错误&lt;/code&gt;，&lt;code&gt;错误检测&lt;/code&gt;，&lt;code&gt;修复故障&lt;/code&gt;四个时间节点为一个周期。&lt;/p&gt;
&lt;p&gt;三个可靠性的指标：&lt;/p&gt;
&lt;p&gt;可靠性：通过&lt;code&gt;错误产生到发现错误&lt;/code&gt;的时间间隔MTTF来衡量&lt;/p&gt;
&lt;p&gt;可维护性：通过&lt;code&gt;发现错误到错误修复&lt;/code&gt;的时间间隔来衡量，定义系统修复的能力&lt;/p&gt;
&lt;p&gt;可用性：通过系统中非修复时间所占的比例，可以对外提供服务的时间占比，$EA=\frac{MTTF}{MTTF+MTTR}$&lt;/p&gt;
&lt;p&gt;MTBF=MTTR+MTTF，两故障之间的时间间隔&lt;/p&gt;
&lt;p&gt;恢复一块硬盘的代价很高，为了提高系统可用性，需要构建多盘系统，在某块磁盘故障时仍然能正常工作。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;每秒的I/O请求峰值为1200，R/W比例为2:1，分别使用RAID 1/5，计算峰值的硬盘负载&lt;/p&gt;
&lt;p&gt;总的R/W分别为800/400&lt;/p&gt;
&lt;p&gt;RAID 1：写操作需要翻倍，总负载为&lt;code&gt;800+400*2=1600&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;RAID 5：写操作翻四倍，总负载为&lt;code&gt;800+400*4=2400&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;使用多盘系统的目的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提高存储容量&lt;/li&gt;
&lt;li&gt;提高性能
&lt;ul&gt;
&lt;li&gt;负载均衡
&lt;ul&gt;
&lt;li&gt;Disk Striping&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;带宽&lt;/li&gt;
&lt;li&gt;吞吐量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;提高可靠性
&lt;ul&gt;
&lt;li&gt;容错
&lt;ul&gt;
&lt;li&gt;基于奇偶校验的保护&lt;/li&gt;
&lt;li&gt;创建副本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;JBOD（Just a Bunch Of Disks）单纯对硬盘进行组合，只提高存储容量&lt;/p&gt;
&lt;h2 id=&#34;负载均衡&#34;&gt;负载均衡&lt;/h2&gt;
&lt;p&gt;静态：某一地址固定映射到某块硬盘&lt;/p&gt;
&lt;p&gt;动态：热点数据分配到不同的硬盘中&lt;/p&gt;
&lt;p&gt;按照数据块：将一个数据划分后存储到所有硬盘中（Disk Striping 条带化）&lt;/p&gt;
&lt;h3 id=&#34;disk-striping&#34;&gt;Disk Striping&lt;/h3&gt;
&lt;p&gt;按一定大小对数据分块（stripe unit/block），然后依次存储到各个硬盘中&lt;/p&gt;
&lt;p&gt;分配规则使用轮询枚举，通过取模判断存储的磁盘编号，根据余数确定偏移量&lt;/p&gt;
&lt;p&gt;Stripe Unit大小设置一般为&lt;code&gt;2M、4M、16M&lt;/code&gt;，太大丧失负载均衡能力，太小会在寻址上花费太多时间&lt;/p&gt;
&lt;h2 id=&#34;磁盘失效&#34;&gt;磁盘失效&lt;/h2&gt;
&lt;p&gt;对于JBOD、Striping某块盘失效，整个文件系统都将失效&lt;/p&gt;
&lt;p&gt;可以通过备份来解决，要花费较长的时间&lt;/p&gt;
&lt;p&gt;多盘系统的MTTF为第一块磁盘失效的时间，比单盘系统时间短很多&lt;/p&gt;
&lt;p&gt;解决方案：Redundancy冗余存储&lt;/p&gt;
&lt;h3 id=&#34;redundancy&#34;&gt;Redundancy&lt;/h3&gt;
&lt;h4 id=&#34;存储副本&#34;&gt;存储副本&lt;/h4&gt;
&lt;p&gt;存储两份或更多的副本，采用三副本的服务有HDFS/GFS/Cloud Storage&lt;/p&gt;
&lt;h5 id=&#34;disk-mirroring&#34;&gt;Disk Mirroring&lt;/h5&gt;
&lt;p&gt;磁盘镜像，分主从磁盘，从盘基于主盘进行同步，可以从任意盘进行读取&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;有较高的可用性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;花费较高&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写性能降低，磁盘之间需要同步，受限于最慢同步的磁盘&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;读性能提高，请求被分散到各个磁盘&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;磁盘镜像可以与结合条带化&lt;/p&gt;
&lt;p&gt;先做Mirroring再做Striping (RAID 10)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.ipandai.club/image-20221005210811763.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221005210811763&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;若有磁盘故障，会损失1/2的数据&lt;/p&gt;
&lt;p&gt;先做Striping再做Mirroring (RAID 01)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.ipandai.club/image-20221005211127116.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221005211127116&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;若有磁盘故障，不会影响整体的读写，可以保证可靠性&lt;/p&gt;
&lt;h5 id=&#34;shadowing&#34;&gt;Shadowing&lt;/h5&gt;
&lt;p&gt;不对外服务，只充当备份&lt;/p&gt;
&lt;h5 id=&#34;duplexing&#34;&gt;Duplexing&lt;/h5&gt;
&lt;p&gt;可进行交换&lt;/p&gt;
&lt;h4 id=&#34;eccerror-correcting-codes&#34;&gt;ECC(Error-Correcting Codes)&lt;/h4&gt;
&lt;p&gt;纠错码常用方案有RAID，纠删码，奇偶校验&lt;/p&gt;
&lt;h5 id=&#34;parity-disk&#34;&gt;Parity Disk&lt;/h5&gt;
&lt;p&gt;增加一块检验盘，保存其他盘上数据的异或值&lt;/p&gt;
&lt;p&gt;奇偶校验：统计数据中1的个数，奇数为1，偶数为0&lt;/p&gt;
&lt;p&gt;43:25&lt;/p&gt;
&lt;h1 id=&#34;0x01-raid&#34;&gt;0x01 RAID&lt;/h1&gt;
&lt;p&gt;通过廉价磁盘构建&lt;strong&gt;可靠&lt;/strong&gt;大型高端存储，类似MapReduce通过廉价服务器来构建高性能计算集群&lt;/p&gt;
&lt;p&gt;RAID 0 条带化，无冗余存储&lt;/p&gt;
&lt;p&gt;RAID 1 Mirroring&lt;/p&gt;
&lt;p&gt;RAID 2 条带化+海明码冗余存储&lt;/p&gt;
&lt;p&gt;RAID 3 条带化+奇偶校验 细粒度&lt;/p&gt;
&lt;p&gt;RAID 4 块条带化+奇偶校验 粒度大&lt;/p&gt;
&lt;p&gt;RAID 5 块条带化+条带化的奇偶校验&lt;/p&gt;
&lt;p&gt;RAID 6 块条带化+两个条带化的奇偶校验&lt;/p&gt;
&lt;p&gt;RAID 0无容错，RAID 1-5支持一个单位的容错，RAID 6支持两个单位容错&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【存储技术基础】主存</title>
        <link>https://blog.ipandai.club/p/%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E4%B8%BB%E5%AD%98/</link>
        <pubDate>Sat, 24 Sep 2022 18:26:22 +0800</pubDate>
        
        <guid>https://blog.ipandai.club/p/%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E4%B8%BB%E5%AD%98/</guid>
        <description>&lt;h1 id=&#34;0x00-主存&#34;&gt;0x00 主存&lt;/h1&gt;
&lt;p&gt;当前面临的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;容量问题、带宽问题、QoS保证&lt;/p&gt;
&lt;p&gt;多核处理器、数据密集应用、云计算、GPU&lt;/p&gt;
&lt;p&gt;HDFS（GFS）基于外存储器&lt;/p&gt;
&lt;p&gt;Spark 内存中数据处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;能耗功率问题&lt;/p&gt;
&lt;p&gt;40%功耗在DRAM，Refresh操作耗能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DRAM发展遇到瓶颈&lt;/p&gt;
&lt;p&gt;制成方式限制&lt;/p&gt;
&lt;p&gt;改进：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;3D-Stack DRAM 提供更高的带宽&lt;/li&gt;
&lt;li&gt;低延迟DRAM&lt;/li&gt;
&lt;li&gt;低功耗DRAM&lt;/li&gt;
&lt;li&gt;NVM（e.g. PCM）容量更大，延迟较高&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;0x01-dram的组成&#34;&gt;0x01 DRAM的组成&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Channel&lt;/li&gt;
&lt;li&gt;DIMM 内存条&lt;/li&gt;
&lt;li&gt;Rank 二维阵列最小单元&lt;/li&gt;
&lt;li&gt;Chip 芯片&lt;/li&gt;
&lt;li&gt;Bank&lt;/li&gt;
&lt;li&gt;Row/Column&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;行为字线 word line&lt;/p&gt;
&lt;p&gt;列为位线，交点是cell 内存单元&lt;/p&gt;
&lt;img src=&#34;https://cdn.ipandai.club/image-20221003154123646.png&#34; alt=&#34;image-20221003154123646&#34; style=&#34;zoom:70%;&#34; /&gt;
&lt;p&gt;DRAM row是一个DRAM page&lt;/p&gt;
&lt;p&gt;Sense Amplifiers 也被叫做Row buffer&lt;/p&gt;
&lt;p&gt;每个地址通过&lt;code&gt;&amp;lt;row,colum&amp;gt;&lt;/code&gt;编址&lt;/p&gt;
&lt;p&gt;访问一个&lt;code&gt;closed row&lt;/code&gt;的过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Activate：将row放到row buffer中&lt;/li&gt;
&lt;li&gt;Read/Write：读写row buffer中的column&lt;/li&gt;
&lt;li&gt;Precharge：从row buffer中的数据写回到选中的row中&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;bank-operation&#34;&gt;Bank Operation&lt;/h2&gt;
&lt;p&gt;给定Row Address通过Row decoder选中一行&lt;/p&gt;
&lt;p&gt;将行加载到Row Buffer&lt;/p&gt;
&lt;p&gt;若读取的Row在Row Buffer中，则为命中Hit状态，通过Column Mutex直接获取数据&lt;/p&gt;
&lt;p&gt;若读取的Row不在Row Buffer中，则为冲突Conflict状态，将Row Buffer回写，然后再选中新的Row，读取数据&lt;/p&gt;
&lt;h2 id=&#34;chip&#34;&gt;Chip&lt;/h2&gt;
&lt;p&gt;由多个(2-16个)Bank组成，Bank共享总线（指令/地址/数据总线）&lt;/p&gt;
&lt;p&gt;每次只能读4或16 Bit&lt;/p&gt;
&lt;h2 id=&#34;rank-and-module&#34;&gt;Rank and Module&lt;/h2&gt;
&lt;p&gt;Module为DIMM内存条，连接在主板上，由一个或多个rank组成&lt;/p&gt;
&lt;p&gt;Rank由多个Chip构成，提高接口带宽，多个Chip共享地址和指令总线，有单独的数据总线&lt;/p&gt;
&lt;img src=&#34;https://cdn.ipandai.club/image-20221003164422987.png&#34; alt=&#34;image-20221003164422987&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;p&gt;多个Chip可以并行操作&lt;/p&gt;
&lt;p&gt;对于64 bit的读取，分配到多个Chip中同时读取&lt;/p&gt;
&lt;p&gt;对于多DIMM情况，可以先确定在哪根DIMM条中，再进行读取操作&lt;/p&gt;
&lt;h2 id=&#34;chanel&#34;&gt;Chanel&lt;/h2&gt;
&lt;p&gt;Bank之间为分时共享&lt;/p&gt;
&lt;p&gt;Channel为独立总线，数据可同时读写，每个Channel有一个Memory Controller&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.ipandai.club/image-20221003182243697.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221003182243697&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;在同一个Channel中的DIMM数据分时共享&lt;/p&gt;
&lt;p&gt;一张比较清晰的结构关系图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.ipandai.club/image-20221003182445252.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221003182445252&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;同一个Channel可以连接多个DIMM条&lt;/p&gt;
&lt;h2 id=&#34;从cpu访问角度观察&#34;&gt;从CPU访问角度观察&lt;/h2&gt;
&lt;p&gt;Memory Channel中，在DIMM中Chip Selection选择访问的Rank，通过地址确定访问的数据&lt;/p&gt;
&lt;p&gt;Rank中的8个Chip每个都提供8 bit，共提供8 Byte访问&lt;/p&gt;
&lt;p&gt;由每个Chip中的bank选择器从8个bank中选择一个获取8 bit&lt;/p&gt;
&lt;p&gt;Bank中通过Row-Buffer来获取数据&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;延迟的产生：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU到controller的传输时间&lt;/li&gt;
&lt;li&gt;Controller延迟，请求队列和调度&lt;/li&gt;
&lt;li&gt;Controller到DRAM的传输时间（总线）&lt;/li&gt;
&lt;li&gt;DRAM 中Bank的延迟
&lt;ul&gt;
&lt;li&gt;选择某一行 Activate&lt;/li&gt;
&lt;li&gt;读取的时间&lt;/li&gt;
&lt;li&gt;Precharge&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DRAM到CPU的传输时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主要关注Bank中的延迟&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;multiple-banks&#34;&gt;Multiple Banks&lt;/h2&gt;
&lt;p&gt;使DRAM访问并行&lt;/p&gt;
&lt;p&gt;由于不同Bank分时共享，可以使得Bank提前将row加载到Row Buffer中，提高利用率&lt;/p&gt;
&lt;h2 id=&#34;multiple-channels&#34;&gt;Multiple Channels&lt;/h2&gt;
&lt;p&gt;更容易实现&lt;/p&gt;
&lt;p&gt;提高总线带宽&lt;/p&gt;
&lt;p&gt;提高并发能力需要减少Bank和Channel的冲突问题，需要对编址策略进行优化&lt;/p&gt;
&lt;p&gt;比较直观的观察Multiple Banks优化的效果，达到Overlap的效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.ipandai.club/image-20221003204558855.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221003204558855&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;address-mapping&#34;&gt;Address Mapping&lt;/h2&gt;
&lt;p&gt;地址映射对DRAM并发能力的影响&lt;/p&gt;
&lt;p&gt;将访问DRAM中数据的地址进行排列，包含Channel、Row、Bank、Column&lt;/p&gt;
&lt;p&gt;核心思想：调整容易产生冲突的地址，使其相对靠后，还要兼顾其他问题&lt;/p&gt;
&lt;p&gt;将Column的高8位和低3位分离&lt;/p&gt;
&lt;img src=&#34;https://cdn.ipandai.club/image-20221004202109741.png&#34; alt=&#34;image-20221004202109741&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;p&gt;提高Row Buffer的利用率，倒数第二种比较常用&lt;/p&gt;
&lt;p&gt;对OS而言，由逻辑地址Virtual Address映射到物理地址&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Virtual Page Number &lt;/code&gt;-&amp;gt; &lt;code&gt;&amp;lt;Row,Bank&amp;gt;&lt;/code&gt;，可以通过调整映射算法来优化存储效率&lt;/p&gt;
&lt;h1 id=&#34;0x02-dram-refresh&#34;&gt;0x02 DRAM Refresh&lt;/h1&gt;
&lt;p&gt;由于电容中的电子持续泄漏，每隔一段时间重新写入数据，读取到row buffer再写回，刷新间隔一般为64ms&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;负面影响：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;能耗增加&lt;/li&gt;
&lt;li&gt;性能减少，Refresh中内存不可用&lt;/li&gt;
&lt;li&gt;QoS影响，不能保证平稳&lt;/li&gt;
&lt;li&gt;刷新率使得DRAM容量的扩展受限&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;性能影响&#34;&gt;性能影响&lt;/h2&gt;
&lt;p&gt;刷新时Bank变得不可用，Row Buffer的占用&lt;/p&gt;
&lt;p&gt;在刷新结束前有长时间的暂定，有两种优化策略：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Burst Refresh 所有的行依次全部刷新&lt;/li&gt;
&lt;li&gt;Distributed Refresh 每行以固定的时间间隔在不同的时间进行刷新&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;两种方式（集中式/分布式）的示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.ipandai.club/image-20221004153056950.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221004153056950&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;Distributed Refresh减少了等待时间&lt;/p&gt;
&lt;p&gt;随着设备容量的增加，消耗在Refresh上的时间/能耗占比越来越大&lt;/p&gt;
&lt;p&gt;目前应用的策略：Auto Refresh，每次只Refresh其中几行&lt;/p&gt;
&lt;p&gt;一些探索：刷新间隔的调整，64ms保证在最坏情况下的可靠性，在容忍存储单元出故障的前提下，可以适当提高刷新间隔，对于出错的单元采用更低的刷新间隔（不同存储单元采用不同刷新频率）&lt;/p&gt;
&lt;h1 id=&#34;0x03-memory-controller&#34;&gt;0x03 Memory Controller&lt;/h1&gt;
&lt;p&gt;位于CPU中&lt;/p&gt;
&lt;p&gt;基本功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保证DRAM的正确性，刷新和时序timing&lt;/li&gt;
&lt;li&gt;遵循一定的时序约束（bank，总线，channel的冲突）来完成DRAM请求，转换请求为DRAM Command&lt;/li&gt;
&lt;li&gt;对请求进行调度提高性能&lt;/li&gt;
&lt;li&gt;管理电源能耗，开关Chip，管理电源模式&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://cdn.ipandai.club/image-20221004204322362.png&#34; alt=&#34;image-20221004204322362&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;由L2 Cache发送请求到Memory Controller，由一个Buffer来对请求进行缓存&lt;/p&gt;
&lt;h2 id=&#34;请求调度策略&#34;&gt;请求调度策略&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;FCFS&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FR-FCFS,First Ready&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Row-Hit First，优先调度命中Row Buffer的请求，提高命中率&lt;/li&gt;
&lt;li&gt;FCFS 防止饥饿&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;row-buffer管理策略&#34;&gt;Row Buffer管理策略&lt;/h2&gt;
&lt;p&gt;Open Row 不预先执行Precharge回写&lt;/p&gt;
&lt;p&gt;Closed Row 预先回写&lt;/p&gt;
&lt;p&gt;自适应结合两种方案&lt;/p&gt;
&lt;h2 id=&#34;dram-controller的设计难点&#34;&gt;DRAM Controller的设计难点&lt;/h2&gt;
&lt;p&gt;时序约束&lt;/p&gt;
&lt;img src=&#34;https://cdn.ipandai.club/image-20221005142053482.png&#34; alt=&#34;image-20221005142053482&#34; style=&#34;zoom:67%;&#34; /&gt;
&lt;p&gt;防止冲突的发生&lt;/p&gt;
&lt;p&gt;Refresh操作&lt;/p&gt;
&lt;h2 id=&#34;能耗管理&#34;&gt;能耗管理&lt;/h2&gt;
&lt;p&gt;在不访问chip时切断供电&lt;/p&gt;
&lt;p&gt;厂商提供多种不同功耗的工作状态&lt;/p&gt;
&lt;p&gt;状态过渡时Chip无法被访问，因此会产生延迟&lt;/p&gt;
&lt;h1 id=&#34;0x04-nvm&#34;&gt;0x04 NVM&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;读&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;写&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;特点&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;e.g.&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Charge Memory电荷存储器&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;通过检测电压V读取数据&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;通过捕获电荷Q写入数据&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;通过写放大器来读写，体积不能太小&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;DRAM, Flash&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Resistive Memory电阻式存储器&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;通过检测电阻R&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;通过脉冲电流$\frac{dQ}{dt}$写入数据&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;写数据调整阻抗&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;PCM, STT-MRAM，memristors&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;pcm&#34;&gt;PCM&lt;/h2&gt;
&lt;p&gt;通电加热会改变状态结晶态/非晶态，阻抗发生变化，表示0/1&lt;/p&gt;
&lt;h3 id=&#34;写&#34;&gt;写&lt;/h3&gt;
&lt;p&gt;两个状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SET：保持低电压，将介质变为结晶态&lt;/li&gt;
&lt;li&gt;RESET：提高温度变为非晶态&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;读&#34;&gt;读&lt;/h3&gt;
&lt;p&gt;检测结晶态($10^3-10^4\Omega$)/非晶态($10^6-10^7\Omega$)的阻抗，两者数量级差距较大&lt;/p&gt;
&lt;h2 id=&#34;优势&#34;&gt;优势&lt;/h2&gt;
&lt;p&gt;比DRAM，Flash有更高的扩展能力，存储密度&lt;/p&gt;
&lt;p&gt;每个单元的存储密度提高&lt;/p&gt;
&lt;p&gt;Non-Volatile，不通电情况下可以保存10年以上（85摄氏度）&lt;/p&gt;
&lt;p&gt;不需要Refresh操作，低功耗&lt;/p&gt;
&lt;h3 id=&#34;mlc-pcm&#34;&gt;MLC-PCM&lt;/h3&gt;
&lt;p&gt;根据电阻划分多个bit，控制距离间隔&lt;/p&gt;
&lt;p&gt;延迟相较于DRAM高&lt;/p&gt;
&lt;p&gt;动态能耗高于DRAM&lt;/p&gt;
&lt;p&gt;写寿命较低&lt;/p&gt;
&lt;h2 id=&#34;stt-mram&#34;&gt;STT-MRAM&lt;/h2&gt;
&lt;p&gt;自旋距磁存储器&lt;/p&gt;
&lt;p&gt;电流改变磁介质方向，改变阻抗&lt;/p&gt;
&lt;p&gt;Reference Layer和Free Layer方向相同表示0，相反时表示1&lt;/p&gt;
&lt;h3 id=&#34;优势-1&#34;&gt;优势&lt;/h3&gt;
&lt;p&gt;容量大，造价低&lt;/p&gt;
&lt;p&gt;非易失&lt;/p&gt;
&lt;p&gt;功耗低&lt;/p&gt;
&lt;p&gt;缺点类似于PCM&lt;/p&gt;
&lt;h2 id=&#34;memristorsrramreram&#34;&gt;Memristors/RRAM/ReRAM&lt;/h2&gt;
&lt;p&gt;改变原子结构&lt;/p&gt;
&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1xE411T7Dy&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;存储技术基础—Main Memory I&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1xE411T7Dy&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;存储技术基础—Main Memory II&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【存储技术基础】固态硬盘</title>
        <link>https://blog.ipandai.club/p/%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98/</link>
        <pubDate>Thu, 22 Sep 2022 09:36:42 +0800</pubDate>
        
        <guid>https://blog.ipandai.club/p/%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98/</guid>
        <description>&lt;p&gt;主要由Flash Memory 和FTL组成&lt;/p&gt;
&lt;p&gt;Non-Volatile Memory 提供低延迟持久性的内存/存储，也可以用来做内存&lt;/p&gt;
&lt;p&gt;根据延迟数量级，一般用PCM做内存，Flash Memory做外存&lt;/p&gt;
&lt;h1 id=&#34;0x00-flash-memory&#34;&gt;0x00 Flash Memory&lt;/h1&gt;
&lt;h2 id=&#34;闪存原理&#34;&gt;闪存原理&lt;/h2&gt;
&lt;h3 id=&#34;类型&#34;&gt;类型&lt;/h3&gt;
&lt;p&gt;NOR闪存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存储密度低&lt;/li&gt;
&lt;li&gt;可字节改写&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NAND闪存（主流）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存储密度高&lt;/li&gt;
&lt;li&gt;不可覆盖写&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用于外存需要较高的存储量级，一般用NAND&lt;/p&gt;
&lt;h3 id=&#34;闪存单元&#34;&gt;闪存单元&lt;/h3&gt;
&lt;p&gt;读：电压代表不同数值&lt;/p&gt;
&lt;p&gt;写：电子注入&lt;/p&gt;
&lt;p&gt;相比晶体管添加了浮栅门，保存电子&lt;/p&gt;
&lt;p&gt;原理其实比较简单，非电子系就不做太详细的研究了&lt;/p&gt;
&lt;p&gt;闪存页(4KB,8KB,16KB，读写单元)，阵列中的每一行&lt;/p&gt;
&lt;p&gt;闪存块(擦除单元)，由多个页组成的单元&lt;/p&gt;
&lt;img src=&#34;https://cdn.ipandai.club/image-20220922124359358.png&#34; alt=&#34;image-20220922124359358&#34; style=&#34;zoom:33%;&#34; /&gt;
&lt;p&gt;选中行和列，然后将数据加载到Sense Amplifiers&lt;/p&gt;
&lt;p&gt;存储单元有两个阈值的电压，可以根据两个电压的中点作为读电压，2.5V读电压时左边通电，数据为1，右边则不通电，数据为0&lt;/p&gt;
&lt;img src=&#34;https://cdn.ipandai.club/image-20220922124755447.png&#34; alt=&#34;image-20220922124755447&#34; style=&#34;zoom:25%;&#34; /&gt;
&lt;p&gt;Pass Through&lt;/p&gt;
&lt;p&gt;选取一个较大的电压，使得所有的单元都接通，数据为1，不影响其他行的状态&lt;/p&gt;
&lt;img src=&#34;https://cdn.ipandai.club/image-20220922131649578.png&#34; alt=&#34;image-20220922131649578&#34; style=&#34;zoom:25%;&#34; /&gt;
&lt;p&gt;如图所示的存储结构，在第二行施加2.5V电压，其他行施加5V，最终读取数据为0011&lt;/p&gt;
&lt;img src=&#34;https://cdn.ipandai.club/image-20220922134857889.png&#34; alt=&#34;image-20220922134857889&#34; style=&#34;zoom:33%;&#34;/&gt;
&lt;p&gt;上述为SLC，Single Level Cell，单存储单元&lt;/p&gt;
&lt;h3 id=&#34;多比特闪存&#34;&gt;多比特闪存&lt;/h3&gt;
&lt;p&gt;多比特闪存单元MLC，包含2Bits 4个Level的数据&lt;/p&gt;
&lt;p&gt;TLC 3 Bits 8个Level&lt;/p&gt;
&lt;p&gt;QLC 4 Bits 16个Level&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多比特使用格雷码来编码&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用格雷码使得相邻单元只有一位差异，方便纠错&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;多比特提高了存储密度，但是提高了错误率，因为施加的电压差距很小。可靠性会降低。&lt;/p&gt;
&lt;img src=&#34;https://cdn.ipandai.club/image-20220922135516463.png&#34; alt=&#34;image-20220922135516463&#34; style=&#34;zoom:45%;&#34; /&gt;
&lt;p&gt;对于多比特的写，MLC分为高比特和低比特，对于低比特的状态加偏移电压确定高比特，在低比特时需要加的电压较大，操作难度低，运行速度快，在高比特时需要加的电压小，波形的间距小，操作难度高，运行的速度较慢。&lt;/p&gt;
&lt;img src=&#34;https://cdn.ipandai.club/image-20220922140421405.png&#34; alt=&#34;image-20220922140421405&#34; style=&#34;zoom:40%;&#34; /&gt;
&lt;p&gt;对于多比特的读，先看lower bit，加一次电压，即可筛选出低位的0，1，再加两次电压确定upper bit。因为upper bit为0的在中间部分，为1的在两侧，因此需要在两个分界线分别加一次电压来确定upper bit为多少。&lt;/p&gt;
&lt;img src=&#34;https://cdn.ipandai.club/image-20220922141455826.png&#34; alt=&#34;image-20220922141455826&#34; style=&#34;zoom:40%;&#34; /&gt;
&lt;h3 id=&#34;闪存&#34;&gt;闪存&lt;/h3&gt;
&lt;p&gt;Block的大小的一种配置：&lt;/p&gt;
&lt;p&gt;一行有两个Page，Upper Page和Lower Page，每个单元中，低位构成Lower Page，高位构成Upper Page，有128个单元，128K/8=16KB&lt;/p&gt;
&lt;p&gt;有64列bitlines，一个block的大小即为&lt;code&gt;16KB*64*2=2MB&lt;/code&gt;，一般按照此比例配置Block&lt;/p&gt;
&lt;p&gt;写入时按照固定顺序，写入高低页面相互独立，不能同时写，在写入加压时容易使相邻单元发生数据偏移，要降低错误率&lt;/p&gt;
&lt;p&gt;写入是需要先擦除再写入，擦除整个块&lt;/p&gt;
&lt;img src=&#34;https://cdn.ipandai.club/image-20220922143608667.png&#34; alt=&#34;image-20220922143608667&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;h4 id=&#34;特性&#34;&gt;特性&lt;/h4&gt;
&lt;h5 id=&#34;读写粒度&#34;&gt;读写粒度&lt;/h5&gt;
&lt;p&gt;闪存页读写粒度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;4KB，8KB，16KB必须全部读取或者写入&lt;/li&gt;
&lt;li&gt;us延迟&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;闪存块擦除力度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2MB擦除&lt;/li&gt;
&lt;li&gt;ms延迟，可以通过FTL来优化&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;不可覆盖写&#34;&gt;不可覆盖写&lt;/h5&gt;
&lt;p&gt;写前需要擦除，读写粒度与擦除粒度不同&lt;/p&gt;
&lt;p&gt;存在64bytes的OOB（out of bound area），保存ECC，用于纠错，容忍写入时部分比特出错&lt;/p&gt;
&lt;img src=&#34;https://cdn.ipandai.club/image-20220922162139217.png&#34; alt=&#34;image-20220922162139217&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;h5 id=&#34;有限次擦除&#34;&gt;有限次擦除&lt;/h5&gt;
&lt;p&gt;随着擦除次数的增加，存储单元不能可靠的保持状态（存储数据）。&lt;/p&gt;
&lt;p&gt;氧化层老化变薄，束缚电子能力变弱&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;耐久性 变薄地次数&lt;/li&gt;
&lt;li&gt;保持力 不通电可以放置的时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SLC：10w次&lt;/p&gt;
&lt;p&gt;MLC：1w次&lt;/p&gt;
&lt;p&gt;TLC：1k次&lt;/p&gt;
&lt;p&gt;根据特性设计FTL固件来&lt;/p&gt;
&lt;img src=&#34;https://cdn.ipandai.club/image-20220922164523965.png&#34; alt=&#34;image-20220922164523965&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;h1 id=&#34;0x01-ftl&#34;&gt;0x01 FTL&lt;/h1&gt;
&lt;p&gt;固态硬盘整体构成&lt;/p&gt;
&lt;img src=&#34;https://cdn.ipandai.club/image-20220922164728094.png&#34; alt=&#34;image-20220922164728094&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;SSD中的通道可以并行，通道中也可以并行读取，每个Plane中有寄存器，暂时存储准备好的数据。不同单元并行，因此内部带宽大&lt;/p&gt;
&lt;img src=&#34;https://cdn.ipandai.club/image-20220922165354311.png&#34; alt=&#34;image-20220922165354311&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;h2 id=&#34;垃圾回收&#34;&gt;垃圾回收&lt;/h2&gt;
&lt;p&gt;page对于OS而言，是写入时的block&lt;/p&gt;
&lt;p&gt;Page三种状态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空闲 free page&lt;/li&gt;
&lt;li&gt;有效页 live/valid page&lt;/li&gt;
&lt;li&gt;无效页 dead/invalid page&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&#34;https://cdn.ipandai.club/image-20220922184349456.png&#34; alt=&#34;image-20220922184349456&#34; style=&#34;zoom:25%;&#34; /&gt;
&lt;p&gt;需要擦除无效页，先移走有效页，然后再对一整行进行擦除，转为空闲&lt;/p&gt;
&lt;img src=&#34;https://cdn.ipandai.club/image-20220922184406162.png&#34; alt=&#34;image-20220922184406162&#34; style=&#34;zoom:25%;&#34; /&gt;
&lt;p&gt;时间开销：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;复制有效数据到$(R_{Latency}+W_{Latency})*N$，N是移动page的数量&lt;/li&gt;
&lt;li&gt;擦除产生的开销 ms级延迟&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;gc策略&#34;&gt;GC策略&lt;/h3&gt;
&lt;p&gt;要解决的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;何时启动GC&lt;/li&gt;
&lt;li&gt;选中那些/多少Block进行GC&lt;/li&gt;
&lt;li&gt;有效的页如何被转写&lt;/li&gt;
&lt;li&gt;新数据写到哪里&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;GC的时间开销：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;块擦除的时间 ms&lt;/li&gt;
&lt;li&gt;有效页的复制时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;贪心策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找到脏页最多的block来进行擦除&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;优化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Age&lt;/li&gt;
&lt;li&gt;Hot/Cold 数据隔离，分组问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;磨损均衡&#34;&gt;磨损均衡&lt;/h2&gt;
&lt;p&gt;优化寿命，有静态和动态策略&lt;/p&gt;
&lt;p&gt;静态：周期性的调整冷热数据存储的位置&lt;/p&gt;
&lt;p&gt;冷热数据的分区：将冷数据放在一起，热数据放在一起&lt;/p&gt;
&lt;h2 id=&#34;ftl简介&#34;&gt;FTL简介&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;维护映射，虚拟地址到物理地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用SRAM存储映射&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;向上层隐藏擦除操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;避免原地更新-&amp;gt;异地更新&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新一个新页面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高性能的垃圾回收和擦除&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OOB有物理地址到虚拟地址的映射，用于掉电恢复，这里引用一段&lt;a class=&#34;link&#34; href=&#34;https://pages.cs.wisc.edu/~remzi/OSTEP/file-ssd.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;wisc的OSTEP中的一段解释（44 Flash- based SSD）&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;OOB保存的在每个页中映射信息，当掉电或者重启时用它在内存中重建映射&lt;/p&gt;
&lt;p&gt;为了防止在重建时扫码整个SSD，可以使用日志或者检查点的方式来加速这个过程&lt;/p&gt;
&lt;p&gt;大致看了一下OSTEP，记得是jyy老师推荐的教材，希望以后有时间读一下&lt;/p&gt;
&lt;img src=&#34;https://cdn.ipandai.club/image-20220924141132556.png&#34; alt=&#34;image-20220924141132556&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;h3 id=&#34;page-level-ftl&#34;&gt;Page-Level FTL&lt;/h3&gt;
&lt;p&gt;原理类似OS中的页表，由Logical Page Number查询页表得到Physical Page Number&lt;/p&gt;
&lt;p&gt;缺点是页表占用很大的空间&lt;/p&gt;
&lt;img src=&#34;https://cdn.ipandai.club/image-20220924152322358.png&#34; alt=&#34;image-20220924152322358&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;h3 id=&#34;block-level-ftl&#34;&gt;Block-Level FTL&lt;/h3&gt;
&lt;p&gt;保持Block 到Block的映射&lt;/p&gt;
&lt;p&gt;先查找到对应的Block，在根据offset得到page，块内的页码偏移offset是固定的&lt;/p&gt;
&lt;img src=&#34;https://cdn.ipandai.club/image-20220924152259043.png&#34; alt=&#34;image-20220924152259043&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;优点是占用空间很小，缺点是GC负载增加&lt;/p&gt;
&lt;p&gt;原因：offset在不同Block中保持不变，在异地更新时，要选择其他block中相同的offset进行写入，如果选中的block已经存在数据，需要把数据迁移。【TODO 这里讲得不是非常的清楚】&lt;/p&gt;
&lt;h3 id=&#34;hybrid-ftl&#34;&gt;Hybrid FTL&lt;/h3&gt;
&lt;p&gt;对写入分为新/旧数据，新写入的数据用Page-Level Mapping效率高，写入Log Blocks作为缓冲，之后再更新到Data Blocks&lt;/p&gt;
&lt;p&gt;旧数据因为写入后更新相对不频繁，使用Block-Level Mapping，写入Data Blocks&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【存储技术基础】磁盘技术</title>
        <link>https://blog.ipandai.club/p/%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%A3%81%E7%9B%98%E6%8A%80%E6%9C%AF/</link>
        <pubDate>Tue, 20 Sep 2022 16:13:29 +0800</pubDate>
        
        <guid>https://blog.ipandai.club/p/%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%A3%81%E7%9B%98%E6%8A%80%E6%9C%AF/</guid>
        <description>&lt;p&gt;本讲内容HDD好弟弟：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;磁盘的构成和各个部分的功能&lt;/li&gt;
&lt;li&gt;磁盘的性能和评估方式&lt;/li&gt;
&lt;li&gt;磁盘固件的功能，固件算法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;推荐阅读：&lt;a class=&#34;link&#34; href=&#34;https://github.com/KevinOfNeu/ebooks/blob/master/Memory%20systems%20Cache%20DRAM%20Disk.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Memory System: Cache,DRAM,Disk.Author: Bruce Jacob, Spencer W. Ng, David T.Wang&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;0x00-组成&#34;&gt;0x00 组成&lt;/h1&gt;
&lt;p&gt;转轴，盘片，磁头&lt;/p&gt;
&lt;p&gt;track 磁道，每个盘片的正面和背面的同心圆&lt;/p&gt;
&lt;p&gt;对于盘片每个面是surface，每个track磁道分为多个sector（扇区）&lt;/p&gt;
&lt;p&gt;所有盘片上同一个位置的track是一个cylinder（柱面）&lt;/p&gt;
&lt;h2 id=&#34;寻址&#34;&gt;寻址&lt;/h2&gt;
&lt;p&gt;物理编址：CHS，Cylinder-Head-Sector 定位一个块的位置&lt;/p&gt;
&lt;p&gt;根据柱面-磁头-扇区来访问&lt;/p&gt;
&lt;p&gt;右边图示表示逻辑块地址，每个柱面可以从上到下顺序编址，组成线性结构&lt;/p&gt;
&lt;img src=&#34;https://cdn.ipandai.club/IMG_0448.jpg&#34; alt=&#34;IMG_0448&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;h1 id=&#34;0x01-性能评估&#34;&gt;0x01 性能评估&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;电子设备
&lt;ul&gt;
&lt;li&gt;电路驱动&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;机械设备
&lt;ul&gt;
&lt;li&gt;seek time 磁头运动速度&lt;/li&gt;
&lt;li&gt;rotational latency 转轴旋转速度&lt;/li&gt;
&lt;li&gt;data transfer rate 数据传输速率&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$磁盘访问时间=磁头运动速度+转轴旋转速度+数据传输速度$&lt;/p&gt;
&lt;h2 id=&#34;seek-time&#34;&gt;Seek time&lt;/h2&gt;
&lt;p&gt;inner和outter track中进行移动，到达对应的track所消耗的时间&lt;/p&gt;
&lt;p&gt;评价方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Full stroke 里圈到外圈&lt;/li&gt;
&lt;li&gt;Average 移动到中间所花费的时间&lt;/li&gt;
&lt;li&gt;Track-to-track 两个磁道间的移动时间&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;rotational-latency&#34;&gt;Rotational Latency&lt;/h2&gt;
&lt;p&gt;平均旋转速度：转半圈的时间&lt;/p&gt;
&lt;p&gt;厂商使用转速来标称&lt;/p&gt;
&lt;p&gt;rpm: round per min
$$
{\rm Rotational\ Latency}=\frac{1}{2}*\frac{1}{\frac{x\ rpm}{60}}
$$&lt;/p&gt;
&lt;h2 id=&#34;data-transfer-time&#34;&gt;Data Transfer Time&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.ipandai.club/image-20220921135256805.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20220921135256805&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;分为内部传输和外部传输&lt;/p&gt;
&lt;p&gt;内部传输是磁介质到Buffer&lt;/p&gt;
&lt;p&gt;外部传输是从接口到主机，例如SATA接口
$$
{\rm Transfer\ time=\frac{Block\ size}{Transfer\ rate(带宽)}}
$$
还有电子控制部件延迟，一般而言可以忽略，以上都是毫秒量级&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.ipandai.club/image-20220921135704097.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20220921135704097&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;大部分时间开销在Seek Time，接近60%&lt;/p&gt;
&lt;p&gt;I/O Controller利用率越高，会导致平均的延迟升高&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.ipandai.club/image-20220921140754758.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20220921140754758&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;data-rate-inner-vs-outer-tracks&#34;&gt;Data Rate: Inner vs. Outer Tracks&lt;/h2&gt;
&lt;p&gt;磁盘在里圈和外圈的传输速率不同，外圈数据密度小，磁盘转速恒定（角速度相同），外圈的线速度大，外部磁道有更大的数据速率&lt;/p&gt;
&lt;p&gt;在操作系统视角来说，内外圈速率相同，实际外圈要快，是里圈的1.7倍&lt;/p&gt;
&lt;h1 id=&#34;0x02-磁盘固件和调度&#34;&gt;0x02 磁盘固件和调度&lt;/h1&gt;
&lt;p&gt;ASIC：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;信号处理&lt;/li&gt;
&lt;li&gt;容错&lt;/li&gt;
&lt;li&gt;驱动处理&lt;/li&gt;
&lt;li&gt;马达控制&lt;/li&gt;
&lt;li&gt;缓存控制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;firmware：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求处理&lt;/li&gt;
&lt;li&gt;请求排队和调度&lt;/li&gt;
&lt;li&gt;LBN-to-PBN 逻辑地址到物理地址的映射&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;映射逻辑地址到sector&#34;&gt;映射逻辑地址到sector&lt;/h2&gt;
&lt;p&gt;一般块大小为512bytes或4KB，块的数量为容量/块大小&lt;/p&gt;
&lt;p&gt;磁盘上的数据编址如图所示，以sector为基础，在track内连续，减少rotational latency&lt;/p&gt;
&lt;img src=&#34;https://cdn.ipandai.club/image-20220921164047132.png&#34; alt=&#34;image-20220921164047132&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;p&gt;不同盘面上的编址分为正面和背面，都会进行编址，还有以柱面为基准的编址，减少seek time。&lt;/p&gt;
&lt;p&gt;一般情况下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;盘片为1-5个，2-10个盘面&lt;/li&gt;
&lt;li&gt;每个面磁道数为10s - 100s，1000s&lt;/li&gt;
&lt;li&gt;每个磁道上的扇区有500-4000个，每个磁道大小为250KB-2MB&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;LBN寻址：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;柱面号=LBN/每个柱面的磁道数&lt;/li&gt;
&lt;li&gt;盘面号=(LBN对每个柱面的磁道数取模)/每个磁道的扇区数&lt;/li&gt;
&lt;li&gt;扇区号=LBN对每个磁道的扇区数取模&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;讲解了几种调度算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FCFS 先来先服务&lt;/li&gt;
&lt;li&gt;SSTF 最近先服务，有饥饿问题&lt;/li&gt;
&lt;li&gt;SCAN 先往一个方向走，再往另一个方向扫描&lt;/li&gt;
&lt;li&gt;C-SCAN 单向走&lt;/li&gt;
&lt;li&gt;LOOK 相较于SCAN不走0和边界&lt;/li&gt;
&lt;li&gt;C-LOOK 相较于C-SCAN不走边界&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;评估指标：平均访问延迟，一般SSTF，C-LOOK&lt;/p&gt;
&lt;h1 id=&#34;缺陷-第三讲开头部分&#34;&gt;缺陷 第三讲开头部分&lt;/h1&gt;
&lt;p&gt;机械式部件限制了性能，继续提升会产生一些物理问题&lt;/p&gt;
&lt;p&gt;带宽提升有限&lt;/p&gt;
&lt;p&gt;存在能耗问题，需要通电、散热冷却等开销&lt;/p&gt;
&lt;p&gt;随机访问的性能差&lt;/p&gt;
</description>
        </item>
        <item>
        <title>【存储技术基础】概述</title>
        <link>https://blog.ipandai.club/p/%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0/</link>
        <pubDate>Tue, 20 Sep 2022 14:41:57 +0800</pubDate>
        
        <guid>https://blog.ipandai.club/p/%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0/</guid>
        <description>&lt;h1 id=&#34;0x00-intro&#34;&gt;0x00 Intro&lt;/h1&gt;
&lt;p&gt;对于场景制定存储方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存储结构&lt;/li&gt;
&lt;li&gt;存储大小&lt;/li&gt;
&lt;li&gt;可靠性和容错&lt;/li&gt;
&lt;li&gt;文件访问类型，读/写频率&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要学习硬件的选择和文件系统设计&lt;/p&gt;
&lt;h1 id=&#34;0x01-现状&#34;&gt;0x01 现状&lt;/h1&gt;
&lt;h2 id=&#34;存储的挑战&#34;&gt;存储的挑战&lt;/h2&gt;
&lt;p&gt;数据量激增&lt;/p&gt;
&lt;h2 id=&#34;存储是什么&#34;&gt;存储是什么&lt;/h2&gt;
&lt;p&gt;分层的存储架构&lt;/p&gt;
&lt;p&gt;L0-L1-L2-DRAM-Disk&lt;/p&gt;
&lt;h2 id=&#34;存储的特性&#34;&gt;存储的特性&lt;/h2&gt;
&lt;p&gt;可靠性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多副本&lt;/li&gt;
&lt;li&gt;纠删码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一致性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原子+持久化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据保护 容灾和备份：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解决单点故障&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;0x02-存储历史与发展&#34;&gt;0x02 存储历史与发展&lt;/h1&gt;
&lt;h2 id=&#34;硬件上的发展&#34;&gt;硬件上的发展&lt;/h2&gt;
&lt;p&gt;1956&amp;ndash;HDD&lt;/p&gt;
&lt;p&gt;1984&amp;ndash;Flash Memory 早期用于嵌入式&lt;/p&gt;
&lt;p&gt;2010s&amp;ndash;Persistent Memory 3D-Point Intel&lt;/p&gt;
&lt;p&gt;SSD NAND Flash：&lt;/p&gt;
&lt;p&gt;SLC，MLC，TLC，QLC存储单元中电平的等级&lt;/p&gt;
&lt;p&gt;对比HDD和SSD：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于NAND，需要先擦出，再写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;NAND Flash有擦除，HDD只能覆盖写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SSD多个颗粒可以并行I/O，总体上速度快&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;软件上的发展&#34;&gt;软件上的发展&lt;/h2&gt;
&lt;p&gt;网络存储 远程挂载目录NAS&lt;/p&gt;
&lt;p&gt;分布式文件系统GFS，Hadoop HDFS&lt;/p&gt;
&lt;p&gt;键值存储Key-Value&lt;/p&gt;
&lt;p&gt;云存储 数据存在远端，商业化，软件协作Office&lt;/p&gt;
&lt;h1 id=&#34;assignment&#34;&gt;Assignment&lt;/h1&gt;
&lt;p&gt;有一个服务器集群（4台），针对I/O 500测试，需要考虑哪些问题？&lt;/p&gt;
</description>
        </item>
        <item>
        <title>[ATC&#39;19] Asynchronous I/O Stack: A Low-latency Kernel I/O Stack for Ultra-Low Latency SSDs</title>
        <link>https://blog.ipandai.club/p/atc19-asynchronous-i/o-stack-a-low-latency-kernel-i/o-stack-for-ultra-low-latency-ssds/</link>
        <pubDate>Wed, 17 Aug 2022 10:30:41 +0800</pubDate>
        
        <guid>https://blog.ipandai.club/p/atc19-asynchronous-i/o-stack-a-low-latency-kernel-i/o-stack-for-ultra-low-latency-ssds/</guid>
        <description>&lt;h1 id=&#34;intro&#34;&gt;Intro&lt;/h1&gt;
&lt;p&gt;优化I/O的方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户层面直接调用外部存储设备，需要应用包含文件系统的调用，臃肿，同时不同应用和用户间的冲突问题。&lt;/li&gt;
&lt;li&gt;优化操作系统内核的I/O 栈
&lt;ul&gt;
&lt;li&gt;使用轮询来减少上下文切换的开销&lt;/li&gt;
&lt;li&gt;在底层减少一半的中断处理&lt;/li&gt;
&lt;li&gt;分散I/O指令&lt;/li&gt;
&lt;li&gt;I/O block调度机制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;related-work&#34;&gt;Related Work&lt;/h1&gt;
&lt;p&gt;减少内核的开销&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少中断处理的后半部分&lt;/li&gt;
&lt;li&gt;是用轮询技术而非中断，减少上下文切换&lt;/li&gt;
&lt;li&gt;混合轮询&lt;/li&gt;
&lt;li&gt;基于SSD的闪存随机读写简化调度策略&lt;/li&gt;
&lt;li&gt;在NVMe固件中进行调度&lt;/li&gt;
&lt;li&gt;对高优先级的任务，提供不同的IO path支持，最小化IO path的开销&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;修改存储接口&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分散/分散 IO合并多个IO到一个指令，减少往返次数&lt;/li&gt;
&lt;li&gt;移除doorbell机制和完成信号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;改善fsync&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;冲fsync请求发出到收到response，延长数据持久化的时间&lt;/li&gt;
&lt;li&gt;在日志提交记录中使用校验和，有效的重叠日志写入和块写入&lt;/li&gt;
&lt;li&gt;提出&lt;code&gt;写守序系统调用&lt;/code&gt;，重叠的fsync效果相同，当应用需要使用fsync时，关于IO的操作将同步进行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用户层直接访问外设，存在隔离、保护等安全问题&lt;/p&gt;
&lt;h1 id=&#34;motivation&#34;&gt;Motivation&lt;/h1&gt;
&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;现状：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I/O 请求过程中太多的步骤&lt;/li&gt;
&lt;li&gt;页面缓存分配和索引&lt;/li&gt;
&lt;li&gt;DMA，一系列数据结构的创建&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前的 ULL SDD实现了低于10微妙的IO延迟，然而操作系统内核产生的延迟没有明显变化&lt;/p&gt;
&lt;p&gt;本文专注于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux内核中的&lt;code&gt;read()&lt;/code&gt;和&lt;code&gt;write()+fsync()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;基于NVMe SSD的Ext4文件系统&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;for-read-path&#34;&gt;For Read Path&lt;/h2&gt;
&lt;p&gt;研究发现许多剩余的操作不必在设备I/O之前或之后执行&lt;/p&gt;
&lt;p&gt;此类操作可以在设备I/O操作进行时执行&lt;/p&gt;
&lt;p&gt;因为此类操作大多独立于设备I/O操作，因此考虑让这些操作与IO重叠&lt;/p&gt;
&lt;h2 id=&#34;for-write-path&#34;&gt;For Write Path&lt;/h2&gt;
&lt;p&gt;缓冲写&lt;code&gt;write()&lt;/code&gt;，并不发起IO请求，不能异步处理&lt;/p&gt;
&lt;p&gt;由于fsync的回写机制和文件系统崩溃一致性（日志系统），包含部分IO请求&lt;/p&gt;
&lt;p&gt;由于文件系统带来的三次IO操作&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据块写&lt;/li&gt;
&lt;li&gt;jbd2发起写入日志Block I/O&lt;/li&gt;
&lt;li&gt;提交Block I/O&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些IO的创建，涉及众多过程（block分配，请求缓冲页，创建和提交bio，设置DMA地址），因此可以让CPU将这些前置操作在IO请求发起前预执行。&lt;/p&gt;
&lt;h2 id=&#34;for-lightweight-block-layer&#34;&gt;For Lightweight Block Layer&lt;/h2&gt;
&lt;p&gt;传统Block Layer涉及过多过程，推迟了IO指令提交给设备的时间&lt;/p&gt;
&lt;p&gt;因为ULL SSD的高速随机IO性能和低速的顺序IO，请求重排的效果很低&lt;/p&gt;
&lt;p&gt;简化block layer，针对异步IO stack进行优化&lt;/p&gt;
&lt;h1 id=&#34;design&#34;&gt;Design&lt;/h1&gt;
&lt;h2 id=&#34;轻量化的block-io-layer&#34;&gt;轻量化的Block I/O Layer&lt;/h2&gt;
&lt;p&gt;LBIO，为LL NVMe SSD而设计，只支持IO submission/completion和IO指令tagging&lt;/p&gt;
&lt;p&gt;只使用&lt;code&gt;lbio&lt;/code&gt;来表示一个block I/O请求，减少了&lt;code&gt;bio-to-request&lt;/code&gt;的时间&lt;/p&gt;
&lt;p&gt;每个lbio包括&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LBA&lt;/li&gt;
&lt;li&gt;I/O 长度&lt;/li&gt;
&lt;li&gt;复制的页面&lt;/li&gt;
&lt;li&gt;页面的DMA地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用全局的lbio二位数组来记录&lt;/p&gt;
&lt;p&gt;行的个数为CPU核心数，行成组被分配到一个NVMe队列&lt;/p&gt;
&lt;p&gt;例如8核心，4NVMe队列，每个队列分配2个核心的lbio
当核心数等于队列数时，可以实现无锁的命令提交&lt;/p&gt;
&lt;p&gt;lbio在全局数组中的索引用作NVMe指令的tag，减少了之前赋tag的过程&lt;/p&gt;
&lt;p&gt;lbio提交后，调用&lt;code&gt;nvme_queue_lbio&lt;/code&gt;来提交I/O指令&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LBIO不会合并和调度IO请求&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;read-path&#34;&gt;Read Path&lt;/h2&gt;
&lt;p&gt;Ext4文件系统中，由extent status tree保存缓存到物理文件block的映射&lt;/p&gt;
&lt;p&gt;预加载映射到内存中，当树太大时，可以只对某个文件预加载&lt;/p&gt;
&lt;h3 id=&#34;异步页面申请和dma分配&#34;&gt;异步页面申请和DMA分配&lt;/h3&gt;
&lt;p&gt;提前分配空闲页池&lt;/p&gt;
&lt;p&gt;为了减少页面DMA的分配，为每个核维护一个DMA映射空闲页（4KB DMA映射页的链表）&lt;/p&gt;
&lt;p&gt;当空闲页池不够用时，将退化为同步进行（origin）&lt;/p&gt;
&lt;h3 id=&#34;缓存页索引&#34;&gt;缓存页索引&lt;/h3&gt;
&lt;p&gt;自旋锁防止并发问题，影响效率&lt;/p&gt;
&lt;p&gt;在请求发出，但是页面还没有更新时，可能重复请求更新页面&lt;/p&gt;
&lt;p&gt;解决方案是不限制request，在request completion阶段解决问题&lt;/p&gt;
&lt;p&gt;尽管多个block请求，但是只能有一个页面被索引&lt;/p&gt;
&lt;p&gt;对于其他页面，标记为abandoned，中断发生之后，如果标记为abandoned，则清除已经完成的页面&lt;/p&gt;
&lt;h3 id=&#34;dma解除映射&#34;&gt;DMA解除映射&lt;/h3&gt;
&lt;p&gt;原本使用中断来处理，改为当系统空闲或等待一个IO请求时处理&lt;/p&gt;
&lt;p&gt;该方式可能会产生漏洞窗口，若不受到恶意访问，不会产生影响，否则用户可以自行选择关闭惰性DMA映射接触&lt;/p&gt;
&lt;h2 id=&#34;write--fsync-path&#34;&gt;Write &amp;amp;&amp;amp; fsync Path&lt;/h2&gt;
&lt;p&gt;当fsync涉及文件系统中事务时，可以将jbd2日志处理重叠处理&lt;/p&gt;
&lt;h1 id=&#34;experiment&#34;&gt;Experiment&lt;/h1&gt;
&lt;p&gt;基于Linux内核5.0.5版本&lt;/p&gt;
&lt;p&gt;使用文件描述符&lt;code&gt;O_AIOS&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;evaluation&#34;&gt;Evaluation&lt;/h1&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;提出了AIOS&lt;/p&gt;
&lt;p&gt;LBIO层&lt;/p&gt;
&lt;p&gt;AIOS将I/O路径中的同步操作替换为异步操作，以将与读取和fsync相关的计算与设备I/O访问重叠。&lt;/p&gt;
&lt;p&gt;AIOS在Optane SSD上实现了一位数微秒的I/O延迟。&lt;/p&gt;
&lt;p&gt;此外，AIOS通过Z-SSD和Optane SSD上的模拟实验和实际测试显著降低延迟和性能改进。&lt;/p&gt;
&lt;h1 id=&#34;一些启发&#34;&gt;一些启发&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;优化I/O可以从CPU的空闲时间分析，需要考虑内核和文件系统的工作流程，最大程度的利用CPU资源，减少空闲。&lt;/li&gt;
&lt;li&gt;硬件设备在发展的同时，软件应该提供必要适配&lt;/li&gt;
&lt;li&gt;减少内核中与I/O相关的结构类型转化，可以有效节省时间开销&lt;/li&gt;
&lt;li&gt;惰性修改会存在安全问题，在保证安全的情况下，可以提高效率&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>[OSDI&#39;19] Flashshare: Punching Through Server Storage Stack from Kernel to Firmware for Ultra-Low Latency SSDs</title>
        <link>https://blog.ipandai.club/p/osdi19-flashshare-punching-through-server-storage-stack-from-kernel-to-firmware-for-ultra-low-latency-ssds/</link>
        <pubDate>Wed, 17 Aug 2022 10:30:30 +0800</pubDate>
        
        <guid>https://blog.ipandai.club/p/osdi19-flashshare-punching-through-server-storage-stack-from-kernel-to-firmware-for-ultra-low-latency-ssds/</guid>
        <description>&lt;p&gt;超低延迟固态硬盘从内核到固件的服务器存储堆栈&lt;/p&gt;
&lt;h1 id=&#34;个别名词解释&#34;&gt;个别名词解释&lt;/h1&gt;
&lt;p&gt;the 99^th percentile 超过统计数据99%的数是多少&lt;/p&gt;
&lt;p&gt;blk-mq Linux Multiqueue block layer 内核对ssd随机I/O的优化&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;message signaled interrupt (MSI)&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;1摘要&#34;&gt;1.摘要&lt;/h1&gt;
&lt;p&gt;flash share&lt;/p&gt;
&lt;p&gt;在内核中，扩展了系统堆栈的数据结构，传递应用程序的属性（？），包括内核层到SSD固件。&lt;/p&gt;
&lt;p&gt;对于给定的属性，FlashShare的块层管理IO调度并处理NVMe中断。&lt;/p&gt;
&lt;p&gt;评估结果表明，FLASHSHARE可以将共同运行应用程序的平均周转响应时间分别缩短22%和31%。&lt;/p&gt;
&lt;h1 id=&#34;10-intro&#34;&gt;1.0 Intro&lt;/h1&gt;
&lt;h2 id=&#34;11-现状&#34;&gt;1.1 现状&lt;/h2&gt;
&lt;p&gt;网络服务提供商，满足服务级别协议SLA，延迟敏感&lt;/p&gt;
&lt;p&gt;某个段时间短可能有大量请求涌入，供应商会超额配置机器以满足SLA&lt;/p&gt;
&lt;p&gt;现状：该场景并不常见，因此大部分情况下服务器的资源占用率非常低，能耗比低。&lt;/p&gt;
&lt;p&gt;为了解决利用率低，服务器会运行离线的数据分析应用，延迟不敏感，以吞吐量为导向。&lt;/p&gt;
&lt;p&gt;因此，在运行了多个进程的服务器上，I/O延迟增高，满足SLA非常困难。&lt;/p&gt;
&lt;p&gt;现有的ULL SSD相较于NVMe SSD可以减少10倍的延迟&lt;/p&gt;
&lt;p&gt;但是这些ULL SSD在同时运行多个进程下高强度压榨服务器的时候，不能充分利用ULL SSD的优势/表现一般。&lt;/p&gt;
&lt;p&gt;the 99th percentile 是0.8ms（apache）&lt;/p&gt;
&lt;p&gt;但是当服务器同时运行pagerank的时候，延迟会增加228.5%。&lt;/p&gt;
&lt;p&gt;原因：略&lt;/p&gt;
&lt;p&gt;从固件到内核优化堆栈的存储。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;内核级别的增强：&lt;/p&gt;
&lt;p&gt;两个挑战&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux的blk-mq导致I/O请求队列化，引入延迟&lt;/li&gt;
&lt;li&gt;NVMe的队列机制没有对I/O优先级的策略，因此，来自离线应用的IO请求容易阻塞在线应用的紧急请求，造成延迟。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于latency critical的请求，绕过NVMe的请求队列。同时令NVMe的驱动通过知晓每个应用的延迟临界匹配NVMe的提交和请求队列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;固件层设计：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​		即使内核级的优化保证了延迟敏感的请求可以获得高优先级，但如果基础固件不了解延迟临界值，ULL特性（类似内存的性能）无法完全暴露给用户。本文中重新设计了I/O调度和缓存的固件，以直接向用户暴露ULL特性。将ULL SSD的集成缓存进行分区，并根据工作负载的属性对每个I/O服务独立的分配缓存。固件动态的更新分区大小并以精细粒度调整预取I/O粒度。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ULL SSD的新中断处理服务：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​	当前的NVMe中断机制没有对ULL I/O服务优化。轮询方法（Linux 4.9.30）消耗了大量的CPU资源去检查I/O服务的完成情况。当轮询在线交互服务的IO请求完成状态时，flashShare使用一个仅对离线应用程序使用消息信号中断的选择性中断服务程序Select-ISR。&lt;/p&gt;
&lt;p&gt;​	通过将NVMe队列和ISR卸载到硬件加速器中来进一步优化NVMe completion routine。&lt;/p&gt;
&lt;p&gt;​	各种仿真实验后效果不错，效率提高了22%和31%。&lt;/p&gt;
&lt;h1 id=&#34;20-background&#34;&gt;2.0 Background&lt;/h1&gt;
&lt;h2 id=&#34;21-存储内核栈&#34;&gt;2.1 存储内核栈&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.ipandai.club/image-20220810145032258.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20220810145032258&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Linux文件系统IO&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bio&lt;/li&gt;
&lt;li&gt;request&lt;/li&gt;
&lt;li&gt;nvme_rw_command&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;存储堆栈中，NVMe驱动发起的请求通过nvme_rw_command的形式传递到PCI/PCIe设备驱动中。&lt;/p&gt;
&lt;p&gt;当I/O请求完成后，发送信号中断，中断直接被写入到中断处理器的中断向量中。被中断的核心选择ISR处理该中断请求，随后NVMe驱动再SQ/CQ中清空相应的记录并将结果返回至上一层（比如blk-mq和文件系统）。&lt;/p&gt;
&lt;h2 id=&#34;22-设备固件栈&#34;&gt;2.2 设备固件栈&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.ipandai.club/image-20220810232230437.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20220810232230437&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;收到request&lt;/li&gt;
&lt;li&gt;SQ tail++入队&lt;/li&gt;
&lt;li&gt;写入SQ门铃寄存器&lt;/li&gt;
&lt;li&gt;通过DMA读取数据的物理位置&lt;/li&gt;
&lt;li&gt;SQ head++出队&lt;/li&gt;
&lt;li&gt;将请求转发至嵌入式缓存层或者FTL&lt;/li&gt;
&lt;li&gt;当出现缺页或者页面替换时，FTL将目标LBA转换成Z-NAND中相应的物理地址，必要时自行GC&lt;/li&gt;
&lt;li&gt;在完成I/O请求之后，NVMe控制器增加这个CQ的tail，入队&lt;/li&gt;
&lt;li&gt;通过DMA传输数据，并修改phase tag&lt;/li&gt;
&lt;li&gt;主机ISR通过搜索队列中检查phase tag，对于有效的phase tag，ISR清除tag位，并且处理剩余的I/O完成请求程序。&lt;/li&gt;
&lt;li&gt;CQ head++出队，在SQ中移除相应的记录，并且写入CQ的head doorbell&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;30-跨层设计&#34;&gt;3.0 跨层设计&lt;/h1&gt;
&lt;h2 id=&#34;31-快速存储的挑战&#34;&gt;3.1 快速存储的挑战&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.ipandai.club/image-20220811110758918.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20220811110758918&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;原因是存储栈无法区分来自Apache的I/O请求，及时两个应用需要不同级别I/O的响应。&lt;/p&gt;
&lt;h1 id=&#34;32-预知灵敏响应&#34;&gt;3.2 预知灵敏响应&lt;/h1&gt;
&lt;p&gt;为了让内核可以区分I/O 请求的优先级和紧迫程度，修改Linux的进程控制快&lt;code&gt;task_struct&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;为了保证有效性，在&lt;code&gt;address_space&lt;/code&gt;,&lt;code&gt;bio&lt;/code&gt;,&lt;code&gt;request&lt;/code&gt;,&lt;code&gt;nvme_rw_command&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;中都保存工作负载属性，在存储堆栈上打孔。&lt;/p&gt;
&lt;p&gt;FlashShare同时提供了一个可以在服务器上配置这些属性的工具。叫做&lt;code&gt;chworkload_attr&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;可以方便的修改每个应用的属性并绑定到&lt;code&gt;task_struct&lt;/code&gt;中&lt;/p&gt;
&lt;p&gt;修改了syscall表&lt;code&gt;arch/x86/entry/syscalls/syscall 64.tbl&lt;/code&gt;添加了两个系统调用，可以从&lt;code&gt;task_struct&lt;/code&gt;中set/get工作属性。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;/linux/syscall.h&lt;/code&gt;中进行注册，并带有&lt;code&gt;asmlinkage&lt;/code&gt;标签。&lt;/p&gt;
&lt;p&gt;用户通过shell给定特定进程，实现于&lt;code&gt;/sched/cores.c&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;33-内核优化&#34;&gt;3.3 内核优化&lt;/h2&gt;
&lt;p&gt;优化文件系统中的blk-mq和NVMe驱动&lt;/p&gt;
&lt;p&gt;blk-mq合并重排请求提高了带宽使用，但是引入了延迟&lt;/p&gt;
&lt;p&gt;跳过所有在线应用的I/O 请求&lt;/p&gt;
&lt;p&gt;如果离线应用程序的 I/O 请求被 blk-mq 调度到后续在线应用程序发出的同一 LBA，则可能发生危险。&lt;/p&gt;
&lt;p&gt;如果两个请求的操作类型不同，blk-mq会将两个请求串联。否则blk-mq会将两个请求合并为一个&lt;code&gt;request&lt;/code&gt;并交给NVMe驱动。&lt;/p&gt;
&lt;p&gt;为了防止延迟敏感的I/O 被NVMe控制器杀死：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为每个核心创建两个SQ队列和一个CQ队列&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.ipandai.club/image-20220811173922087.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20220811173922087&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;其中一个SQ保存来自在线应用的I/O请求。&lt;strong&gt;NVMe驱动程序通过管理员队列发送消息，通知NVMe控制器选择一种新的队列调度方法，该方法始终优先安排该SQ中的请求。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;未来避免因优先级带来的饥饿，当该队列中的请求数量大于阈值时，或者没有在规定时间内被满足，NVMe驱动会满足所有离线应用I/O 。&lt;/p&gt;
&lt;p&gt;实验表明，队列大小为8或者200us的阈值最好。&lt;/p&gt;
&lt;h1 id=&#34;40-io-completion和缓存&#34;&gt;4.0 I/O Completion和缓存&lt;/h1&gt;
&lt;p&gt;采用轮询机制时查询I/O Completion时，内核态占用97%。&lt;/p&gt;
&lt;p&gt;带来两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;没有为处理I/O 响应单独分配核心，对于多进程下低效&lt;/li&gt;
&lt;li&gt;我们要减轻处理I/O轮询的核心开销，进一步降低延迟&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;41-中断处理程序&#34;&gt;4.1 中断处理程序&lt;/h2&gt;
&lt;p&gt;flash share仅对来自在线应用的I/O 请求使用轮询&lt;/p&gt;
&lt;p&gt;使用信号处理离线应用&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.ipandai.club/image-20220811231355037.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20220811231355037&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;修改blk-mq中的&lt;code&gt;submit_bio()&lt;/code&gt;，将由文件系统或缓存的bio插入到mq&lt;/li&gt;
&lt;li&gt;如果bio是来自离线应用的，则插入队列，as normal&lt;/li&gt;
&lt;li&gt;如果bio是来自在线应用的，blk-mq则调用&lt;code&gt;queue_rq()&lt;/code&gt;将请求发送至NVMe驱动。&lt;/li&gt;
&lt;li&gt;NVMe驱动转换I/O 请求为NVMe指令并非插入到响应SQ队列中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用Select-ISR，当请求为离线应用时，CPU核心可以通过上下文切换从NVMe驱动中释放。否则，blk-mq调用轮询机制&lt;code&gt;blk-poll()&lt;/code&gt;。&lt;code&gt;blk-poll()&lt;/code&gt;持续调用&lt;code&gt;nvme_poll()&lt;/code&gt;，检查有效的完成记录是否存在于目标NVMe CQ中。如果存在，blk-mq禁用此CQ的IRQ，以至于MSI信号无法再次捕获blk-mq程序。&lt;code&gt;nvme_poll()&lt;/code&gt;通过检查CQ中的phase tags查找CQ中的新记录。&lt;/p&gt;
&lt;p&gt;具体来说，&lt;code&gt;nvme poll()&lt;/code&gt;搜索一个CQ记录，其请求信息与&lt;code&gt;blk poll()&lt;/code&gt;等待完成的标签匹配。一旦检测到这样的新记录，blk-mq就会退出在&lt;code&gt;blk poll()&lt;/code&gt;中实现的无限迭代，并将上下文切换到其用户进程。&lt;/p&gt;
&lt;p&gt;提出&lt;code&gt;I/O-stack accelerator&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;主要目的是将blk-mq的任务迁移到附属于PCIe的加速器中&lt;/p&gt;
&lt;p&gt;可以使得通过上层文件系统生成的bio直接转换成&lt;code&gt;nvm_rw_command&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;通过特殊的tag索引搜索队列中的元素，并且代表CPU合并bio&lt;/p&gt;
&lt;p&gt;该方法可以减少36%的I/O completion时间。&lt;/p&gt;
&lt;h2 id=&#34;42-固件层&#34;&gt;4.2 固件层&lt;/h2&gt;
&lt;p&gt;创建两个内存分区，一个服务于在线应用，一个服务于离线应用。&lt;/p&gt;
&lt;p&gt;三种模式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;固定拆分缓存&lt;/li&gt;
&lt;li&gt;根据I/O动态划分&lt;/li&gt;
&lt;li&gt;数据可保留&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.ipandai.club/image-20220812003132031.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20220812003132031&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;43-io-stack-acceleration&#34;&gt;4.3 I/O-Stack Acceleration&lt;/h2&gt;
&lt;p&gt;添加了一个barrier logic，简单的MUX，作为硬件仲裁&lt;/p&gt;
&lt;p&gt;引入status bitmap来过滤SQ队列中的记录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;合并逻辑插入一个行的nvme 指令，status bitmap设置为1&lt;/li&gt;
&lt;li&gt;如果监测到ULL SSD从I/O SQ中读取NVMe指令，status bitmap设置为0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果状态位图表明CAM中的请求条目（与目标SQ相关联）无效，CAM将跳过对这些条目的搜索。&lt;/p&gt;
&lt;h1 id=&#34;50-实验&#34;&gt;5.0 实验&lt;/h1&gt;
&lt;h2 id=&#34;51-实验步骤&#34;&gt;5.1 实验步骤&lt;/h2&gt;
&lt;p&gt;使用gem5系统结构模拟&lt;/p&gt;
&lt;p&gt;64位arm指令集&lt;/p&gt;
&lt;p&gt;Linux 4.9.30&lt;/p&gt;
&lt;p&gt;8核心2GHz&lt;/p&gt;
&lt;p&gt;L1 Cache 64KB&lt;/p&gt;
&lt;p&gt;2GB Memory&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.ipandai.club/image-20220812191343849.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20220812191343849&#34;
	
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;related-work&#34;&gt;Related Work&lt;/h1&gt;
&lt;p&gt;将SSD固件转移到主机上，消除冗余的地址转换&lt;/p&gt;
&lt;p&gt;根据应用程序特征对缓存进行分区处理，然而不能发挥ULL SSD的作用&lt;/p&gt;
&lt;p&gt;从文件系统和block IO设备方面优化移动端操作系统，使其提高SQLite的性能，有局限性，应用程序、ULL SSD&lt;/p&gt;
&lt;p&gt;在内核的多个层对写请求进行调度，容易阻塞读请求和ULL操作&lt;/p&gt;
&lt;p&gt;根据前台任务和后台任务中的依赖关系，分配优先级，允许后台任务高优先级，IO通常情况下没有依赖关系，效果差，服务器大部分都是多进程&lt;/p&gt;
&lt;p&gt;考虑对在线应用设置高优先级，但是没有考虑对IO stack中其他部分的影响&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
