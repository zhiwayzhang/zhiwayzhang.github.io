{"pages":[{"title":"about","text":"Coder,Student,Worker,Researcher,CitizenLearning and Sharing","link":"/about/index.html"}],"posts":[{"title":"51nod3143-切比雪夫距离与曼哈顿距离","text":"51nod3143 Descriptionn位战士即将奔赴战场，他们每个人都有一个攻击值ai和一个防御值bi，现在你想设计一种装备给这n位战士，如果这件装备的攻击值为A，防御值为B，那么对于第i位战士这件装备的不匹配度为$max(|A−a_i|,|B−b_i|)$A，B都是正整数，要让所有战士的不匹配度之和最小，求出最小的不匹配度之和$2\\le N \\le 100000$ Solution题意中很明显是切比雪夫距离，可以将其转换为曼哈顿距离对于点$(x,y)$,转换为$(\\frac{x+y}{2},\\frac{x-y}{2})$然后可以求出转换后横坐标和纵坐标的中位数，再以这个中位数为基准，将四周3*3的范围内的点都进行计算，去最小值。由于涉及除法，可能会发生精度丢失，可以将所有坐标都扩大二倍，最后让答案除以2同时要注意，这里的A，B都是整数，也就是说我们进行计算的点必须也是整数点，可以通过奇偶关系来判断。答案只用A，B为整数点转换过来的点进行计算。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;set&gt;#define debug cout&lt;&lt;0&lt;&lt;endl#define ll long longconst int MAXN = 1e5 + 10;const int MOD = 1e9 + 7;using namespace std;struct point{ ll a, b;} arr[MAXN];int dx[] = {0, 1, -1, 0, 0, 1, 1, -1, -1};int dy[] = {0, 0, 0, 1, -1, 1, -1, 1, -1};ll x[MAXN];ll y[MAXN];int main() { ios::sync_with_stdio(false); cin.tie(0); int N; cin &gt;&gt; N; int xx, yy; for (int i = 1; i &lt;= N; i++) { cin &gt;&gt; xx &gt;&gt; yy; x[i] = arr[i].a = (xx + yy); y[i] = arr[i].b = (xx - yy); } sort(x+1,x+N+1); sort(y+1,y+N+1); int A, B; ll ans = __LONG_LONG_MAX__; if (N&amp;1) { A = x[N/2+1]; B = y[N/2+1]; } else { A = x[N/2+1]; B = y[N/2+1]; } ll ans2 = 0; for (int i = 0; i &lt;= 8; i++) { int tx = A + dx[i]; int ty = B + dy[i]; if ((tx-ty)%2==1 || ((tx+ty))%2==1) continue; ll temp = 0; for (int j = 1; j &lt;= N; j++) { temp += abs(arr[j].a-tx) + abs(arr[j].b-ty); } ans = min(ans, temp); } cout &lt;&lt; ans/2; return 0;}","link":"/2020/10/11/51nod3143/"},{"title":"GCD-兔八哥与猎人","text":"Description兔八哥躲藏在树林旁边的果园里。果园有M × N棵树，组成一个M行N列的矩阵，水平或垂直相邻的两棵树的距离为1。兔八哥在一棵果树下。猎人背着猎枪走进了果园，他爬上一棵果树，准备杀死兔八哥。如果猎人与兔八哥之间没有其它的果树，猎人就可以看到兔八哥。现己知猎人和兔八哥的位置，编写程序判断兔子所在的位置是否安全.输入： 第一行为n，表示有n(n ≤ 100,000)组数据，每组数据的第一行为两个正整数ax和ay，表示猎人的位置，第二行为两个正整数bx和by，表示兔八哥的位置(1 ≤ ax, ay, bx, by ≤ 100,000,000)。输出： 共有n行，每行为“yes”或“no”表示兔八哥的位置是否安全。 Solution容易想到，兔八哥和猎人只要连线上无整数点即可，可以转化成$|a_x - b_x| 和 |a_y - b_y|$互质，即$gcd(|a_x - b_x|,|a_y - b_y|)=1$ Code12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;#define mem(a,b) memset(a,b,sizeof(a))typedef long long ll;typedef unsigned long long ull;using namespace std;inline int gcd(int a, int b) { return b == 0 ? a : gcd(b,a%b);}int main() { //freopen(&quot;test.txt&quot;, &quot;r&quot;, stdin); ios::sync_with_stdio(false); cin.tie(0); int N; cin &gt;&gt; N; while (N--) { int ax, ay, bx, by; cin &gt;&gt; ax &gt;&gt; ay; cin &gt;&gt; bx &gt;&gt; by; int xx = abs(ax - bx); int yy = abs(ay - by); if (gcd(xx,yy) != 1) { cout &lt;&lt; &quot;yes&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;no&quot; &lt;&lt; endl; } } return 0;}","link":"/2020/10/07/GCD/"},{"title":"余数求和-整除分块","text":"Description给出整数$$n,k$$,计算$$G(n,k)=\\sum\\limits_{i=1}^n=k \\ mod \\ i$$,$$1&lt;=n,k&lt;=1e9$$ Solution将k mod i展开可以得到$$k - i\\lfloor \\frac{k}{i} \\rfloor$$将求和式子展开可以得到$$ \\sum\\limits_{i=1}^n = nk-\\sum\\limits_{i=1}^n i * \\lfloor\\frac{k}{i} \\rfloor $$利用整除分块，可以发现，对于相同的$$\\lfloor\\frac{k}{i} \\rfloor$$，即每个区间$$l 到 r$$，每次只需要再对i求和即可即每次计算$$(r-l+1)*\\lfloor \\frac{k}{i} \\rfloor * (l+r)/2$$ Note在分块的时候误写为r=N/(N/i)导致调试耽误大量时间，而且交了四发才发现 1234567for (ll l = 1, r; l &lt;= N; l = r + 1) { if (l &gt; K) { break; } r = min(N, K/(K/l)); ans -= (r - l + 1)*(K/l)*(l + r)/2; } Code1234567891011121314151617181920212223242526272829303132333435363738//https://www.luogu.com.cn/problem/P2261#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;set&gt;#define mem(a,b) memset(a,b,sizeof(a))#define debug cout&lt;&lt;0&lt;&lt;endl#define ll long longconst int MAXN = 1e2 + 10;const int MOD = 1e9 + 7;using namespace std;ll ans = 0;void solve(ll N, ll K) { ans = N*K; for (ll l = 1, r; l &lt;= N; l = r + 1) { if (l &gt; K) { break; } r = min(N, K/(K/l)); ans -= (r - l + 1)*(K/l)*(l + r)/2; } cout &lt;&lt; ans;}int main() { ios::sync_with_stdio(false); cin.tie(0); ll N, K; cin &gt;&gt; N &gt;&gt; K; solve(N, K); return 0;}","link":"/2020/10/07/divide/"},{"title":"统计硬币-递推&#x2F;DP","text":"DescriptionHDU 2566假设一堆由1分、2分、5分组成的n个硬币总面值为m分，求一共有多少种可能的组合方式（某种面值的硬币可以数量可以为0）。 Solution坑题，没给数据范围，只能瞎猜，一发搜索挂掉发现无法去重，但是考虑到该问题满足从1开始分配并无后效性，可以直接递推（类似背包），三种物品可选任意次 Code1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;#define mem(a,b) memset(a,b,sizeof(a))typedef long long ll;typedef unsigned long long ull;using namespace std;int main() { //freopen(&quot;test.txt&quot;, &quot;r&quot;, stdin); ios::sync_with_stdio(false); int N, M; int ans; int dp[2000][2000]; int n[] = {1,2,5}; cin.tie(0); int T; cin &gt;&gt; T; while (T--) { cin &gt;&gt; N &gt;&gt; M; mem(dp,0); dp[0][0] = 1; for (int i = 0; i &lt; 3; ++i) { for (int j = 1; j &lt;= N; ++j) { for (int k = n[i]; k &lt;= M; ++k) { dp[j][k] += dp[j-1][k-n[i]]; } } } cout &lt;&lt; dp[N][M] &lt;&lt; endl; } return 0;}","link":"/2020/10/07/cntcoin/"},{"title":"小兔的棋盘 组合数学","text":"Description小兔的叔叔从外面旅游回来给她带来了一个礼物，小兔高兴地跑回自己的房间，拆开一看是一个棋盘，小兔有所失望。不过没过几天发现了棋盘的好玩之处。从起点$(0，0)$走到终点$(n,n)$的最短路径数是$C_{2n}^{n}$,现在小兔又想如果不穿越对角线(但可接触对角线上的格点)，这样的路径数有多少?小兔想了很长时间都没想出来，现在想请你帮助小兔解决这个问题，对于你来说应该不难吧! $n \\leq 35$ Solution由于规定不能超过对角线，可用分治的思想，只考虑沿对角线分隔开的三角形的情况，对于一个三角形中，求从$(0，0)$走到终点$(n,n)$的最短路径，观察发现无论怎么走，设到达某一点时向上走了$i$步，向右走了$j$步，都有$i \\leq j$这也能通过线性规划相关知识证明。不难发现只是一个类括号匹配问题，可用$Catalan$数求解，计算$C(n)$后即是在一个三角形中的解，答案是$$2C(n)$$ $$C(n) = \\sum_{i=0}^{n-1} C(i) \\cdot C(n-i-1)$$通项公式$$C(n)=\\frac{C_{2n}^{n}}{n+1}$$ 预处理$C(n)$即可 Code1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;queue&gt;typedef long long LL;using namespace std;LL C[100];int main() { C[0] = 1; C[1] = 1; for (int i = 2; i &lt;= 80; i++) { LL t = 0; for (int j = 0; j &lt; i; j++) t += C[j]*C[i - j - 1]; C[i] = t; } LL N; int cnt = 1; while (cin &gt;&gt; N) { if (N == -1) break; cout &lt;&lt; cnt++ &lt;&lt; &quot; &quot; &lt;&lt; N &lt;&lt; &quot; &quot; &lt;&lt; C[N]*2 &lt;&lt; endl; } return 0;}","link":"/2019/12/13/catalan/"},{"title":"DP? 素数筛+Lucas定理+费马小定理","text":"Description在杨辉三角中，从第一行第一列$(0,0)$开始，每次可选择向正下方走或向右下方走，走到第$n$行时不能超过第$n$行第$k$个元素，询问所经过路径的值的和的最小值$mod(p)$，一共有T组询问，$T \\leq 100000$， $0 \\leq k \\leq n \\leq 1e9$, 保证$p$是质数， 其中$p &lt; 1e4$ Solution名字虽然是DP，但是可以找出最优方案。优先考虑$k \\leq \\frac{n}{2}$的情况，先向下走$n-k$步到达$(n-k-1,0)$再一路沿着右下方走，直到到达底部，即有$$C_{n-k}^{0}+C_{n-k+1}^{1}+C_{n-k+2}^{2}+…+C_{n}^{k}=C_{n+1}^{k}$$通过变换$$C_{n-k}^{0} = C_{n-k+1}{0}$$再通过公式$$C_{n}^{m}=C_{n-1}^{m}+C_{n-1}^{m-1}$$可将上述公式合并得到$$C_{n+1}^{k}$$所以答案为$$C_{n+1}^{k}+n-k$$当$$k &gt; \\frac{n}{2}$$时，根据对称性，令$k=n-k$即可转化成上一种情况又发现题目涉及组合数取模，所以要用到费马小定理 费马小定理:假如$a$是一个整数，$p$是一个质数，且$gcd(a,p)=1$，即$a,p$互质，那么有$a^{p−1}≡1(modp)$ 已知$a^{p-1}≡1$，可以得到$a \\cdot a^{p-2}≡1$，我们称$a$和$a^{p-2}$为在$mod(p)$意义下的乘法逆元然而这只解决了除法取模的问题，注意到$n$的范围在$1e9$直接计算组合数又是铁套老鹅(TLE)，于是借助Lucas定理 对于质数$p$,有$$C_n^m\\ mod \\ p = C_{\\lfloor \\frac{n}{p} \\rfloor}^{\\lfloor \\frac{m}{p} \\rfloor} \\cdot C_{n\\ mod\\ p}^{m\\ mod\\ p} \\ mod \\ p$$ 可知$n\\ mod\\ p$和$m\\ mod\\ p$一定是小于$p$的数，可直接求解，其余部分继续用Lucas定理求解，当$m=0$的时候返回$1$ 1234long long Lucas(long long n, long long m, long long p) { if (m == 0) return 1; return (C(n % p, m % p, p) * Lucas(n / p, m / p, p)) % p;} 有了这些工具之后就可以预处理阶乘和逆元了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;queue&gt;typedef long long LL;const int MAXN = 10000;using namespace std;LL N,K,MOD;bool isnotp[MAXN + 10];LL pri[1500], num = 0;//素数表int f[1300][MAXN];//阶乘int inv[1300][MAXN];//逆元inline void Euler() { isnotp[1] = true; memset(isnotp, false, sizeof(isnotp)); for (int i = 2; i &lt;= MAXN; i++) { if (!isnotp[i]) pri[++num] = i; for (int j = 1; j &lt;= num &amp;&amp; i*pri[j] &lt;= MAXN; j++) { isnotp[i*pri[j]] = true; if (i%pri[j]==0) break; } }}LL fffpow(LL x, LL y, LL pp) { LL sum = 1; LL a = x; while (y) { if (y&amp;1) { sum = (sum*a) % pp; } a = (a*a)%pp; y&gt;&gt;=1; } return (sum)%pp;}int cnt = 0;inline LL Lucas(int N,int M,int o){ LL a,b,ans=1; while(N &amp;&amp; M) { a = N%pri[o]; b = M%pri[o]; if(a &lt; b)return 0; ans = ans*f[o][a]%pri[o]*inv[o][b]%pri[o]*inv[o][a-b]%pri[o]; N /= pri[o]; M /= pri[o]; } return ans;} int main() { Euler(); for(int i = 1; i &lt;= num; i++) { f[i][0] = f[i][1] = 1; inv[i][0] = inv[i][1] = 1; for(int j = 2;j &lt; pri[i]; j++) { f[i][j] = f[i][j-1]*j % pri[i]; inv[i][j] = fffpow(f[i][j], pri[i]-2, pri[i]); } } while (cin &gt;&gt; N &gt;&gt; K &gt;&gt; MOD) { LL ans; if(K &gt; N/2) K = N - K; int l = 1, r = 1229; while(l &lt;= r) { int mid = (l + r) &gt;&gt; 1; if(MOD &lt; pri[mid]) r = mid - 1; else l = mid + 1; } ans = (Lucas(N + 1, K, l - 1) + N - K)%MOD; printf(&quot;Case #%d: %lld\\n&quot;, ++cnt, ans); } return 0;}","link":"/2019/12/13/lucas/"},{"title":"Fibonacci 矩阵快速幂","text":"Description请输出$Fib(n) mod 10000$$n \\leq 1000000000$ Solution由于$n$的范围在$1e9$直接递推铁TLE，考虑矩阵快速幂Fibonacci数列有如下性质通过多次迭代算是个板子题吧，记得在WUST新生赛做过一道想矩阵快速幂的题，然而正解是找规律QAQ，在此贴个板子。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;string&gt;typedef long long LL;const int MOD = 1e4;using namespace std;struct Matrix{ LL m[2][2]; void print(){ for (int i = 0; i &lt; 2; i++) { for (int j = 0; j &lt; 2; j++) cout &lt;&lt; m[i][j] &lt;&lt; ' '; cout &lt;&lt; endl; } }} base, ans;Matrix times(Matrix a, Matrix b) { Matrix ans; ans.m[0][1] = ans.m[0][0] = ans.m[1][0] = ans.m[1][1] = 0; for (int i = 0; i &lt; 2; i++) { for (int j = 0; j &lt; 2; j++) { for (int k = 0; k &lt; 2; k++) ans.m[i][j] = (ans.m[i][j] + a.m[i][k]*b.m[k][j])%MOD; } } return ans;}void Matrixpow(LL x) { base.m[0][0] = base.m[1][0] = base.m[0][1] = 1; base.m[1][1] = 0; ans.m[0][0] = ans.m[1][1] = 1; ans.m[0][1] = ans.m[1][0] = 0; while (x) { if (x&amp;1){ ans = times(ans, base); } x &gt;&gt;= 1; base = times(base, base); }}LL N;int main(){ while (cin &gt;&gt; N) { if (N == -1) break; if (N == 0) { cout &lt;&lt; &quot;0&quot; &lt;&lt; endl; continue; } Matrixpow(N); cout &lt;&lt; ans.m[0][1] % MOD &lt;&lt; endl; } return 0;}","link":"/2019/12/13/fibMatrix/"},{"title":"计算几何-平行四边形","text":"Description求平面上n个点构成的平行四边形个数。输入一行一个数n。接下来n行，每行两个数x,y，表示这个点的坐标为(x,y)。保证任意两点不重合，任意三点不共线。输出一行一个整数表示平行四边形个数。 Solution按照平行四边形的性质，两组顶点的中点重合，可以统计出每组顶点的中点，再统计每个顶点的个数，排列组合一下 Note第一发对于顶点的统计出锅了，排序条件写错，提交都要检查排序","link":"/2020/05/13/jsjh/"},{"title":"莫队-小B的询问洛谷P2709","text":"DescriptionP2709小B 有一个长为n的整数序列$a$，值域为$[1,k]$。他一共有m个询问，每个询问给定一个区间$[l,r]$求：$\\sum_{i=1}^k c_i^2$其中 $c_i$表示数字 $i$ 在$[l,r]$ 中的出现次数。小B请你帮助他回答询问。 Solution莫队算法板子题 mark Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;set&gt;#define mem(a,b) memset(a,b,sizeof(a))#define debug cout&lt;&lt;0&lt;&lt;endl#define ll long longconst int MAXN = 5e4 + 10;const int MOD = 1e9 + 7;using namespace std;struct Q{ int l, r, k;} q[MAXN];int N, M, K;int pos[MAXN], a[MAXN], cnt[MAXN];ll ans[MAXN];ll res;inline void Add(int n) { cnt[a[n]]++; res += 2ll*cnt[a[n]] - 1;}inline void Sub(int n) { cnt[a[n]]--; res -= 2ll*cnt[a[n]] + 1;}int main() { ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; N &gt;&gt; M &gt;&gt; K; int siz = sqrt(N); for (int i = 1; i &lt;= N; i++) { cin &gt;&gt; a[i]; pos[i] = i/siz; } for (int i = 1; i &lt;= M; i++) { cin &gt;&gt; q[i].l &gt;&gt; q[i].r; q[i].k = i; } sort(q+1,q+M+1,[](Q x, Q y){ return pos[x.l] == pos[y.l] ? x.r &lt; y.r : pos[x.l] &lt; pos[y.l]; }); int l = 1, r = 0; for (int i = 1; i &lt;= M; i++) { while (q[i].l &lt; l) Add(--l); while (q[i].r &gt; r) Add(++r); while (q[i].l &gt; l) Sub(l++); while (q[i].r &lt; r) Sub(r--); ans[q[i].k] = res; } for (int i = 1; i &lt;= M; i++) { cout &lt;&lt; ans[i] &lt;&lt; endl; } return 0;}","link":"/2020/10/07/modui/"},{"title":"Triangle Fibonacci+二分查找","text":"Description有$n$个木棍，长度为$1,2,3…n$，现在要从中删掉一些木棍，使得剩下的木棍不能构成三角形，使删掉木棍的数量最少。T组数组，$T \\leq 20$$n \\leq 20$ Solution由于数据范围很小，可以直接暴力求解，依次选取两个数$a,b(a&lt;b)$相加，要知道不能有任何一个数小于这个值，直接删掉$(a,a+b)$范围中的数即可如果$n$的范围是$1e9$呢？通过找规律发现我们剩下的数是这样的$1,2,3,5,8,13,21…$这是Fibonacci数列!!!!所以我们只需要找到$\\leq n$的Fibonacci数有几个，减去就是答案可以直接lower_bound注意处理极限数据！！！即$n==1||n==2$的情况也可手写二分，但是二分貌似常数有点大，又考虑到第$88$个Fibonacci数就爆掉$1e9$了，所以直接便利也完全没问题 Code暴力版本12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;bool vis[23];int main() { int T; cin &gt;&gt; T; for (int i = 1; i &lt;= T; i++) { int N, ans = 0; cin &gt;&gt; N; memset(vis, false, sizeof(vis)); for (int j = 1; j &lt;= N - 1; j++) if (!vis[j]) { for (int k = j + 1; k &lt;= N; k++) { if (!vis[k]) { for (int l = k + 1; l &lt;= j + k - 1; l++) if (!vis[l] &amp;&amp; l &lt;= N) vis[l] = true, ans++; break; } } } printf(&quot;Case #%d: %d\\n&quot;, i, ans); } return 0;} 二分+Fib123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;queue&gt;typedef unsigned long long uLL;typedef long long LL;const LL MOD = 1e18; using namespace std;LL f[100];int main() { f[0] = 1; f[1] = 1; for (int i = 2; i &lt;= 80; i++) f[i] = f[i - 1] + f[i - 2]; int T; cin &gt;&gt; T; for (int i = 1; i &lt;= T; i++){ LL N; cin &gt;&gt; N; if (N == 1 || N == 2) { printf(&quot;Case #%d: 0\\n&quot;, i); continue; } int l = 1, r = 80; /*手写二分查找 while (l &lt;= r) { int mid = (l + r) &gt;&gt; 1; if (f[mid] &lt;= N) l = mid + 1; else r = mid - 1; } int pos = l; */ int pos = lower_bound(f, f + 80, N) - f; if (f[pos] != N) pos--; printf(&quot;Case #%d: %d\\n&quot;, i, N - pos); } return 0;}","link":"/2019/12/13/fib/"},{"title":"Luogu3964-松鼠聚会","text":"Luogu3964 Description草原上住着一群小松鼠，每个小松鼠都有一个家。时间长了，大家觉得应该聚一聚。但是草原非常大，松鼠们都很头疼应该在谁家聚会才最合理。每个小松鼠的家可以用一个点$(x,y)$表示,两个点的距离定义为点 $(x,y)$ 和它周围的8个点 $$(x-1,y)，(x+1,y),(x,y-1)，(x,y+1)$$$(x−1,y+1),(x-1,y-1),(x+1,y+1),(x+1,y-1)$距离为1。输出一个整数，表示松鼠为了聚会走的路程和最小是多少。 Solution观察题目发现，松鼠家之间的距离为切比雪夫距离，可以通过转换成曼哈顿距离求解，即问题转换为给出平面中的N个点，求一个点到其他所有点的曼哈顿距离之和最小是多少。如果选定的点为第j个答案即为$$\\sum_{i=1}^{N}dis(i,j)$$,dis表示两个点的曼哈顿距离将两个坐标拆开计算，可以得到$$ans_x = \\sum_{i=1}^Ndis(j,i)$$$$dis(1,j)+dis(2,j)+dis(3,j) +…+dis(n,j)$$将横坐标按照升序排序$$(x_j-x_1)+(x_j-x_2)+(x_j-x_3)+…+(x_j-x_{j-1})+(x_{j+1}-x_j)+…+(x_n-x_j)$$ $$\\sum_{i=1}^{j-1}(x_j-x_i)+\\sum_{i=j+1}^{N}(x_i-x_j)$$ $$(j-1)*x_j-\\sum_{i=1}^{j-1}x_i + \\sum_{i=j+1}^Nx_i-(N-j)*x_j$$ $$\\sum_{i=1}^Nx_i-2\\sum_{i=1}^jx_i-x_j*(n-2*j)$$于是可以使用前缀和优化，坐标排序后预处理前缀和在每次进行计算时在有序坐标数组中找到对应的下标精度问题可以先把坐标都扩大二倍，最后令答案处以2 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;set&gt;#define debug cout&lt;&lt;0&lt;&lt;endl#define ll long longconst int MAXN = 1e5 + 10;const int MOD = 1e9 + 7;using namespace std;int N;struct point { ll x, y;} a[MAXN];ll x[MAXN]; ll prex[MAXN];ll y[MAXN];ll prey[MAXN];int main() { ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; N; for (int i = 1; i &lt;= N; i++) { int xx, yy; cin &gt;&gt; xx &gt;&gt; yy; x[i] = a[i].x = (xx + yy); y[i] = a[i].y = (xx - yy); } sort(x+1, x+N+1); sort(y+1, y+N+1); for (int i = 1; i &lt;= N; i++) { prex[i] = prex[i-1] + x[i]; prey[i] = prey[i-1] + y[i]; } ll ans = __LONG_LONG_MAX__; for (int i = 1; i &lt;= N; i++) { ll temp; int lx = lower_bound(x+1,x+N+1,a[i].x) - x; int ly = lower_bound(y+1,y+1+N,a[i].y) - y; temp = (prex[N]-2*prex[lx]-a[i].x*(N-2*lx)) +(prey[N]-2*prey[ly]-a[i].y*(N-2*ly)); // cout &lt;&lt; &quot; list = &quot;&lt;&lt; a[i].x &lt;&lt; ' ' &lt;&lt; a[i].y &lt;&lt; ' ' &lt;&lt; temp &lt;&lt; endl; ans = min(ans, temp); } cout &lt;&lt; (ans/2); return 0;}","link":"/2020/10/11/luogu3964/"},{"title":"WHUT新生赛&quot;游记&quot;","text":"Day -N快新生赛了啊啊啊啊，半个多月没碰算法题了，一直在搞ToKen的前端任务，还在搞服务器的事，感觉要凉凉。 Day 1嗯，就只有Day1.早上起的很晚，八点半才从床上爬起来，起来之后第一件事是看我的USB-HUB发货没有!!!都好几天了，一个USB接口坏了，机械键盘没法用啊，想去买usb转type-c线的想了想还是再等等吧ε=ε=ε=┏(゜ロ゜;)┛下楼去堕落一条街吃了早饭。中午吃完饭回来买了杯奶茶丫丫精，发现喝完了有点撑得慌~~~~然后就等12.30了。比赛开始赶紧去找签到题。 A题emmmmm像是的数学题，递推，一看数据范围感觉不可做。 B题这题面稍微有点问题啊。室友就以为是按顺序组合起来的，虽然感觉仔细想想也想出来是求和的，直接DFS走了？？？不存在的，这里有个老年人sum没重置，debug一万年啊，最后才发现sum每次没有赋初值ε=ε=ε=┏(゜ロ゜;)┛ C题签到题 D题一开始没看清题意，直接while求Σa*0.1一直到不影响答案为止，算到了1e-5，第一发不知道咋WA了，两发才过。 E题博弈论，不可做 F题并查集。但是！！老年人在这里又拉胯了！！！要输出没有感染的人，我输出了一万年感染的人，交了五六发？？？ J题模拟题。 Ｈ题贪心交了一发没过，分类讨论情况可能会很多，没敢用搜索。 I题博弈论sg==就会三种博弈的蒟蒻枯了。听WHU的巨巨说记忆化搜索也能过。 J题计算几何。我认输。在线处理当成直线做的，没考虑到路程是个线段，debug一万年，最后还有半个小时封板的时候放弃了QAQ K题模拟题，我充分意识到半个小时可能写不出来了，想去debug一下J题吧 后记最后五题榜19。校内 榜二。WHU和HUST的巨巨们霸榜啊orz。 进队了orz 其实感觉中间耽误了好多时间啊，低级错误，不然可能会在开出两题，just可能。orz J题一大遗憾。也是给自己个教训吧。 至此成为WHUTer之后，又成为了ToKener，又成为了ACMer。专心训练和学习啦。逃ε=ε=ε=┏(゜ロ゜;)┛：蒟蒻 蒟蒻 蒟蒻","link":"/2019/11/16/whutacm/"},{"title":"中缀表达式求值","text":"中缀表达式求值对于表达式求值，我们通常用栈来操作。常用的做法是先转换为后缀表达式，再利用栈来求值。步骤如下： 开一个栈一个储存运算符，再开一个结构存后缀表达式，可以选择string数组 每遇到一个数字，将其加入到后缀表达式种 遇到左括号，加入到符号栈种 遇到右括号，不断将栈顶元素添加到后缀表达式中，直到遇到左括号，然后弹出左括号 遇到普通运算符，只要栈顶符号的优先级不低于新符号，就不断取出栈顶元素存到后缀表达式，然后将新符号入栈，优先级顺序为乘除&gt;加减&gt;左括号 依次取出符号栈中剩余元素，加入到后缀表达式中 将得到的后缀表达式求值 Note代码在取栈顶元素时容易出错，需要注意对栈为空时的判断 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#define mem(a,b) memset(a,b,sizeof(a))#define debug cout&lt;&lt;0&lt;&lt;endl#define ll long longconst int MAXN = 1e4 + 10;const int MOD = 1e9 + 7;using namespace std;stack&lt;int&gt; stnumber;stack&lt;char&gt; stsign;stack&lt;int&gt; ans;struct node { string s=&quot;&quot;;} a[MAXN];int oder(char c) { if (c == '+' || c == '-') return 1; else if (c == '*' || c == '/') return 2; return 0;}int toInt(string ss) { int res = 0; for (int i = 0; i &lt; ss.length(); i++) { res = res*10 + ss[i] - '0'; } return res;}int calc(int aa, int bb, char op) { switch (op) { case '+': return aa + bb; break; case '/': return bb / aa; break; case '*': return aa*bb; break; case '-': return bb - aa; break; default: break; }}bool isnum(char si) { if (si &lt;= '9' &amp;&amp; si &gt;= '0') return true; return false;}int cur = 0;int main() { ios::sync_with_stdio(false); cin.tie(0); int N; cin &gt;&gt; N; string s; cin &gt;&gt; s; N = s.length(); int len = 0; for (int i = 0; i &lt; N; i += len) { len = 0; if (isnum(s[i])) { string t = &quot;&quot;; for (int j = i; j &lt; N; j++) { if (isnum(s[j])) { t += s[j]; len++; } else { break; } } a[++cur].s = t; } else { if (s[i] == '(') stsign.push(s[i]); else if (s[i] == ')') { while (stsign.top() != '(') { char op = stsign.top(); stsign.pop(); a[++cur].s += op; } stsign.pop(); } else { char op = s[i]; if (!stsign.empty()) while (!stsign.empty() &amp;&amp; oder(stsign.top()) &gt;= oder(op)) { a[++cur].s += stsign.top(); stsign.pop(); //if (stsign.empty()) break; } stsign.push(op); } len = 1; } } while (!stsign.empty()) { char op = stsign.top(); stsign.pop(); a[++cur].s += op; } // for (int i = 1; i &lt;= cur; i++) { // cout &lt;&lt; a[i].s &lt;&lt; endl; // } for (int i = 1; i &lt;= cur; i++) { int temp; if (isnum(a[i].s[0])) { temp = toInt(a[i].s); ans.push(temp); } else { int aa = ans.top(); ans.pop(); int bb = ans.top(); ans.pop(); ans.push(calc(aa, bb, a[i].s[0])); } } cout &lt;&lt; ans.top(); return 0;}","link":"/2020/10/07/zhongzhui/"},{"title":"计算机组成原理笔记","text":"本文随机更新机组笔记 CH2数据表示定点数与浮点数定点数小数点的位置固定不变，有两种形式，定点小数和定点整数.定点整数要求小数点在数据最低有效数位之后。$$00101001.$$定点小数要求小数点在数据最高有效数位之前。$$0.1111111$$ 浮点数基数为2的数F，浮点表示为$$F = M \\times 2^E$$其中M为尾数，E为阶码。尾数为带符号的纯小数，阶码为带符号的纯整数。按照上式表示的数字既可以是纯整数，也可以是纯小数，因此小数点位置不固定，所以称为浮点数。 在计算机中，常用的一种浮点数表示方法为 数符 阶符 阶码数值部分 尾数数值部分 1 1 k n 阶码和尾数的数值范围为 阶码与尾数 数值 阶码与尾数 数值 阶码最小值 $-2^k$ 阶码最大值 $2^k-1$ 尾数最小负值 $-1$ 尾数最大负值 $-2^{-n}$ 尾数最小正值 $+2^{-n}$ 尾数最大正值 $+(1-2^{-n})$ 因此可以得到浮点数表示的数值范围：最小负数:$-2^{2^k-1}=-2^{阶码最大值}$ 最大负数:$-2$ 因此浮点数编码位数位$$m=(n+1)+(k+1)$$ 补码补码的特点： n位补码表示的整数数值范围为$[-2^{n-1},2^{n-1}-1]$ n位补码表示的小数数值范围为$[-1,1-2^{-n+1}]$ 在补码中0的表示是唯一的 变形码，当模数为4时，可以形成双符号位补码，11表示负，00表示正，当两个符号位不同时表示运算溢出，又叫做变形补码。待更 求补运算，处理器中有求补指令，其功能是对操作数取负数(所有位变反+1) 简化加减法$$[X+Y]_补=[X]_补+[Y]_补$$ 移码当一个数字的正数所对的二进制与负数所对的二进制直接比较大小时，会出现负数所对的二进制更大的情况。例如对于十进制数31 $$10011111_{-31} &gt; 01100001_{31}$$ 如果对负数补码上加上一个偏移量，再进行比较即可反应实际情况。 定义为:对于包括符号位在内的n位字长，在其真值上加上$2^{n-1}$$$[X]_移 =2^{n-1}+X$$ 特点：$$[X]_移&lt;符号为取反&gt;[X]_补$$ 纠错码若有n位数据，添加k位校验位，共有n+k位编码 海明距离：$$d = |x-y|=\\sum_{i=0}^{m-1}|x_i-y_i|$$ 可以使用位运算异或求解，获得海明距离 奇偶校验码 奇校验：设$$X = x_0x_1x_2x_3x_4…x_{n-1}$$是一个n位字，在最高位添加一位奇校验c使得$$X’=cx_0x_1x_2x_3x_4…x_{n-1}$$有$$c \\oplus x_1\\oplus … \\oplus x_{n-1} = 1$$ 偶校验则相反，只能判断是否出错，无法纠错 海明校验码 对于16位数据，用$$D_{16}-D_{0}$$分别表示高位到低位，要使其拥有1位纠错功能，则需要在有效信息中添加5个校验位，H4～H0此时海明码的码长为$$m=n+k=16+5=21$$ 循环冗余校验码大概就是用一个性能比较好的生成多项式构造一个编码，利用模2除法的余数进行校验，而且纠错性能不是100%，先Pass 运算方法和运算器加减运算利用补码的性质，可以将运算转化为补码的加法。 $$[X+Y]_补=[X]_补+[Y]_补$$ 这里有一个需要区分的概念，求补运算和求补码的区别 求补：对一个正数求补，令其包括符号位在内的各位取反再加1，即可得到该数的负数，若对该负数再求补，可以得到原来的正数。 $$[[X]_补]_求=[-X]_补$$ 同理有 $$[[-X]_补]_求=[X]_补$$ 可以总结出补码减法的运算法则为 $$[X-Y]_补 = [X]_补+[-Y]_补 =[X]_补+[[Y]_补]_求$$ 因此可以将减法转化为加法运算 溢出判断只有两个符号相同的数字相加，或者符号相异的数相减才有可能发生溢出。若分别用xyz表示三个数字的符号位，可得标准最小项$$\\overline{x} \\cdot \\overline{y} \\cdot z+x\\cdot y\\cdot \\overline{z}$$只有该式为真时，将发生溢出。 双符号位判定每个数字有两个符号位，其中00表示正数，11表示负数令OF OverflowFlag表示溢出符号$$S_1,S_2$$分别表示运算结果的两符号， 有$$OF = S_1 \\oplus S_2$$ 进位符号判定$$令 C_{n-1}表示最高数值位产生的进位，C_n表示符号位产生的进位$$即有$$OF = C_{n-1}\\oplus C_n$$ 一位全加器计算每一位逻辑$$Z_i=X_i\\oplus Y_i \\oplus C_i$$进位信号通过递推产生可以设计出简单的行波式进位加法器，从最低位开始传递进位信号，是异步时序电路，因此运算速度比较慢。 在位数已知的情况下，可以设计电路一次性计算出所有的进位信号，比较理想的情况是以四个位数为一组，该电路增长量级太大，如果需要更多位数可以利用多个该电路组合使用，组成组内并行组间串行进位加法器。","link":"/2021/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/"},{"title":"汇编语言笔记","text":"简介本学期选了汇编语言这门选修课，我认为还是有很大的学习价值的，虽然学习的还是年代久远的8086CPU指令集，但对后续接触更多汇编语言还是有很大帮助，方便我们调试程序，多了一种查错的方式。其实关于调试自己很久之前就想学了，高中的时候看紫书，发现lrj老师讲了一段的gdb调试方法，当时感觉一点都看不懂，现在借此机会学习一下gdb的调试。本文除了将总结一些汇编语言学习过程中的笔记之外，还计划穿插一些cs213/CSAPP 的内容以及bomb lab的解析。 准备工作dos系统现在以及年代久远，想使用8086CPU指令集调试的话需要借助DosBox来实现。DosBox官网 由于macOS下没有DOSbox需要的调试工具，因此下载之后需要挂载debug.exe等Windows下的调试工具在DOSbox中输入 123mount C ~/dosC:debug 即可进入debug模式 实验1前置知识几条汇编指令 1234mov 目标操作对象,源操作数add 目标操作对象,源操作数jmp 寄存器 //修改IP寄存器的值or 12345jmp CS:IPeg: jmp ax == (let IP = ax) jmp 2AE3:3 == let CS = 2AE3H and let IP = 0003Hsub ax,bxax = ax - bx 1234inc and decinc 操作对象 eg: inc ax == ax+=1 dec ax == ax-=1 注意：不可用mov指令修改段寄存器的值。（代码段寄存器CS，指令指针寄存器IP）CPU中识别CS:IP为执行指令操作对象可以是寄存器，也可以是地址 Debug命令 123456r: 看查寄存器内容，或者修改寄存器内容d: 看查内存内容e: 改写内存内容u: 将机器指令翻译为汇编指令t: 执行下一条汇编指令a: 写入汇编指令 编译指令 123masm testlink test.objdebug test.exe lab112345678MOV WORD PTR [1100],3445MOV WORD PTR [1102],5678MOV WORD PTR [1106],6732MOV AX,[1100]SUB AX,[1102]ADD AX,[1106]MOV [1104],AXHLT //使CPU停止工作 123456789101112MOV AX,1234 MOV [1000],AXMOV BX,1002MOV BYTE PTR[BX],20MOV DL,39INC BXMOV [BX],DLDEC DLMOV SI,3MOV [BX+SI],DLMOV [BX+SI+1],DLMOV WORD PTR[BX+SI+2],2846","link":"/2021/03/16/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/"},{"title":"记录一次Go项目的部署","text":"最近写了一个go项目，需要部署到服务器进行测试，如果只是go run main.go难免也太麻烦了点，于是学习了项目部署的相关知识。项目的部署有多种方式，Jenkins,nginx等方式，本文只讲解一下简单的shell脚本部署。 系统信息系统信息: CentOS Linux release 8.3.2011 x86_64Go version: go version go1.14.12 linux/amd64 几条命令的介绍nohupnohup命令的全称为no hang up不挂起，可以在系统后台不挂断的运行命令，退出终端后程序也会正常运行。语法格式：nohup ./xxx &gt; xxx.log 2&gt;&amp;1 &amp;解释：&gt; xxx.log表示将输出重定向至该文件，可以记录运行时的日志2&gt;&amp;1将标准错误2重定向到标准输出&amp;1，然后标准输出&amp;1再被重定向至xxx.log文件 git pullgit pull origin dev为了方便项目的及时更新，使用改名了保证运行时与上游仓库的代码保持一致。 psps命令为 process status,可以查看系统当前的进程状态 例如 123456~&gt; ps PID TTY TIME CMD 255873 pts/0 00:00:02 zsh 258517 pts/0 00:00:00 sh 258519 pts/0 00:00:00 OnlineJudge 263021 pts/0 00:00:00 ps 我们将用ps命令与grep等命令筛选出项目的pidps命令有很多参数选择，这里介绍一下用到的两条命令: 12ps -e 列出所有进程ps -f 显示进程的全部信息 grepgrep命令可以查找文本中符合条件的字符串，用于匹配进程的名称，还可以匹配文本中的各种信息，本文不再具体展开，后续打算更一篇具体记录Linux命令的博客。 awk用于处理文本提取信息，将使用grep查询到的进程信息提取出pid查询到的结果为root 263948 263946 0 12:49 pts/0 00:00:00 ./OnlineJudge我们只需要第二项的pid，使用awk {print $2}即可提取出进程的pid 263948 killkill pid杀死进程 Shell脚本1234567891011121314echo -e &quot;*** Online_Judge ***\\n&quot;echo -e &quot;*** 检查上游代码中 ***\\n&quot;git pull origin devecho -e &quot;*** 编译中 ***\\n&quot;go buildchmod -R 777 OnlineJudgepid=`ps -ef|grep OnlineJudge|grep -v grep|awk '{print $2}'`echo -e &quot;$pid\\n&quot;kill $pid &amp;&amp; nohup ./OnlineJudge &gt; OnlineJudge.log 2&gt;&amp;1 &amp;pid2=`ps -ef|grep OnlineJudge|grep -v grep|awk '{print $2}'`echo -e &quot;项目部署成功***进程ID为:$pid2&quot; 将脚本保存至项目目录，赋予执行权限chmod +x setup.sh执行脚本 1234567891011121314151617181920➜ git:(dev) ✗ ./setup.sh *** Online_Judge ****** 检查上游代码中 ***From url * branch dev -&gt; FETCH_HEADAlready up to date.*** 编译中 ****** 添加权限 ***添加权限成功*** kill进程 ***258519./setup.sh: line 18: 258519 Terminated nohup ./OnlineJudge &gt; OnlineJudge.log 2&gt;&amp;1项目部署成功***进程ID为:263948 至此项目即可部署成功上述shell中的视个人情况而修改 ReferenceLinux命令大全如何优雅的通过Shell脚本一键部署GO项目到服务器？","link":"/2021/03/30/godeploy/"},{"title":"Git学习笔记","text":"对于git，很早很早就在用了，但是还没有系统整理过，并且有些命令使用时需要注意的事项，在此也一并标出。 About Gitgit是一个分布式版本控制工具，如果你是一个程序猿，那你必须要学会如何使用git来管理你的代码或者项目。可能更多人所熟知的是GitHub，顾名思义，按照英语的命名特点，GitHub就是所有git上传的枢纽，汇聚到一起，你可以开源你的代码，指定一款开源协议共享给所有需要的人，也可以将仓库设为私有，只有自己或者受到邀请的人可见或者进行编辑。除了GitHub，世界上还有很多这种代码托管平台，比如国内的gitee,coding等，国外还有gitlab等平台提供代码托管服务。 Setup在一个目录中，你可以使用git init来初始化这个目录，git会把这个文件夹变为一个git目录， 12&gt; GitTest git initInitialized empty Git repository in /Users/username/GitTest/.git/ 使用git remote add origin {your repo url}即可添加远程的仓库地址。 Commit &amp;&amp; Push对于一个采用迭代式开发或者其他开发模式的项目来说，都避免不了后续对代码进行修改或者添加一些新的文件，对于每一次这样的操作，都要对添加或者修改的文件指定一个commit。例如：修改了项目功能中的bug，文件名字为a.cpp可以使用 12git add a.cppgit commit -m &quot;fix: the bug in xxx&quot; 这样就可以将此次更改添加到提交的队列中如果使用git add .，git将添加所有监控的文件到缓冲区再使用git push就可以将修改添加到远程仓库中 对与一个团队而言，有标准规范的commit格式是很重要的，例如以下格式 12345feat: 新功能featurefix: 解决bugadd: 添加模块update: 更新模块... 等等 Dangerous Pull ing如果是多人协作开发，那么必然会导致本地文件之间存在着不一致，为了解决这个问题，可以使用git pull，执行该命令后将同步仓库中存在并且与本地不同的文件。这个操作看似简单，但是有时候如果使用了–force强制执行的话，会覆盖掉本地的文件，属于非常危险的操作，所以无论在什么时候使用–force之前都要思考清楚自己在干什么。 Branch我觉得git很强大的一个功能就是对分支的管理，在不同分支中切换可以让项目的代码得到更有效的管理，例如在main主分支中保存可以稳定运行的版本，在另一个dev分支中保存正在开发的非稳定版，后续改进之后可以将dev分支合并到main分支中去。如果更新过后的主分支依然出现问题，也是可以通过回滚的方式回到之前某个稳定的版本。分支的创建也非常简单 12git branch namegit checkout name 切换后git所有的操作将在新的分支进行 .gitignore顾名思义，肯定是让git去忽略某些项目，比如文件夹，或者是单个文件，添加到gitignore之后git将不在追踪这些文件的变化，因此我们可以将例如npm庞大的node_modules这种文件夹添加到其中，或者是编译器调试产生的临时文件，优化仓库的存储结构。 1git status 使用该命令看查目前项目的改动 123456On branch devUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) b.cppnothing added to commit but untracked files present (use &quot;git add&quot; to track) git监控到了文件b.cpp的产生，我们将b.cpp添加到.gitignore中 12On branch devnothing to commit, working tree clean 再次使用git status看查，发现b.cpp已经不再被监控了，在.gitignore中还可以使用文件夹名忽略整个文件夹的项目，或者使用通配忽略包含特定后缀名的文件等。 End随着开发工具的现代化，很多时候我们已经用不到这些git命令了，很多繁琐的命令早已被图形化的界面取代，但不乏还有git爱好者们做出的努力，如lazygit等工具。当你接收一台崭新的服务器时，这些命令又显得格为重要了。因此，在简便的工具的包裹下，他们背后的原理才是最值得我们去了解的，就如同学习汇编语言一样，给力我们另一种看待程序的方式。很早就像总结一下git了，拖了这么久终于写完了，后续还想再添加一些更具体的内容，希望能给初入git的同学一些启发。","link":"/2021/04/02/GitNote/"},{"title":"OJ部署debug记录","text":"学校重构之后的OJ终于进入了前后端对接的阶段，经过了一周的紧张对接环境，项目依然是(正在稳定推进的阶段)，和前端对接口的一周里，我感觉到自己之前工作的不足，在此做出反思，以后要改掉这些错误。同时在和运维一起部署的过程中，也发现了许许多多的问题，在此一并记录一下。 Access to Judger Ana In Docker因为OJ要防止恶意代码的提交，解决办法就是使用docker，为了让评测机稳定于是又要在docker里跑一个docker。直接docker run评测机，用了一下judge_test的模块，发现返回的结果全是AC，这就非常奇怪了。问了一下hr发现ana是用grpc通信的，好，没有学过，于是开始看怎么测试grpc是否正常，初步定位问题是没接上。也去docker里配了一下环境，加了工作目录，放行端口，发现还是不行。当hr进入服务器的时候，才发现真正的问题所在。直接docker pull的时候是跑的master分支的镜像，而新评测机接口是在另一个分支的。于是把锅甩给了嘎嘎豪。 NPM throw error后端采用了go语言的gin+gorm框架搭建，直接go build然后丢到后台守护进程，前端使用了vue框架，要先用npm build一下，但是我本意是想直接npm run serve的，无奈npm一直疯狂报错。最初我也是打算现在本地run serve然后只测试后台的，但是npm先是依赖问题没有解决，最后重装了全局的依赖之后发现报错有个字段为darwin-arm64，看到这个我就感觉不对劲，可能是M1芯片没有合适的包可以下载，于是才决定丢到服务器上。在服务器上也是遇到了依赖的问题，直接尝试删除所有包，包括全局包，发现一个报错，大概就是说npm要没钱了，快来funding，好家伙，我直接npm uninstall * --no-fund删除了所有依赖，然后重新npm install，跑完之后在此run serve，显然还是不行，问了王哥之后他给出了一个解决办法，先build然后用nginx反代到build之后生成的dist文件夹中。于是开始build，很不错，这回没有报错。于是开始了nginx反代。 Nginx服务器没有绑定域名，因此直接将服务器的某个端口直接映射到前端渲染出来的dist文件夹中去，需要现在安全组放行端口，这里就不得不提一下宝塔界面了，最初接触服务器的时候感觉宝塔确实很方便，今天运维也吐槽了一下，有些地方宝塔反而做复杂了，我就感觉上传或者下载文件比较方便，懒得用ftp。还不得不提yum包管理器是我用过最难用的，不如pacman，也没apt包全，但是总不能在服务器上跑arch吧 Orz。在宝塔上装了Nginx，开始做反代。先是监听一下888端口,并反代/请求到dist文件夹,设置首页为index.html 123456server { listen 888; index index.html index.htm index.php; root /root/dev/OnlineJudge/front_end/dist;} 好，重载一下nginx的配。咦，发现403 forbidden，运维猜测是nginx没有权限访问那个目录。这就开始打算直接chmod 777了，仔细一看发现，没改nginx配置里的user。 1user root root; 正常情况下建议分一个用户单独给nginx。然后发现访问首页是空白内容，打开F12看看，发现是js和css的请求全阻塞了，又去看了一眼nginx的配置，发现正则匹配的js和css文件目录不对。 123456789 location ~ .*\\.js?${ root /root/dev/OnlineJudge/front_end/dist;}location ~ .*\\.css?${ root /root/dev/OnlineJudge/front_end/dist;} 这里要注意，一开始我是分别代理到/dist/js和/dist/css文件夹的，这样是不对的，因为请求的uri里是带有js和css字段的，于是就造成了路径不对，成了/js/js/**。至此，首页可以成功进入了。开始测试喜闻乐见的登录环节，发现请求没发出去，前端的请求之前是发送到远程服务器的，现在应该是访问本机localhost，于是进行代理转发请求 1234location /api{ proxy_pass http://127.0.0.1:5000;} 终于可以登录了。到了八点多，感觉要下班了，又发现后台登录不进去了，又发现是只有我自己的chrome登录不进去，看日志的报错是interface提取的时候出问题了，uint和int之间产生了冲突，但是感觉事情没有那么简单，定位到出错的代码之后，发现异常是用_接收的，于是又对id打了log，再次运行。这个id怎么这么熟悉。原来是前端的session里的id，看来是因为前台后台共用了session，导致id混用了。 End此时已经到了晚上八点多了，看似已经解决了不少bug，但是很多问题都是和OJ无关的配置问题，真正的debug才刚刚开始。 项目正在稳定的向前推进。","link":"/2021/04/03/debugnote/"},{"title":"三种插值方法及实现","text":"插值方法插值属于数值分析领域中的一种方法，是一种通过已知的离散的数据点，来拟合原函数根据给定的自变量估算因变量的方法。常用的插值方法有很多，本文章给出三种常见的插值方法的实现。使用语言: Python 线性插值线性插值及求一次多项式$p(x)$，满足$p(x_0), p(x_1) = y_1$可以根据点斜式方程求解即 $p(x) =y_0 \\frac{y_{1}-y_{0}}{x_1-x_0}(x-x_0)$还可以将公式整理成如下形式 $p(x) = y_0 \\frac{x - x_1}{x_0 - x_1} + y_1 \\frac{x- x_0}{x_1 - x_0}$ 我们令这里的$l_0(x)=\\frac{x-x_1}{x_0 - x_1}, l_1(x)=\\frac{x-x_0}{x_1-x_0}$ 将其线性组合之后即为 $p(x)=y_0 l_0(x)+y_1 l_1(x)$ 是Lagrange插值的特殊形式此处给出线性插值的代码实现： 1234567891011121314151617import numpy as npdef linear(x, y, x0): ''' x : 为横坐标数组 y : 为纵坐标数组 x0: 为需要预测点的横坐标 res: 预测结果 ''' res = y[1] + (y[1] - y[0])*(x0 - x[1])/(x[1] - x[0]) // 根据公式计算结果 return resx = np.array([0.5, 0.6])y = np.array([-0.6931, -0.5108])answer = linear(x, y, 1)print(np.around(answer, 4)) // 保留四位小数 Largrange插值根据Lagrange插值基函数$l_k(x)$，其满足如下性质当$i=k,l_k(x_i)=1$ 当$i\\not ={k}, l_k(x_i) = 0$ 其中$l_k(x) = \\prod_{i=0,i \\not ={k}}^{n} \\frac{x-x_i}{x_k-x_i}$ 可以得到$p(x)=y_0 l_0(x) + y_1 l_1(x) + … + y_n l_n(x)$ $p(x)$满足$p(x_i)=y_i, i = 0,1,…,n$ 即根据插值结点确定的方程，可以使得$p(x_i)=y_i$，是一种可行的插值方法，极大的提高了插值精度。 并且当只有两个插值结点时，Lagrange插值就退化成了线性插值，当有三个结点时，退化成抛物线插值。 12345678910111213141516171819202122232425import numpy as npfrom matplotlib import pyplot as pltdef largrange(x, y, x0): ''' x : x数组 y : y数组 x0: 预测点横坐标 res: 预测结果 ''' n = len(x) res = 0 for i in range(n): param = np.append(x[:i], x[(i+1):]) // 获得除去xi的所有横坐标 numerator = (x0 - param).prod() // 分子，使用prod求出矩阵中所有元素的积 denominator = (x[i] - param).prod() // 计算分母 res += y[i]*numerator/denominator // 根据公式计算当前步骤对答案的贡献 return resx = np.array([0.5, 0.6, 0.4, 0.7])y = np.array([-0.6931, -0.5108, -0.9163, -0.3567])answer = largrange(x, y, 1)print(np.around(answer, 4)) Newton插值我们引入差商的概念，设有函数$f(x), x_0,…,x_n$ $f[x_i, x_j] = \\frac{f(x_j)-f(x_i)}{x_j - x_i}$ 称为$f(x)$关于点$x_i, x_j$的一阶差商 $f[x_i, x_j, x_k] = \\frac{f[x_j, x_k] - f[x_i, x_j]}{x_k - x_i}$ 称为$f(x)$关于点$x_i， x_j， x_k$二阶差商 我们可以得到差商的一般定义，对于k阶差商 $f[x_0, x_1, …, x_k] = \\frac{f[x_1, …, x_k] - f[x_0, …, x_{k-1}]}{x_k - x_0}$计算差商可以通过差商表来计算 $x_i$ $f(x_i)$ 一阶差商 二阶差商 三阶差商 … n阶差商 $x_0$ $f(x_0)$ $x_1$ $f(x_1)$ $f[x_0, x_1]$ $x_2$ $f(x_2)$ $f[x_1, x_2]$ $f[x_0, x_1, x_2]$ $x_3$ $f(x_3)$ $f[x_2, x_3]$ $f[x_1, x_2, x_3]$ $f[x_0, x_1, x_2, x_3]$ … … … … … … $x_n$ $f(x_n)$ $f[x_{n-1}, x_{n}]$ $f[x_{n-2}, x_{n-1}, x_{n}]$ $f[x_{n-3}, x_{n-2}, x_{n-1}, x_{n}]$ $f[x_0, x_1, …, x_n]$ 将对角线上的差商值用来构造插值函数 $f(x) = f(x_0) + f[x_0, x_1](x- x_0) + f[x_0, x_1, x_2](x - x_0)(x - x_1) + … + f[x_0, …, x_n](x - x_0)…(x - x_{n-1}) + f[x,x_0,x_1,x_2,…,x_n](x - x_0)…(x - x_{n})$ 其中$R(x) = f[x,x_0,x_1,x_2,…,x_n](x - x_0)…(x - x_{n})$为插值余项 综上，牛顿插值的最终表达式为 $R(x) = N(x)+R(x)$ 123456789101112131415161718192021222324252627282930313233import numpy as npdef GetColumRes(arr, j): n = len(arr[:,0]) colum = np.zeros(n) for i in range(j-1, n): colum[i] = (arr[i, j-1] - arr[i-1, j-1])/(arr[i, 0] - arr[i-j+1, 0]) return columdef CalculateDividedDiffernces(x, y): n = len(x) arr = np.zeros((n, n+1)) arr[0:n, 0] = x arr[0:n, 1] = y for i in range(2, n+1): arr[:, i] = GetColumRes(arr, i) print(arr) return arrdef newton(x, y, x0): res = y[0] n = len(x) factor = 1 DD = CalculateDividedDiffernces(x, y) for i in range(1,n): factor *= (x0-x[i-1]) res += DD[i, i+1]*factor return resx = np.array([0.5, 0.6, 0.4, 0.7])y = np.array([-0.6931, -0.5108, -0.9163, -0.3567])answer = newton(x, y, 1)print(np.around(answer, 4))","link":"/2021/04/19/newtown/"},{"title":"数值积分方法","text":"数值积分应用背景：微积分的基本计算公式为经典的牛顿莱布尼茨公式，但是作为计算机来说，计算原函数等操作过于困难，因此需要其他方法进行优化，代替牛顿莱布尼茨公式进行计算，本文将分享两种求积公式及其代码实现。 使用语言： Python-Numpy 复化梯形的递推公式由梯形公式改进，将区间[a, b]等分为n个小区间$[x_i, x_{i+1}]$ $\\int_{a}^{b}f(x)dx=\\sum_{i=0}^{n-1}\\int_{x_i}^{x_{i+1}}f(x)dx\\approx \\frac{h_i}{2}[f(x_i)+f(x_{i+1})]$ 根据梯形公式化简为区间端点值组合 将求和公式展开，分离出左右端点 得到最终的化简结果 $T_n = \\frac{h}{2} [f(a)+2\\sum_{i=1}^{n-1}f(x_i)+f(b)]$ 但是该方法的步长太小的话会导致计算次数太大，步长太大又难以保证效率 采用区间不断对分的方法，取$n = 2^k$，反复使用复合求积公式 $T^{(k)}=\\frac{1}{2}T^{(k-1)}+\\frac{h_{k-1}}{2}\\sum_{i=0}^{2^{k-1}-1}f(a+ih_{k-1} + 0.5h_{k-1})$ 其中$h_{k-1} = \\frac{b-a}{2^{k-1}}$ Code 1234567891011121314151617181920212223242526272829import numpy as npdef f(x): return np.sin(x)def Calc(): eps = 1e-7 Flag = True l = 1.0 r = 2.0 h = r - l t1 = 1.0*(h/2)*(1+f(r)) t2 = 0.0 while Flag: sum = 0 x = l + h/2 while x &lt; r: sum += f(x) x += h t2 = t1/2 + h*sum/2 h /= 2.0 if abs(t2 - t1) &lt; abs(eps): Flag = False t1 = t2 res = t2 return resanswer = Calc()print(np.around(answer, 6)) Romberg 算法基于梯形递推公式，将上一级递推公式的结果进行线性组合，得到Simpson公式，再对Simpson公式结果进行线性组合得出Cotes公式结果，最后对Cotes公式线性组合得出Romberg算法的递推公式 该方法为Richardson外推法 $T_{m}^{(k)}=\\frac{4^m T_{m-1}^{(k+1)} - T_{m-1}^{(k)}}{4^m - 1}$ k为Romberg算法的阶数，Romberg算法具有收敛性，一般情况下我们取四阶 k = 3进行计算就可以满足精度要求 123456789101112131415161718192021222324252627282930import numpy as npdef f(x): return np.sin(x)# 计算梯形公式的结果def trapezcomp(l, r, k): h = (r - l)/k x = l Sum = f(x) for i in range(1, k): x += h Sum += 2*f(x) return (Sum + f(r))*h*0.5def romberg(x, y, n): ''' x : 积分下限 y : 积分上限 n : Romberg算法求解的阶数 ''' I = np.zeros((n, n)) for i in range(0, n): I[i, 0] = trapezcomp(x, y, 2**i) for j in range(0, i): I[i, j+1] = (4**(j+1)*I[i, j] - I[i-1, j])/(4**(j+1)-1) return I[n-1, n-1]answer = romberg(1.0, 2.0, 4)print(answer)","link":"/2021/04/23/integration/"},{"title":"常微分方程初值问题求解方法","text":"常微分方程初值问题常微分方程描述了不同变量之间的变化关系，通过该关系我们可以确定变量之间的具体函数关系，但是微分方程不一定总是可解的，并且有些求解起来相当困难。给出积分曲线初始位置的状态，求解需要预测点的状态，为常微分方程的初值问题，我们可以在求解微分方程即的情况下对结果做出复合精度要求的预测。 本文给出几种算法的原理与实现。 Euler方法及其改进从初始点开始，根据不同离散点的导数值对曲线进行预测，导数值可以通过对ODE的化简求解，做出一条折线图，最终曲线会逼近预测值。 该方法有明显的缺点就是在每一步做出抉择时，只考虑了当前的状态，并没有考虑后面的状态，因此必然会造成较大的误差，因此采用下一个结点的导数值进行修正。 123456789101112131415161718192021222324252627import numpy as npdef ode(x, y): return y - 2 * x / ydef f(x): return np.sqrt(1+2*x)def Euler(bound, start): h = 0.1 n = int(bound/h) x = np.zeros(n) y = np.zeros(n) sample = np.zeros(n) for i in range(0, n): x[i] = 0+i*h sample[i] = f(x[i]) y[0] = start for i in range(1, n): yp = y[i-1] + h*ode(x[i-1], y[i-1]) yc = y[i-1] + h*ode(x[i], yp) y[i] = (yp+yc)/2.0 return y, sampleanswer,sample = Euler(2, 1)print(answer)print(sample)","link":"/2021/04/23/ode/"},{"title":"迭代法求解线性方程组","text":"求解线性方程组在线性代数中，有一类经典问题，就是求解线性方程组，我们熟知的解法有高斯消元法，但是高斯消元法属于直接求解的方法，不适合编程计算，因此引入更适合计算机求解的迭代法。 Jacobi迭代法考虑线性方程组$Ax=b$ 用L和U分别表示严格下三角矩阵和严格上三角矩阵 可以利用迭代公式 $x^{k+1}=D^{-1}(b-(L+U)x^{k}))$ 进行迭代求解，可以通过精度控制迭代次数，还需要控制迭代是否收敛，不然迭代次数再多也无法求解。 迭代法需要给定解列向量的初值，因此初值的选取也很重要。 1234567891011121314151617import numpy as npdef Jacobi(A, B, N, x): D = np.diag(A) R = A - np.diagflat(D) # R = L + U print(R/D) for i in range(N): x = (B - np.dot(R, x))/D return xA = np.array([[1, 0.4, 0.4], [0.4, 1, 0.8], [0.4, 0.8, 1]] )B = np.array([1, 2, 3])x = np.array([1, 1, 1])answer = Jacobi(A, B, 30, x)print(answer) Gauss Seidel迭代法Gauss Seidel法使用了另一种迭代格式，获得了快的收敛速度 首先我们利用迭代求解的特性，新得到的值总会比老值更优，因此使用新值来进行迭代，即 $x^{k+1}=D^{-1}(b+Lx^{k+1}+Ux^k)$ 化简 $x^{k+1}=(D-L)^{-1}(Ux^k+b)$ 123456789101112131415161718192021import numpy as npdef GaussSeidel(A, B, N, x): # 下三角矩阵 L = np.tril(A) U = A - L D = np.diagflat(np.diag(A)) LL = L - D # x^{k+1} = (D + L)^-1 (b - Ux^{k}) print(np.dot(np.linalg.inv(D-LL), U)) for i in range(N): x = np.dot(np.linalg.inv(L), B - np.dot(U, x)) return xA = np.array([[1, 0.4, 0.4], [0.4, 1, 0.8], [0.4, 0.8, 1]])B = np.array([1, 2, 3])x = np.array([1, 1, 1])answer = GaussSeidel(A, B, 30, x)print(answer)","link":"/2021/04/25/matrix/"},{"title":"方程求根的迭代法","text":"迭代法求解方程的根求解方程的根，即$f(x)=0$的数值解等问题，对于经典的二次方程等函数我们可以直接进行求解，但是对于超越方程我们不能用常规方法进行求解。因此我们可以通过使用计算机实现某些求解算法进行计算。 选取样例 $f(x) =x^3 - x - 2$ $\\frac{dy}{dx} = 3x^2-1$ 求解$f(x)$在[1, 2]上的零点 二分法在高中数学课本我们就接触过二分法求函数零点，根据零点存在性定理，可以保证我们得到符合要求的一个根，但是该方法局限性太大，只能求解区间内的一个根。 大致流程如下 先确定要求解的区间[x, y]，然后不断对区间进行二分，根据精度要求判断根是否合法，再根据中点值与端点值的符号是否相同缩小二分范围。 $if \\ f(mid)\\times f(l) &gt; 0$ $let \\ l = mid$ $or \\ r = mid$ Code 123456789101112131415161718192021222324import numpy as npimport math as mdef f(x): return x**3-x-2def binary(x, y): res = 0 eps = 1e-3 h = 1e-3 l = x r = y while l &lt;= r: mid = (l+r)/2 if abs(f(mid)-0) &lt; eps: return mid if f(mid)*f(x) &gt; 0: l = mid else: r = mid return -1answer = binary(1.0, 2.0)print(np.around(answer, 4)) 运算结果为1.5215 牛顿迭代法牛顿迭代法的基本思想为将非线性方程线性化，选取一个初始点，做切线交与x轴一点，然后继续该操作，直到根收敛或者达到精度要求。 基本流程为 取任意的迭代初始值$x_0$ 计算 $x_1 = x_0 - \\frac{f(x_0)}{f’(x_0)}$ 判断收敛性：如果$|x_1 - x_0|&lt; \\epsilon \\ or |f(x_1)-0| &lt; \\epsilon$ 令$x_0 = x_1$，保存上一步结果，继续迭代 Code 123456789101112131415161718192021222324import numpy as npimport math as m# f(x) = x**3 - x - 2# df/dx = 3x**2 -1def df(x): return 3*x**2 - 1def f(x): return x**3 - x - 2def newton(x): eps = 1e-7 x0 = x x1 = x0 - f(x0)/df(x0) while abs(x1-x0) &gt; eps: t = x1 x1 = t - f(t)/df(t) x0 = t return x1answer = newton(1.0)print(np.around(answer, 4)) 运算结果为1.5214","link":"/2021/04/25/equtaion/"}],"tags":[{"name":"Math","slug":"Math","link":"/tags/Math/"},{"name":"ACM","slug":"ACM","link":"/tags/ACM/"},{"name":"数论","slug":"数论","link":"/tags/%E6%95%B0%E8%AE%BA/"},{"name":"Lucas定理","slug":"Lucas定理","link":"/tags/Lucas%E5%AE%9A%E7%90%86/"},{"name":"费马小定理","slug":"费马小定理","link":"/tags/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/"},{"name":"计算几何","slug":"计算几何","link":"/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"},{"name":"莫队","slug":"莫队","link":"/tags/%E8%8E%AB%E9%98%9F/"},{"name":"游记","slug":"游记","link":"/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"Note","slug":"Note","link":"/tags/Note/"},{"name":"计算机组成原理","slug":"计算机组成原理","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"汇编语言","slug":"汇编语言","link":"/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"Golang","slug":"Golang","link":"/tags/Golang/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"Numpy","slug":"Numpy","link":"/tags/Numpy/"}],"categories":[{"name":"ACM","slug":"ACM","link":"/categories/ACM/"},{"name":"数论","slug":"数论","link":"/categories/%E6%95%B0%E8%AE%BA/"},{"name":"ACM","slug":"数论/ACM","link":"/categories/%E6%95%B0%E8%AE%BA/ACM/"},{"name":"Note","slug":"Note","link":"/categories/Note/"},{"name":"Course Note","slug":"Course-Note","link":"/categories/Course-Note/"},{"name":"Notes","slug":"Notes","link":"/categories/Notes/"},{"name":"Web","slug":"Web","link":"/categories/Web/"},{"name":"Math","slug":"Math","link":"/categories/Math/"}]}