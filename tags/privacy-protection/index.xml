<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Privacy Protection on Coding_Panda&#39;s Blog</title>
        <link>https://blog.ipandai.club/tags/privacy-protection/</link>
        <description>Recent content in Privacy Protection on Coding_Panda&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Sun, 04 Sep 2022 14:11:46 +0800</lastBuildDate><atom:link href="https://blog.ipandai.club/tags/privacy-protection/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Homomorphic Encryption Security Standard</title>
        <link>https://blog.ipandai.club/p/homomorphic-encryption-security-standard/</link>
        <pubDate>Sun, 04 Sep 2022 14:11:46 +0800</pubDate>
        
        <guid>https://blog.ipandai.club/p/homomorphic-encryption-security-standard/</guid>
        <description>&lt;p&gt;此篇搁置了好几天了，网挑复赛耽误了一段时间&lt;/p&gt;
&lt;h1 id=&#34;0x00-standardize&#34;&gt;0x00 Standardize&lt;/h1&gt;
&lt;h2 id=&#34;1-notation-and-definition&#34;&gt;1. Notation and definition&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;${\rm ParamGen}(\lambda,PT,K,B)\to {\rm Params}$&lt;/p&gt;
&lt;p&gt;​	将参数实例化&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$\lambda$代表需要的安全等级，128-bit安全性或256-bit安全性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$PT$表示明文空间，目前指定了两种参数明文空间&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(MI) Modular Integer，确定了明文空间的大小，例如$Z_p, p=1024$表示每个信息空间的元素都在$(0,1023)$范围中并且对所有元素的操作都要对p取模。&lt;/li&gt;
&lt;li&gt;(EX) Extension Ring/Fields 由模数$p$和$Z_p$上的多项式$f(x)$确定，指定了明文空间$\frac{Z[x]}{(p,f(x))}$，每个信息空间的元素都是一个度数小于$f(x)$整数多项式，系数在范围$(0,p-1)$之间，并且所有对单个元素的操作都是$mod \ f(x)$和$mod \ p$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$K$表示被加密向量的维数。例如$K=100$，$PT=(M1,1024)$表示将要被加密的信息是向量$(V_1,&amp;hellip;,V_K)$，每个$V_i\in(0,1023)$并且执行Component-wise操作（对向量的每一个分量进行操作并得到一个新的向量）。根据定义，$(V_1,&amp;hellip;,V_K)+(V_1^\prime,&amp;hellip;,V_K^\prime)=(V_1+V_1^\prime,&amp;hellip;,V_K+V_K^\prime)$，乘法操作类似，所有向量的空间称为消息空间message space MS&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$B$表示需要程序和电路的复杂性，越小则说明程序越简单，可以处理的范围也就越小；越大则加密支持更多复杂的操作，同时需要更复杂的处理程序&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;${\rm PubKeygen(Params)\to SK,PK,EK}$&lt;/p&gt;
&lt;p&gt;生成一组私钥和公钥，这两个概念比较熟悉。要注意EK，Evaluation Key，用于在密文上执行同态操作时使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;${\rm SecKeygen(Params)\to SK,EK}$&lt;/p&gt;
&lt;p&gt;生成一组私钥和EK，SK会同时用于对数据进行加密和解密，EK同上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;${\rm PubEncrypt(PK,M)\to C}$&lt;/p&gt;
&lt;p&gt;通过公钥加密信息，生成密文。通常使用随机性保证安全性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;${\rm SecEncrypt(SK, M)\to C}$&lt;/p&gt;
&lt;p&gt;通过私钥加密信息，生成密文。通常使用随机性保证安全性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;${\rm Decrypt(SK, C)\to M}$&lt;/p&gt;
&lt;p&gt;通过私钥对密文进行解密，如果解密不能恢复消息可能会遇到&lt;code&gt;FAIL&lt;/code&gt;失败输出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;${\rm EvalAdd(Params,EK, C1,C2)\to C3}$&lt;/p&gt;
&lt;p&gt;有随机性，结合输入的EK，将密文C1、C2相加，输出密文C3&lt;/p&gt;
&lt;p&gt;保证有$(C1+C2)&lt;em&gt;{decryption}=C3&lt;/em&gt;{decryption}=M1+M2$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;${\rm EvalAddConst(Params, EK, C1, M2)\to C3}$&lt;/p&gt;
&lt;p&gt;同理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;${\rm EvalMult(Params, EK, C1,C2)\to C3}$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;${\rm EvalMultConst(Params, EK, C1,M2)\to C3}$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;${\rm Refresh(Params,flag,EK,C1)\to C2}$&lt;/p&gt;
&lt;p&gt;flag is one of &lt;code&gt;(Relinearize, ModSwitch, Bootstrap)&lt;/code&gt;，C1和C2都是同一个Message的密文，将同一消息的复杂密文转变为简单密文；Bootstrapping是将高噪声的密文转换为低噪声的密文；KeySwitch就是将A密钥的密文转换到B密钥&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;${\rm ValidityCheck(Params, EK, [C], COMP) \to flag}$&lt;/p&gt;
&lt;p&gt;密文数组&lt;code&gt;[C]&lt;/code&gt;，同态计算的程序被编码为完全串行执行的程序COMP，并输出一个布尔标志。当执行COMP所对应的同态计算输出的密文结果符合正确结果时，flag为1。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-defines-the-security-properties&#34;&gt;2. Defines the security properties&lt;/h2&gt;
&lt;h3 id=&#34;安全性&#34;&gt;安全性&lt;/h3&gt;
&lt;p&gt;得益于算法的随机性，同一消息的密文并不相同，即使攻击者拥有参数，EK，PK，可以计算加密出来的密文，在对密文进行对比的过程中有显著大于$\frac{1}{2}$的概率猜测失败，由同态加密的安全性来保证。因为密文中没有显示有关消息的信息。&lt;/p&gt;
&lt;h3 id=&#34;compactness&#34;&gt;Compactness&lt;/h3&gt;
&lt;p&gt;保证密文上的同态操作不会扩大密文的长度&lt;/p&gt;
&lt;h3 id=&#34;efficient-decryption&#34;&gt;Efficient Decryption&lt;/h3&gt;
&lt;p&gt;同态加密方案的解密运行时间不依赖于密文对应的计算函数&lt;/p&gt;
&lt;h2 id=&#34;3-describes-the-bgv--bfv-scheme&#34;&gt;3. Describes the BGV &amp;amp;&amp;amp; BFV scheme&lt;/h2&gt;
&lt;h3 id=&#34;a-bgv&#34;&gt;(a) BGV&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;${\rm ParamGen}(\lambda,PT,K,B)\to {\rm Params}$&lt;/p&gt;
&lt;p&gt;lambda是安全参数&lt;/p&gt;
&lt;p&gt;K是整数数组的长度&lt;/p&gt;
&lt;p&gt;PT是明文空间类型MI/EX&lt;/p&gt;
&lt;p&gt;参数B表示同态计算可以执行的最大乘法深度&lt;/p&gt;
&lt;p&gt;在基础的BGV中，Params包括密文模数q和环$R=\frac{Z[x]}{f(x)}$，相应的明文环$\frac{R}{pR}$，参数还确定了R上的key分布$D_1$和误差分布$D_2$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;${\rm PubKeygen(Params)\to SK,PK,EK}$&lt;/p&gt;
&lt;p&gt;首先运行SecKeygen，从环$\frac{R}{qR}$中选取一个元素$a$并输出一组环元素组成的公钥PK，$(pk_0,pk_1)=(-a,as+pe)$，e是从误差分布$D_2$中选取的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;${\rm SecKeygen(Params)\to SK,EK}$&lt;/p&gt;
&lt;p&gt;BGV中，SK是从分布$D_1$选取的环R中的一个元素&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;${\rm PubEncrypt(PK,M)\to C}$&lt;/p&gt;
&lt;p&gt;先将从明文空间的M映射到环$R/pR$上的元素$\hat{M}$，公钥PK是一组元素$(pk_0,pk_1)$。从分布D1中采样三个元素u并从误差分布D2中采样两个元素e1和e2，输出一组环元素$(c_0,c_1)=(pk_0u+pe_1,pk_1u+pe_2+\hat{M})$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;${\rm SecEncrypt(SK, M)\to C}$&lt;/p&gt;
&lt;p&gt;首先将明文信息M映射到环$R/pR$上的元素$\hat{M}$，随后在环$R/qR$上采样一个随机均匀的元素$a$，并输出一组环元素$(c_0,c_1)=(-a,as+pe+\hat{M})$，e从误差分布D2种选取。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;${\rm Decrypt(SK, C)\to M}$&lt;/p&gt;
&lt;p&gt;通过同态评估，密文可能有更多的环元素，此时需要调整解密算法去处理相应的密文&lt;/p&gt;
&lt;p&gt;解密时先计算$R/qR$上的环元素$c_0s+c_1$，并将其称为环R中的元素$c^\prime$，然后再mod p的到结果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;${\rm EvalAdd(Params,EK, C1,C2)\to C3}$&lt;/p&gt;
&lt;p&gt;在环$R/qR$中完成add&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;${\rm EvalMult(Params, EK, C1,C2)\to C3}$&lt;/p&gt;
&lt;p&gt;在环$R/qR$中完成mult&lt;/p&gt;
&lt;p&gt;有密文$C1=(c_{1,0},c_{1,1})$，$C2=(c_{2,0},c_{2,1})$&lt;/p&gt;
&lt;p&gt;output：
$$
C3=(c_{1,0}c_{2,0},c_{1,0}c_{2,1}+c_{1,1}c_{2,0},c_{1,1}c_{2,1})
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Comment&lt;/p&gt;
&lt;p&gt;还有一种加密的编码格式，二者之间可以进行无损转换，要求明文模数p和密文模数q互质&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Full BGV&lt;/p&gt;
&lt;p&gt;在基本的BGV中，密文会在执行Mult之后增加一个环元素，度数为d的多项式，Mult之后度数为d+1。&lt;/p&gt;
&lt;p&gt;在Full BGV中，增加了两个过程来缓解，&lt;code&gt;Key Switching&lt;/code&gt;或&lt;code&gt;Relinearization&lt;/code&gt;。通过flag=KeySwitch调用Refresh 子程序；另一个过程是模数切换，Modulus Switching or Modulus Reduction，通过flag=ModSwitch调用Refresh。支持这两个操作还需要加强密钥生成算法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-describes-the-gsw-scheme&#34;&gt;4. Describes the GSW scheme&lt;/h2&gt;
&lt;h2 id=&#34;5-some-alternative-schemes&#34;&gt;5. Some alternative schemes&lt;/h2&gt;
&lt;h2 id=&#34;6-describes-additional-features&#34;&gt;6. Describes additional features&lt;/h2&gt;
&lt;h1 id=&#34;0x01-recommends-parameter-choices-to-achieve-security&#34;&gt;0x01 Recommends parameter choices to achieve Security&lt;/h1&gt;
&lt;h2 id=&#34;1-hard-problem-the-lwe-and-rlwe-assumptions&#34;&gt;1. Hard Problem: the LWE and RLWE assumptions&lt;/h2&gt;
&lt;h2 id=&#34;2-lattice-attacks--estimated-running-times&#34;&gt;2. Lattice Attacks &amp;amp;&amp;amp; Estimated running times&lt;/h2&gt;
&lt;h2 id=&#34;3-the-arora-ge-attack-on-lwe&#34;&gt;3. The Arora-Ge attack on LWE&lt;/h2&gt;
&lt;h2 id=&#34;4-algebraic-on-rlwe&#34;&gt;4. Algebraic on RLWE&lt;/h2&gt;
&lt;h2 id=&#34;5-recommends-concrete-parameters-to-achieve-various-security-levels&#34;&gt;5. Recommends concrete parameters to achieve various security levels&lt;/h2&gt;
</description>
        </item>
        <item>
        <title>Homomorphic Encryption Learning Notes</title>
        <link>https://blog.ipandai.club/p/homomorphic-encryption-learning-notes/</link>
        <pubDate>Sun, 28 Aug 2022 23:41:33 +0800</pubDate>
        
        <guid>https://blog.ipandai.club/p/homomorphic-encryption-learning-notes/</guid>
        <description>&lt;h1 id=&#34;0x00-intro&#34;&gt;0x00 Intro&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Protecting Privacy through Homomorphic Encryption Part I&lt;/code&gt;读书笔记&lt;/p&gt;
&lt;h2 id=&#34;1-对称加密大战公钥同态加密&#34;&gt;1. 对称加密大战公钥同态加密&lt;/h2&gt;
&lt;p&gt;双方使用相同的key对数据进行加密解密，属于对称加密&lt;/p&gt;
&lt;p&gt;公钥同态加密（非对称加密）使用两个不同的key，使用公钥来对数据进行加密，使用私钥来对数据进行解密。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.ipandai.club/image-20220829152536970.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20220829152536970&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;二者的工作流程对比如上图所示&lt;/p&gt;
&lt;h2 id=&#34;2-参数与安全性的关系&#34;&gt;2. 参数与安全性的关系&lt;/h2&gt;
&lt;p&gt;对于同态加密，参数的选取影响着安全性以及明文的类型和可以进行的计算。&lt;/p&gt;
&lt;p&gt;同态加密目前最重要的两个参数为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;密文空间$n$，大致对应每个密文中整数的数量&lt;/li&gt;
&lt;li&gt;密文模数$q$，确定密文中每个整数的大小边界&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般来说，安全性随着$n$的增大而升高，随着$q$的增大而降低。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.ipandai.club/image-20220829153213946.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20220829153213946&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;$q$越大，在加密之后的密文上则可以执行更复杂的计算。&lt;/p&gt;
&lt;p&gt;加密方法最终都会对数据加噪声，只有当噪声$&amp;lt;q$时，才可以被解密。因此更大的q可以让我们执行更多的操作。&lt;/p&gt;
&lt;p&gt;基于格密码的同态加密，理论基础是$Learning  \ with  \ Errors (LWE)$问题难解性或者是他的变种问题$Ring \ Learning-with-Errors (RLWE)$。在适当的参数下，该问题对于经典计算机和量子计算机都很难解。&lt;/p&gt;
&lt;p&gt;对于参数的选取可以根据所需要的安全性去查阅安全文档。&lt;/p&gt;
&lt;p&gt;本文主要介绍了几种同态加密的方案以及特点。&lt;/p&gt;
&lt;h1 id=&#34;0x01-bgvbfv-encryption-scheme&#34;&gt;0x01 BGV，BFV Encryption Scheme&lt;/h1&gt;
&lt;p&gt;基于RLWE问题的难解性，两种模式都支持明文为整数组成的向量。&lt;/p&gt;
&lt;p&gt;加密包括的参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;明文模数$p$&lt;/li&gt;
&lt;li&gt;密文模数$q$&lt;/li&gt;
&lt;li&gt;密文维数$n$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;明文模数$p$决定了明文向量整数的上限，约束加密后的密文计算中的结果。&lt;/p&gt;
&lt;p&gt;密文模数$q$是决定方案的加密计算能力。BGV或者BFV加密模式的密文包含一个长度为$2n$的整数数组，值为$[0,q-1]$，前文提到过，模数越大，密文可以执行的操作就越多。&lt;/p&gt;
&lt;p&gt;对于给定的$q$，密文的维数$n$决定了加密等级，越高则安全性越高。同时，还影响明文向量的大小。一般而言明文向量的长度等于$n$。&lt;/p&gt;
&lt;h2 id=&#34;1--同态操作&#34;&gt;1.  同态操作&lt;/h2&gt;
&lt;p&gt;密文在操作时保留模数p，输出结果同样为密文。&lt;/p&gt;
&lt;p&gt;Ciphertext-Plaintext&lt;/p&gt;
&lt;p&gt;二元操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ciphertext-Ciphertext Addition&lt;/li&gt;
&lt;li&gt;Ciphertext-Plaintext Addition&lt;/li&gt;
&lt;li&gt;Ciphertext-Ciphertext Multiplication&lt;/li&gt;
&lt;li&gt;Ciphertext-Plaintext Multiplication&lt;/li&gt;
&lt;li&gt;Ciphertext-Ciphertext Subtraction&lt;/li&gt;
&lt;li&gt;Ciphertext-Plaintext Subtraction&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一元操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;向量旋转&lt;/li&gt;
&lt;li&gt;否定&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-参数选取&#34;&gt;2. 参数选取&lt;/h2&gt;
&lt;p&gt;明文模数$p$：决定明文数据的宽度，要保证在应用范围内足够大，不发生溢出，有些场景下需要溢出。&lt;/p&gt;
&lt;p&gt;密文模数$q$：主要由乘法深度决定，更高的深度需要更大的模数，并且运算时间也会增大。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;p&gt;对于密文$A,B,C,D$，乘法运算$(A*B)*(C*D)$优于$A*(B*(C*D))$，
前者的乘法深度较小，需要的密文模数小。&lt;/p&gt;
&lt;p&gt;密文维数$n$：查阅安全性文档中的参数表来选取，选取表格时许啊要了解密钥分发等实现细节。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-bgvbfv-hello-world&#34;&gt;3. BGV/BFV Hello World&lt;/h2&gt;
&lt;p&gt;一个简单的例子&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# set parameters&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;31&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;q&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;65537&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;# generate key&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;myPublicKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mySecretKey&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;generateBFVkey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;# encrypt data&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# each plaintext is a vector of 8 elements&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;encrypted_a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encrypt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;myPublicKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;11&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;11&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt; 
&lt;span class=&#34;n&#34;&gt;encrypted_b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encrypt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;myPublicKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;12&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;14&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;11&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;24&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt; 
&lt;span class=&#34;n&#34;&gt;excrypted_c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encrypt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;myPublicKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;15&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;13&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;encrypted_d&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;addCiphertexts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;myPublicKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encrypted_a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encrypted_b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# Encryption of vector [17, 18, 16, 11, 21, 5, 11, 4]&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;# Maybe we want to multiply the result by the 3rd ciphertext. &lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;encrypted_e&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;multiplyCiphertexts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;myPublicKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encrypted_c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encrypted_d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# Encryption of vector [3, 25, 23, 19, 2, 15, 22, 4]&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# encrypted_c * encrypted_d % p&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;# Then rotate by 2 to the right&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;encrypted_f&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rotateBy2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;myPublicKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encrypted_e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# To actually see the final result we have to use the key. &lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;decrypted&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;decrypt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mySecretKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encrypted_f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;decrypted&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# This should print [22, 4, 3, 25, 23, 19, 2, 15]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;4-further-information&#34;&gt;4. Further Information&lt;/h2&gt;
&lt;h3 id=&#34;41-维护操作&#34;&gt;4.1 维护操作&lt;/h3&gt;
&lt;p&gt;BGV和BFV期望在执行操作时对隐含的明文没有影响，但是由于实现原因有些时候还是需要的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ciphertext-Ciphertext 乘和循环向量旋转有副作用，需要用一个与操作前不同的密钥去解密结果。被称为key切换操作，存储新密钥到之前的密钥中。又被称为&lt;code&gt;relinearization&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Boot strapping，刷新一个密文，并降低其中的噪声来支持更多的操作，这个操作需要巨大的开销，一般不执行。&lt;/li&gt;
&lt;li&gt;Modules Switching，模数切换，在乘法操作之后。BGV应用较多，来控制密文的噪声级别。很少在BFV中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;42-估价key&#34;&gt;4.2 估价key&lt;/h3&gt;
&lt;p&gt;key切换操作需要评估器可以访问特殊的公共评估密钥，这些评估密钥有密钥拥有者生成。在&lt;code&gt;Ciphertext-Ciphertext Multiplication&lt;/code&gt;中，这些key被称为&lt;code&gt;relinearization keys&lt;/code&gt;，在&lt;code&gt;rotation&lt;/code&gt;中，被称为&lt;code&gt;rotation/Galois keys&lt;/code&gt;伽罗瓦。&lt;/p&gt;
&lt;h3 id=&#34;43-数据编码&#34;&gt;4.3 数据编码&lt;/h3&gt;
&lt;p&gt;在BGV和BFV操作之前，需要独立进行编码操作将原数据转换为加密方案可以识别的明文格式。因此在解密之后，还需要相应的解码器。&lt;/p&gt;
&lt;h3 id=&#34;44-数据移动操作&#34;&gt;4.4 数据移动操作&lt;/h3&gt;
&lt;p&gt;对于一些设定的参数p和n，自身的数据移动操作可能与循环旋转不同。&lt;/p&gt;
&lt;p&gt;理解：运算中可能需要去改变矩阵中数据的排列，因此而产生时间开销。行旋、列旋。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.shoup.net/papers/helib.pdf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;reference Algorithms in HElib&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;45-references-for-the-bfv-encryption-scheme&#34;&gt;4.5 References for the BFV Encryption Scheme&lt;/h3&gt;
&lt;p&gt;实践中常用BFV表示RNS残数系统中的大整数。&lt;/p&gt;
&lt;p&gt;与传统的多精度位置数相比，RNS有许多优势：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;RNS使用机器字大小的整数，比PNS快5-10倍&lt;/li&gt;
&lt;li&gt;RNS的运行时间随着整数大小线性变化&lt;/li&gt;
&lt;li&gt;RNS显著改善了内存局部性&lt;/li&gt;
&lt;li&gt;计算可以并行化，RNS支持高效的GPU/FPGA硬件实现&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;两种RNS变体为基于整数运算，基于整数和浮点数运算&lt;/p&gt;
&lt;p&gt;一些实现了BFV的开源库&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://gitlab.com/palisade/palisade-development/-/wikis/home&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;PALISADE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/tuneinsight/lattigo&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Lattigo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.microsoft.com/en-us/research/project/microsoft-seal/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Microsoft SEAL&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;46-references-for-the-bgv-encryption-scheme&#34;&gt;4.6 References for the BGV Encryption Scheme&lt;/h3&gt;
&lt;p&gt;也可以在RNS中表示大整数。&lt;/p&gt;
&lt;p&gt;在 HElib 和 PALISADE 库中实现&lt;/p&gt;
&lt;p&gt;BGV Bootstrapping参见其它论文&lt;/p&gt;
&lt;h1 id=&#34;0x02-ckks-encryption-scheme&#34;&gt;0x02 CKKS Encryption Scheme&lt;/h1&gt;
&lt;p&gt;安全性由RLWE问题的难解性保证&lt;/p&gt;
&lt;p&gt;明文是以浮点数表示的实数向量&lt;/p&gt;
&lt;p&gt;该方案原生支持定点数运算，使用SIMD方法&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SIMD：Single Instruction Multiple Data 单指令流多数据流，采用一个控制器来控制多个处理器，同时对一组数据中的每一个分别执行相同的操作，实现空间上的并行技术。&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/55327037&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;link&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;控制安全性和精度的参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小数位数$f$，决定了计算的准确程度&lt;/li&gt;
&lt;li&gt;密文模数 $q$&lt;/li&gt;
&lt;li&gt;密文维数$n$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设每个明文值都表示为二进制定点数，有$f$小数位。密文的$f$可以在执行&lt;code&gt;rescaling&lt;/code&gt;处理之后重新进行调整，是一个feature。密文模数$q$，决定加密计算能力的主要参数。&lt;/p&gt;
&lt;p&gt;CKKS的密文由长度为$2n$的整数数组对$q$取模。对于给定的$q$，密文的维数$n$决定了加密等级，越高则安全性越高。&lt;/p&gt;
&lt;p&gt;CKKS允许在单个密文中加密多个定点数。密文维度$n$还决定了明文向量的大小，即$n/2$。&lt;/p&gt;
&lt;h2 id=&#34;1-homomorphic-operations&#34;&gt;1. Homomorphic Operations&lt;/h2&gt;
&lt;p&gt;密文参与的运算结果都是输出密文&lt;/p&gt;
&lt;p&gt;二元操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ciphertext-Ciphertext Addition&lt;/li&gt;
&lt;li&gt;Ciphertext-Plaintext Addition&lt;/li&gt;
&lt;li&gt;Ciphertext-Ciphertext Multiplication&lt;/li&gt;
&lt;li&gt;Ciphertext-Plaintext Multiplication&lt;/li&gt;
&lt;li&gt;Ciphertext-Ciphertext Subtraction&lt;/li&gt;
&lt;li&gt;Ciphertext-Plaintext Subtraction&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一元操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;向量旋转&lt;/li&gt;
&lt;li&gt;否定&lt;/li&gt;
&lt;li&gt;Rescaling&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Rescaling总是遵循乘法运算，是一种将输入密文的缩放因子除以特定因子的一元运算。它控制同态计算过程中缩放因子的大小。重新缩放操作后，密码文本模数会减小，如果密文模量太小，则不允许进一步乘法。&lt;/p&gt;
&lt;h2 id=&#34;2-参数选取-1&#34;&gt;2. 参数选取&lt;/h2&gt;
&lt;p&gt;分数位数和支持深度是需要考虑的主要参数。如果电路深度不超过参数确定的边界，则可以对电路进行加密评估。&lt;/p&gt;
&lt;p&gt;定点数运算的两个主要问题是精度损失和溢出。密文在加密或者计算后存在固有误差，受到参数$f$的控制。$f$越大表示结果越准确，但是计算开销会增大，同时加密值的大小必须严格控制小于模数$q$，保证计算过程中不会溢出。&lt;/p&gt;
&lt;p&gt;最大密文模数$q$主要由待评估电路的乘法深度和精度参数$f$。&lt;/p&gt;
&lt;p&gt;更高的深度和高精度需要更大的密文模数，运算变慢。&lt;/p&gt;
&lt;p&gt;一种参见的优化技术是将计算任务表示为深度最小的电路。&lt;/p&gt;
&lt;p&gt;参照之前的ABCD例子。&lt;/p&gt;
&lt;p&gt;一旦$q$确定，通过查表获得较高安全性的$n$下界。&lt;/p&gt;
&lt;h2 id=&#34;3-ckks-hello-world&#34;&gt;3. CKKS Hello World&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# set paramters&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;q&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;65537&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 2位小数&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# Generate the keys for these parameters &lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;myPublicKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mySecretKey&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;generateCKKSkey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# Encrypt data, each plaintext is a vector of 4 elements &lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;encrypted_a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encrypt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;myPublicKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;1.53&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;11.53&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.02&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;3.32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt; 
&lt;span class=&#34;n&#34;&gt;encrypted_b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encrypt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;myPublicKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;12.29&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;7.52&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;14.47&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;11.01&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt; 
&lt;span class=&#34;n&#34;&gt;excrypted_c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encrypt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;myPublicKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;2.64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;10.78&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;15.30&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;13.34&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt; 
&lt;span class=&#34;c1&#34;&gt;# We have three ciphertexts now.&lt;/span&gt;


&lt;span class=&#34;c1&#34;&gt;# We want the sum of the first two.&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# Luckily we used homomorphic encryption, so we can actually. do this.&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;encrypted_d&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;addCiphertexts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;myPublicKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encrypted_a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encrypted_b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# encrypting the vector [13.82, -4.01, -14.45, 7.69]&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# Maybe we want to multiply the result by the 3rd ciphertext. &lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;encrypted_e&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;multiplyCiphertexts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;myPublicKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encrypted_c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encrypted_d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# encrypting the vector [36.48, -43.23, 221.09, 102.58]&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# Then rotate by 2 to the right&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;encrypted_f&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rotateBy2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;myPublicKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encrypted_e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# To actually see the final result, we have to use the key. &lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;decrypted&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;decrypt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mySecretKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encrypted_f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;decrypted&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# This should print [221.09, 102.58, 36.48, -43.23]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;4-further-information-1&#34;&gt;4. Further Information&lt;/h2&gt;
&lt;h3 id=&#34;41-数据编码&#34;&gt;4.1 数据编码&lt;/h3&gt;
&lt;p&gt;CKKS的编码会导致一些精度损失，因为明文向量必须首先乘缩放因子（参数由加密方案决定）来保证编码的精度足够。缩放后的向量 被转换为CKKS支持的明文格式。密文隐式存储可能在同态计算时改变的伸缩因子。&lt;/p&gt;
&lt;p&gt;解密后，需要相应的解码器。&lt;/p&gt;
&lt;p&gt;密文模数决定了底层编码明文部分的上限，以保证其正确解密。防止溢出。&lt;/p&gt;
&lt;h3 id=&#34;42-维护操作&#34;&gt;4.2 维护操作&lt;/h3&gt;
&lt;p&gt;类似上文&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ciphertext-Ciphertext 乘和循环向量旋转有副作用，需要用一个与操作前不同的密钥去解密结果。被称为key切换操作，存储新密钥到之前的密钥中。又被称为&lt;code&gt;relinearization&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Boot strapping，刷新一个密文，并提高其密文模数，来支持更多的操作，这个操作需要巨大的开销，一般不执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;43-估价key&#34;&gt;4.3 估价Key&lt;/h3&gt;
&lt;p&gt;密钥切换需要要求评估者可以访问特殊的公共评估密钥。评估密钥生成必须由密钥所有者完成。在Ciphertext-Ciphertext乘法的过程中，这些键通常被称为重新线性化键；在旋转的过程中，它们有时被称为旋转或伽罗瓦键。Bootstrapping操作同样需要这样的评估密钥。&lt;/p&gt;
&lt;h3 id=&#34;44-ckks相关实现&#34;&gt;4.4 CKKS相关实现&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;HEAAN/RNS-HEAAN&lt;/li&gt;
&lt;li&gt;HElib&lt;/li&gt;
&lt;li&gt;Lattigo&lt;/li&gt;
&lt;li&gt;MS SEAL&lt;/li&gt;
&lt;li&gt;PALISADE&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;0x03-dmfhew-and-cggitfhe-schemes&#34;&gt;0x03 DM(FHEW) And CGGI(TFHE) Schemes&lt;/h1&gt;
&lt;h2 id=&#34;1-basic&#34;&gt;1. Basic&lt;/h2&gt;
&lt;p&gt;基于RLEW问题。&lt;/p&gt;
&lt;p&gt;有两种模式，simple和advanced。simple模式在每个门操作后自动执行bootstrapping操作，提供评估电路的能力。simple模式很容易配置，只需要一个参数，尤其当电路已知时。advanced模式下，用户决定何时执行bootstrapping或者其他维护操作，可以永不执行bootstrapping。&lt;/p&gt;
&lt;p&gt;simple模式易于使用，只需生成或编译与应用程序相对应的小型布尔电路即可，并且在加密输入上对每个门进行评估。advanced模式可以提高性能。&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安全位数$\lambda$ (all modes)&lt;/li&gt;
&lt;li&gt;特定于密码文本的计算预算测量（advanced mode）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;安全参数的位数$\lambda$与其他加密方案中的密文模数和密文维数相关。simple模式下，所有参数只能从$\lambda$得出。&lt;/p&gt;
&lt;p&gt;在advanced模式下，计算预算与可以执行的同态操作数量相关，即在执行下一次bootstrapping之前可以执行的次数。&lt;/p&gt;
&lt;h2 id=&#34;2-homomorphic-operations&#34;&gt;2. Homomorphic Operations&lt;/h2&gt;
&lt;p&gt;Simple模式支持布尔电路，Advanced模式支持布尔电路，整数，定点数。&lt;/p&gt;
&lt;h3 id=&#34;simple-模式明文空间和操作&#34;&gt;Simple 模式明文空间和操作&lt;/h3&gt;
&lt;p&gt;明文都是布尔变量，主要操作为&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常量
&lt;ul&gt;
&lt;li&gt;ZERO/ONE&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一元门
&lt;ul&gt;
&lt;li&gt;NOT&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;二元门
&lt;ul&gt;
&lt;li&gt;AND/NAND&lt;/li&gt;
&lt;li&gt;OR/NOR&lt;/li&gt;
&lt;li&gt;XOR/XNOR&lt;/li&gt;
&lt;li&gt;ORNOT/ANDNOT&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;三元门
&lt;ul&gt;
&lt;li&gt;MUX 数据选择器&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;&#34; &gt;Majority/Minority&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上逻辑门中，输入和输出都只能是密文。&lt;/p&gt;
&lt;h3 id=&#34;dmcggi-hello-world-simple-mode&#34;&gt;DM/CGGI Hello World Simple Mode&lt;/h3&gt;
&lt;p&gt;lambda&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;k&#34;&gt;lambda&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;128&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# Generate the keys for these parameters &lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;myPublicKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mySecretKey&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;generateKeys&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;lambda&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# Encrypt data, each plaintext is a boolean value &lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;encrypted_a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encrypt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;myPublicKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
&lt;span class=&#34;n&#34;&gt;encrypted_b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encrypt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;myPublicKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
&lt;span class=&#34;n&#34;&gt;excrypted_c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encrypt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;myPublicKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# We have three ciphertexts now.&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# Compute the AND of the first two.&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;encrypted_AND&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;EvalGate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;“&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;AND&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;”&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;myPublicKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encrypted_a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encrypted_b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
&lt;span class=&#34;c1&#34;&gt;# Encryption of 1 AND 1 = 1&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# Maybe we want to compute OR of this with the 3rd ciphertext. &lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;encrypted_ANDOR&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;EvalGate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;“&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;OR&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;”&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;myPublicKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encrypted_AND&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encrypted_c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
&lt;span class=&#34;c1&#34;&gt;# Encryption of (1 AND 1) OR 0 = 1&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# To actually be able to see the final result we have to use the key.&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;decrypted&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;decrypt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mySecretKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encrypted_ANDOR&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;decrypted&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# This should print 1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;advanced-mode-明文空间和操作&#34;&gt;Advanced Mode 明文空间和操作&lt;/h3&gt;
&lt;p&gt;明文由定点数向量组成，有精度参数$\pm\alpha$&lt;/p&gt;
&lt;p&gt;只支持向量加和一些其他向量运算，不支持向量乘&lt;/p&gt;
&lt;p&gt;误差可以通过还原明文后四舍五入消除。&lt;/p&gt;
&lt;p&gt;主要三种运算：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;addition&lt;/li&gt;
&lt;li&gt;scaling&lt;/li&gt;
&lt;li&gt;rotation&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意scaling运算中，缩放倍数会影响误差的数量级&lt;/p&gt;
&lt;p&gt;rotation运算时，任何消失在向量右侧的系数都以相反的符号显示在左侧&lt;/p&gt;
&lt;p&gt;支持非线性操作，使用RGSW scheme（RLWE密文向量）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;外积&lt;/p&gt;
&lt;p&gt;给定加密线性变换$f$的RGSW密文和加密向量$x$的RLWE密文，获得$f(x)$的加密。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Blind Rotation&lt;/p&gt;
&lt;p&gt;给定RGSW加密$rot_k$和RLWE加密$x$的密文，得到$rot_k(x)$的RLWE加密，$k$依然是密文&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Private Selection（CMUX）&lt;/p&gt;
&lt;p&gt;给定加密了$c=0/1$的RGSW密文，两个加密了$x$和$y$的RLWE密文，获得RLWE加密的$c?x:y$，三目运算符。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;advanced-mode-cggi-hello-world&#34;&gt;Advanced Mode CGGI Hello World&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# set bits of security and noise rate&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;lambda&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;128&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;alpha&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ˆ&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;15&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# Generate the keys for these parameters&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;myPublicKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mySecretKey&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;generateKeys&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;lambda&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;alpha&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# encrypt each letter with RGSW&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;encrypted_x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;encryptRGSW&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;myPublicKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;encryptRGSW&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;myPublicKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;encryptRGSW&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;myPublicKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# the initial state values are trivial RLWE ciphertexts &lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RLWE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RLWE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RLWE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;0.5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;For&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;to&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;# evaluate each transition&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;newA&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CMux&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;encrypted_x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
  &lt;span class=&#34;n&#34;&gt;newB&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CMux&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;encrypted_x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
  &lt;span class=&#34;n&#34;&gt;newC&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CMux&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;encrypted_x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
  &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;newA&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;newB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;newC&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;EndFor&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# To actually see the final result, we have to use the key. &lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;decrypted&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;decrypt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mySecretKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;decrypted&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;3-further-infomation&#34;&gt;3. Further Infomation&lt;/h2&gt;
&lt;h3 id=&#34;scheme-switching&#34;&gt;scheme switching&lt;/h3&gt;
&lt;p&gt;在一些框架的实现中，CGGI支持不同加密方案的切换&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.ipandai.club/image-20220901145321222.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20220901145321222&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;difference-between-dm-and-cggi&#34;&gt;difference between DM and CGGI&lt;/h3&gt;
&lt;p&gt;CGGI支持simple和advanced模式，DM只支持simple模式&lt;/p&gt;
&lt;p&gt;simple模式中的主要区别是在bootstrapping中&lt;/p&gt;
&lt;h3 id=&#34;implementation&#34;&gt;implementation&lt;/h3&gt;
&lt;p&gt;基于CPU&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TFHE&lt;/li&gt;
&lt;li&gt;FHEW&lt;/li&gt;
&lt;li&gt;PALISADE&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于GPU&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cuFHE&lt;/li&gt;
&lt;li&gt;nuFHE&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;
&lt;p&gt;Part I主要介绍了几种全同态加密算法的特点和适用范围&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特征\加密模式&lt;/th&gt;
&lt;th&gt;BGV/BFV&lt;/th&gt;
&lt;th&gt;CKKS&lt;/th&gt;
&lt;th&gt;DM/CGGI&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;明文类型&lt;/td&gt;
&lt;td&gt;整数&lt;/td&gt;
&lt;td&gt;浮点数近似计算&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;支持的运算&lt;/td&gt;
&lt;td&gt;1. 密文明文间加减乘 2. 一元向量旋转，否定&lt;/td&gt;
&lt;td&gt;1. 密文明文间加减乘 2. 一元向量旋转，否定，缩放&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;参数&lt;/td&gt;
&lt;td&gt;明文模数$p$,密文模数$q$,密文维数$n$&lt;/td&gt;
&lt;td&gt;小数位数$f$,密文模数$q$,密文维数$n$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
        </item>
        
    </channel>
</rss>
