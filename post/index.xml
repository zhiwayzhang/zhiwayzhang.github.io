<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Coding_Panda&#39;s Blog</title>
    <link>https://ez4zzw.github.io/post/</link>
    <description>Recent content in Posts on Coding_Panda&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 17 Aug 2022 10:30:30 +0800</lastBuildDate><atom:link href="https://ez4zzw.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Flashshare: Punching Through Server Storage Stack from Kernel to Firmware for Ultra-Low Latency SSDs (OSDI&#39;19)</title>
      <link>https://ez4zzw.github.io/p/flashshare-punching-through-server-storage-stack-from-kernel-to-firmware-for-ultra-low-latency-ssds-osdi19/</link>
      <pubDate>Wed, 17 Aug 2022 10:30:30 +0800</pubDate>
      
      <guid>https://ez4zzw.github.io/p/flashshare-punching-through-server-storage-stack-from-kernel-to-firmware-for-ultra-low-latency-ssds-osdi19/</guid>
      <description>超低延迟固态硬盘从内核到固件的服务器存储堆栈
个别名词解释 the 99^th percentile 超过统计数据99%的数是多少
blk-mq Linux Multiqueue block layer 内核对ssd随机I/O的优化
message signaled interrupt (MSI)
1.摘要 flash share
在内核中，扩展了系统堆栈的数据结构，传递应用程序的属性（？），包括内核层到SSD固件。
对于给定的属性，FlashShare的块层管理IO调度并处理NVMe中断。
评估结果表明，FLASHSHARE可以将共同运行应用程序的平均周转响应时间分别缩短22%和31%。
1.0 Intro 1.1 现状 网络服务提供商，满足服务级别协议SLA，延迟敏感
某个段时间短可能有大量请求涌入，供应商会超额配置机器以满足SLA
现状：该场景并不常见，因此大部分情况下服务器的资源占用率非常低，能耗比低。
为了解决利用率低，服务器会运行离线的数据分析应用，延迟不敏感，以吞吐量为导向。
因此，在运行了多个进程的服务器上，I/O延迟增高，满足SLA非常困难。
现有的ULL SSD相较于NVMe SSD可以减少10倍的延迟
但是这些ULL SSD在同时运行多个进程下高强度压榨服务器的时候，不能充分利用ULL SSD的优势/表现一般。
the 99th percentile 是0.8ms（apache）
但是当服务器同时运行pagerank的时候，延迟会增加228.5%。
原因：略
从固件到内核优化堆栈的存储。
  内核级别的增强：
两个挑战
 Linux的blk-mq导致I/O请求队列化，引入延迟 NVMe的队列机制没有对I/O优先级的策略，因此，来自离线应用的IO请求容易阻塞在线应用的紧急请求，造成延迟。  对于latency critical的请求，绕过NVMe的请求队列。同时令NVMe的驱动通过知晓每个应用的延迟临界匹配NVMe的提交和请求队列。
  固件层设计：
  ​	即使内核级的优化保证了延迟敏感的请求可以获得高优先级，但如果基础固件不了解延迟临界值，ULL特性（类似内存的性能）无法完全暴露给用户。本文中重新设计了I/O调度和缓存的固件，以直接向用户暴露ULL特性。将ULL SSD的集成缓存进行分区，并根据工作负载的属性对每个I/O服务独立的分配缓存。固件动态的更新分区大小并以精细粒度调整预取I/O粒度。
 ULL SSD的新中断处理服务：  ​	当前的NVMe中断机制没有对ULL I/O服务优化。轮询方法（Linux 4.9.30）消耗了大量的CPU资源去检查I/O服务的完成情况。当轮询在线交互服务的IO请求完成状态时，flashShare使用一个仅对离线应用程序使用消息信号中断的选择性中断服务程序Select-ISR。</description>
    </item>
    
    <item>
      <title>并发编程</title>
      <link>https://ez4zzw.github.io/p/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Mon, 14 Mar 2022 10:22:18 +0800</pubDate>
      
      <guid>https://ez4zzw.github.io/p/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</guid>
      <description>三个基本方法：
 进程 IO多路复用 线程  </description>
    </item>
    
    <item>
      <title>计算机网络自顶向下</title>
      <link>https://ez4zzw.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/</link>
      <pubDate>Sat, 05 Mar 2022 10:32:46 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/</guid>
      <description>DNS 使用UDP 53端口
多路复用和多路分解 无连接运输UDP UDP无需建立连接，速度快
无连接状态，不需要维护序列号，可以支持更多用户活跃（游戏服务器）
首部只有8个字节，源端口号和目的端口号，长度和check sum
为什么需要checksum校验和：
 在路由器内存中可能有bit差错 链路传输不可靠  checksum最终为1111111&amp;hellip;则可能无差错
端到端原则：某种功能应该在较高级别提供，在较低级别上设置该功能可能会冗余
UDP只能检查错误，不能纠错
DNS服务采用UDP
何时UDP，何时TCP？
 不希望延迟报文的发送，TCP有拥塞控制机制，并容忍数据的丢失  可靠数据传输 差错检测
接收方反馈：
 ACK肯定确认 NAK否定确认  ACK 0接收成功，ACK 1接收失败
重传，收方发现差错，发送方重传
序号，检测哪个数据包出错进行重传
数据包可靠传输：
 在没有ack的情况下，等待一定的时间后进行重传 序号可以保证传输不冗余（接收方检测是否冗余）  发送方需要实现：
 没发送或者重传一个分组，启动定时器countdown timer 定时器过期后响应 终止定时器  流水线可靠传输协议：
 采用极小的数据包，接收方收到最后一bit立即ack  GBN协议（回退N步），滑动窗口协议 限制数据包的序号，直到相应序号ack之后再发送后续的序号，用长度为N的窗口控制。
GBN发送方：
 发送数据包时，检查发送窗口，未满则返回未发送的分组 收到ack后，对分组中的序号累积确认，表明接收方，正确接收到序号为n的分组以及以前的所有分组，[0, N] 超时，发送方重传所有未被确认的分组  接收方收到的分组都是有序的，如果出现无序，会丢弃后面的数据包，等待重传
选择重传 避免不必要的重传
发送方接收方都维护一个窗口
发送方：
 收到send base后窗口右移到第一个没确认的分组处 接收ack将窗口内分组标记为ack 定时器防止分组丢失  接收方：</description>
    </item>
    
    <item>
      <title>Redis设计与实现读书笔记</title>
      <link>https://ez4zzw.github.io/p/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 01 Mar 2022 16:11:42 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;p&gt;redis设计与实现&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go语言学习笔记</title>
      <link>https://ez4zzw.github.io/p/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 25 Jan 2022 20:14:16 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;p&gt;Go语言源码阅读与原理分析&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>【操作系统】虚拟内存</title>
      <link>https://ez4zzw.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</link>
      <pubDate>Tue, 18 Jan 2022 15:27:22 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</guid>
      <description>&lt;p&gt;虚拟内存提供了三个重要能力：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将主存看做是 存储在磁盘上地址空间的 高速缓存，主存按照需要在磁盘和主存中传递数据&lt;/li&gt;
&lt;li&gt;每个进程提供一致的地址空间，简化内存管理&lt;/li&gt;
&lt;li&gt;保护每个进程的地址空间不被其他进程破坏&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Mysql学习笔记</title>
      <link>https://ez4zzw.github.io/p/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 17 Jan 2022 23:16:08 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>基础知识 单进程多线程，线程之间共享内存
OLTP Online Transaction Processing 在线事务处理
InnoDB overview 特点：
 行级锁 支持外键 支持事务  MVCC并发控制，插入缓冲，二次写，自适应哈希索引，预读
四种隔离级别：
 REPEATABLE 默认  聚集方式保存数据，按主键顺序存放，没有主键则生成6字节的ROWID
后台线程  Master Thread 缓冲区数据异步更新到磁盘 IO Thread innodb使用异步IO，提高数据库性能，负责接受回调 Purge Thread 事务提交后回收undolog页 Page Cleaner Thread 脏页刷新  主要都是为了减轻Master的负担，提高性能，减少对用户查询线程的阻塞
内存 用页管理记录
缓冲池：通过内存来弥补低速硬盘的影响，数据库读取页，从磁盘获取页放入缓冲池fix，读取时先判断缓冲区，命中后直接读取；修改时先修改缓冲池的页，然后通过checkpoint机制刷新到磁盘上。基本上和虚拟内存一样。
配置参数innodb_buffer_pool_size
数据页分类：索引页，数据页，undo页，插入缓冲，自适应哈希索引，innodb锁信息，数据字典信息等
允许有多个缓冲池
内存管理 LRU List 频繁使用的在列表前，不频繁的在列表后，先释放尾部的页
页默认大小16KB
innodb会把新读取的页放入midpoint位置，为列表长度的$$\frac{5}{8}$$，midpoint之后为old，之前为new，如果放在首部会导致某些sql导致缓冲池页被刷新，如全表扫描遍历全表。防止一条指令拖慢其他指令效率。
Free列表保存空闲页
MyISAM  表锁 全文索引 不支持事务  缓冲区只缓存索引文件，不缓冲数据
MYD保存数据，MYI保存索引文件
myisampack使用Huffman编码压缩MYD，压缩后只读</description>
    </item>
    
    <item>
      <title>图解HTTP读书笔记</title>
      <link>https://ez4zzw.github.io/p/%E5%9B%BE%E8%A7%A3http%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 16 Jan 2022 22:25:00 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/%E5%9B%BE%E8%A7%A3http%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;p&gt;图解HTTP读书笔记&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>【操作系统】异常控制流</title>
      <link>https://ez4zzw.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</link>
      <pubDate>Fri, 14 Jan 2022 10:12:15 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</guid>
      <description>&lt;p&gt;异常控制流&lt;/p&gt;
&lt;p&gt;CSAPP CH-8&lt;/p&gt;
&lt;p&gt;指令地址间的过度为控制转移，控制转移序列叫做控制流&lt;/p&gt;
&lt;p&gt;ECF Exceptional Control Flow 异常控制流是系统实现IO，进程和虚拟内存的基本机制&lt;/p&gt;
&lt;p&gt;ECF用于应用程序和操作系统的交互&lt;/p&gt;
&lt;p&gt;try catch等语句基于ECF&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>redis实战读书笔记</title>
      <link>https://ez4zzw.github.io/p/redis%E5%AE%9E%E6%88%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 03 Jan 2022 16:22:27 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/redis%E5%AE%9E%E6%88%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;p&gt;redis基础知识以及一些应用场景总结&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>【操作系统】网络编程</title>
      <link>https://ez4zzw.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Mon, 03 Jan 2022 13:37:02 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid>
      <description>&lt;p&gt;承接Unix I/O这一章节，了解网络如何构建以及客户端和服务器如何通信，socket函数相关内容的学习&lt;/p&gt;
&lt;p&gt;CSAPP Ch-11 笔记&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>【操作系统】系统级IO</title>
      <link>https://ez4zzw.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B3%BB%E7%BB%9F%E7%BA%A7io/</link>
      <pubDate>Mon, 03 Jan 2022 10:31:33 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B3%BB%E7%BB%9F%E7%BA%A7io/</guid>
      <description>&lt;p&gt;高级别的IO程序，如c中的printf和scanf，c++中的&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;，都依赖Unix 系统级IO&lt;/p&gt;
&lt;p&gt;CSAPP Ch-10 笔记&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>编译原理笔记</title>
      <link>https://ez4zzw.github.io/p/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 02 Jan 2022 10:33:48 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;p&gt;编译原理笔记，词法语法分析&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>【操作系统】程序的机器级表示</title>
      <link>https://ez4zzw.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</link>
      <pubDate>Fri, 10 Dec 2021 21:19:54 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</guid>
      <description>讲解机器代码以及汇编
TODO了，有个bomb lab</description>
    </item>
    
    <item>
      <title>【操作系统】信息的表示和处理</title>
      <link>https://ez4zzw.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</link>
      <pubDate>Fri, 10 Dec 2021 13:02:03 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</guid>
      <description>&lt;p&gt;本章为CSAPP Ch-2的读书笔记，复习了数据的存储方式&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>【算法题】幸运数字</title>
      <link>https://ez4zzw.github.io/p/%E7%AE%97%E6%B3%95%E9%A2%98%E5%B9%B8%E8%BF%90%E6%95%B0%E5%AD%97/</link>
      <pubDate>Fri, 10 Dec 2021 12:46:33 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/%E7%AE%97%E6%B3%95%E9%A2%98%E5%B9%B8%E8%BF%90%E6%95%B0%E5%AD%97/</guid>
      <description>&lt;h1 id=&#34;description&#34;&gt;Description&lt;/h1&gt;
&lt;p&gt;给定一个数字N，给定一个数字的集合，使用集合里的数字构造出小于数字N的最大数。&lt;/p&gt;
&lt;p&gt;如N = 23131，集合为{2, 4, 9}&lt;/p&gt;
&lt;p&gt;则构造出22999&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>【leetcode-179】最大数</title>
      <link>https://ez4zzw.github.io/p/leetcode-179%E6%9C%80%E5%A4%A7%E6%95%B0/</link>
      <pubDate>Thu, 09 Dec 2021 21:22:30 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/leetcode-179%E6%9C%80%E5%A4%A7%E6%95%B0/</guid>
      <description>&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode-cn.com/problems/largest-number/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://leetcode-cn.com/problems/largest-number/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;description&#34;&gt;Description&lt;/h1&gt;
&lt;p&gt;给定一组非负整数 &lt;code&gt;nums&lt;/code&gt;，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。&lt;/p&gt;
&lt;p&gt;注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>操作系统</title>
      <link>https://ez4zzw.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Thu, 09 Dec 2021 19:58:54 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid>
      <description>&lt;p&gt;CSAPP读书笔记 Ch-1 宏观看一看操作系统，很多知识之前确实没了解到，值得一读&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>127.0.0.1,localhost和0.0.0.0暨🐼一次两次的神神秘秘的debug记录</title>
      <link>https://ez4zzw.github.io/p/127.0.0.1localhost%E5%92%8C0.0.0.0%E6%9A%A8%E4%B8%80%E6%AC%A1%E4%B8%A4%E6%AC%A1%E7%9A%84%E7%A5%9E%E7%A5%9E%E7%A7%98%E7%A7%98%E7%9A%84debug%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Mon, 26 Jul 2021 22:23:38 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/127.0.0.1localhost%E5%92%8C0.0.0.0%E6%9A%A8%E4%B8%80%E6%AC%A1%E4%B8%A4%E6%AC%A1%E7%9A%84%E7%A5%9E%E7%A5%9E%E7%A7%98%E7%A7%98%E7%9A%84debug%E8%AE%B0%E5%BD%95/</guid>
      <description>前记 潘达某天在本机docker部署了他的服务，但是发现无论如何都无法ping通，他冥(疯)思(狂)苦(谷)想(歌)，逛遍了GitHub上的各种issues，stack overflow上的各种回答，各种博客文章，都没有解决他的问题，直到他的mentor来到他的电脑前，一通命令猛如虎啊，发现他竟然在docker内监听了容器中的127.0.0.1的端口，那必然会访问不到，检查发现原来是在服务的config中写了magic number，让服务开在了127.0.0.1，在本地这样必然是没问题的，但是如果要与外部进行通信，那就要改成0.0.0.0了。
又是一天，潘达又部署起了他的rpc服务，想在服务器上部署一个微服务然后本机去访问，测试框架是否可以通过域名通信各个微服务，然而，服务器上启动成功，本地依然迟迟无法连接，上来就是一个curl: (7) Failed to connect to ababab.ababab port ababa: Connection refused，安全组也放行了对应的端口，然后他看到了一行127.0.0.1，但是他感觉不是这个问题，继续debug，然后再次呼叫他的mentor，希望得到帮助，还是一顿操作猛如虎，找到了那个127.0.0.1的监听服务，乐。
于是，这篇blog就诞生了。 
127.0.0.1 和 localhost 127.0.0.1是回路地址中的一个，在计算机中127.*.*.*被称为回路地址，所有对这些地址的请求都会让本机接收，最最重要的是，外部设备也不能通过这个地址访问到本机的服务。 localhost其实是一个域名，他一般指代本机的网络，大多数机器都会默认localhost指向127.0.0.1，可以自行修改为其他地址。
0.0.0.0 可能我们都会以为localhost为本地的网络地址，但实际上真正的本地网络是0.0.0.0，但是他是不能被ping通的。在服务器中，0.0.0.0并不是一个真实的的IP地址，它表示本机中所有的ipv4地址。监听0.0.0.0的端口，就是监听本机中所有IP的端口。如果服务监听在0.0.0.0，那么外部访问的所有ip都可以通过对应的端口访问这个服务。
所以问题得到了解答，如果是在本机的话，127.0.0.1的话显然是没问题的，但是如果要将服务上云或者容器，就需要进行调整，首先要避开127.0.0.1，再根据是否只允许内网ip访问进行端口映射和服务监听。
后记 这两次问题前前后后折腾了半天，本想自己找到解决办法，查了不少资料后还是要寻求运维☁️的帮助，其实问题并不是很大，还是自己的知识储备不够，不能准确定位的问题的所在。另外，计网应该开始看了。🐼。</description>
    </item>
    
    <item>
      <title>Bilibili视频网站排行榜评分的线性回归分析</title>
      <link>https://ez4zzw.github.io/p/bilibili%E8%A7%86%E9%A2%91%E7%BD%91%E7%AB%99%E6%8E%92%E8%A1%8C%E6%A6%9C%E8%AF%84%E5%88%86%E7%9A%84%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 02 Jul 2021 14:05:48 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/bilibili%E8%A7%86%E9%A2%91%E7%BD%91%E7%AB%99%E6%8E%92%E8%A1%8C%E6%A6%9C%E8%AF%84%E5%88%86%E7%9A%84%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/</guid>
      <description>&lt;p&gt;Bilibili（哔哩哔哩）是当下最热门的视频播放网站，人们在该网站对视频进行浏览，会根据自己喜好对视频进行点赞、投币、收藏、分享、回复等操作，Bilibili同时还有一个排行榜机制，记录了近期比较热门的视频，并给出了一个评分，排行榜的排序规则即根据该评分，本文将根据这些排行榜视频的各项数据，进行线性回归分析，结合实际情况找出对评分影响最大的数据。&lt;/p&gt;
&lt;p&gt;Bilibili提供了获取排行榜数据的API，因此我们可以利用该API获取实时的排行榜数据，获取的数据为json格式，经过解析，已将数据保存至Bilibili.csv文件中。&lt;/p&gt;
&lt;p&gt;本文的思路即为多元线性回归，在统计学中，线性回归（linear regression）是利用称为线性回归方程的最小二乘函数对一个或多个自变量和因变量之间关系进行建模的一种回归分析。这种函数是一个或多个称为回归系数的模型参数的线性组合。只有一个自变量的情况称为简单回归，大于一个自变量情况的叫做多元回归（multivariable linear regression）。&lt;/p&gt;
&lt;p&gt;完成了对各个自变量权重的计算，找出了对评分影响权重最高的因素，并得到了验证。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>方程求根的迭代法</title>
      <link>https://ez4zzw.github.io/p/%E6%96%B9%E7%A8%8B%E6%B1%82%E6%A0%B9%E7%9A%84%E8%BF%AD%E4%BB%A3%E6%B3%95/</link>
      <pubDate>Sun, 25 Apr 2021 13:04:57 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/%E6%96%B9%E7%A8%8B%E6%B1%82%E6%A0%B9%E7%9A%84%E8%BF%AD%E4%BB%A3%E6%B3%95/</guid>
      <description>&lt;h1 id=&#34;迭代法求解方程的根&#34;&gt;迭代法求解方程的根&lt;/h1&gt;
&lt;p&gt;求解方程的根，即$f(x)=0$的数值解等问题，对于经典的二次方程等函数我们可以直接进行求解，但是对于超越方程我们不能用常规方法进行求解。因此我们可以通过使用计算机实现某些求解算法进行计算。&lt;/p&gt;
&lt;p&gt;选取样例&lt;/p&gt;
&lt;p&gt;$f(x) =x^3 - x - 2$&lt;/p&gt;
&lt;p&gt;$\frac{dy}{dx} = 3x^2-1$&lt;/p&gt;
&lt;p&gt;求解$f(x)$在[1, 2]上的零点&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>迭代法求解线性方程组</title>
      <link>https://ez4zzw.github.io/p/%E8%BF%AD%E4%BB%A3%E6%B3%95%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</link>
      <pubDate>Sun, 25 Apr 2021 00:38:16 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/%E8%BF%AD%E4%BB%A3%E6%B3%95%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</guid>
      <description>求解线性方程组 在线性代数中，有一类经典问题，就是求解线性方程组，我们熟知的解法有高斯消元法，但是高斯消元法属于直接求解的方法，不适合编程计算，因此引入更适合计算机求解的迭代法。
以线性方程组：
$ \left[ \begin{matrix} 10 &amp;amp; -1 &amp;amp; -2 \
-1 &amp;amp; 10 &amp;amp; -2 \
-1 &amp;amp; -1 &amp;amp; 5 \end{matrix} \right] x = \left[ \begin{matrix} 7.2 \
8.3 \
4.2 \end{matrix} \right] $ 为例
Jacobi迭代法 考虑线性方程组$Ax=b$
用L和U分别表示严格下三角矩阵和严格上三角矩阵
可以利用迭代公式
$x^{k+1}=D^{-1}(b-(L+U)x^{k}))$
进行迭代求解，可以通过精度控制迭代次数，还需要控制迭代是否收敛，不然迭代次数再多也无法求解。
迭代法需要给定解列向量的初值，因此初值的选取也很重要。
import numpy as np def Jacobi(A, B, N, x): # Ax=B N为迭代次数 # 获得对角矩阵的数组 D = np.diag(A) # 获得L+U矩阵，减去对角矩阵即可 # diagflat为D数组转为对角矩阵 R = A - np.</description>
    </item>
    
    <item>
      <title>常微分方程初值问题求解方法</title>
      <link>https://ez4zzw.github.io/p/%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%88%9D%E5%80%BC%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A3%E6%96%B9%E6%B3%95/</link>
      <pubDate>Fri, 23 Apr 2021 23:26:18 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%88%9D%E5%80%BC%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A3%E6%96%B9%E6%B3%95/</guid>
      <description>常微分方程初值问题 常微分方程描述了不同变量之间的变化关系，通过该关系我们可以确定变量之间的具体函数关系，但是微分方程不一定总是可解的，并且有些求解起来相当困难。给出积分曲线初始位置的状态，求解需要预测点的状态，为常微分方程的初值问题，我们可以在求解微分方程即的情况下对结果做出复合精度要求的预测。
以$f(x) = \sqrt{1+2x}$为例
有$y&#39;=\frac{dy}{dx}=y-\frac{2x}{y}$
本文给出几种算法的原理与实现。
Euler方法及其改进 从初始点开始，根据不同离散点的导数值对曲线进行预测，导数值可以通过对ODE的化简求解，做出一条折线图，最终曲线会逼近预测值。
该方法有明显的缺点就是在每一步做出抉择时，只考虑了当前的状态，并没有考虑后面的状态，因此必然会造成较大的误差，因此采用下一个结点的导数值进行修正。
具体流程如下
选取一定的步长h，一般为区间的n等分
预测下一个值$\overline{y}_{i+1} = y_i + hf(x_i, y_i)$
校正预测值$y_{i+1} = y_i + \frac{h}{2}[f(x_i, y_i)+f(x_{i+1}, \overline{y}_{i+1})]$
改写成平均化形式
$y_p = y_i +hf(x_i, y_i)$
$y_c = y_i + hf(x_{i+1}, y_p)$
$y_{i+1} = \frac{1}{2} (y_p+y_c), i =0,1,2,3,&amp;hellip;,n-1$
import numpy as np # 常微分方程化简 def ode(x, y): return y - 2 * x / y def f(x): return np.sqrt(1+2*x) def Euler(bound, start): &amp;#39;&amp;#39;&amp;#39; bound : 预测边界值 start : 起始点 &amp;#39;&amp;#39;&amp;#39; h = 0.</description>
    </item>
    
    <item>
      <title>数值积分方法</title>
      <link>https://ez4zzw.github.io/p/%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86%E6%96%B9%E6%B3%95/</link>
      <pubDate>Fri, 23 Apr 2021 20:18:59 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86%E6%96%B9%E6%B3%95/</guid>
      <description>数值积分 应用背景：微积分的基本计算公式为经典的牛顿莱布尼茨公式，但是作为计算机来说，计算原函数等操作过于困难，因此需要其他方法进行优化，代替牛顿莱布尼茨公式进行计算，本文将分享两种求积公式及其代码实现。
使用语言： Python-Numpy
使用两种方法计算$f(x)=sin(x)$在[1,2]上的积分
复化梯形的递推公式 由梯形公式改进，将区间[a, b]等分为n个小区间 $[x_i, x_{i+1}]$
$\int_{a}^{b}f(x)dx=\sum_{i=0}^{n-1}\int_{x_i}^{x_{i+1}}f(x)dx\approx \frac{h_i}{2}[f(x_i)+f(x_{i+1})]$
根据梯形公式化简为区间端点值组合
将求和公式展开，分离出左右端点
得到最终的化简结果
$T_n = \frac{h}{2} [f(a)+2\sum_{i=1}^{n-1}f(x_i)+f(b)]$
但是该方法的步长太小的话会导致计算次数太大，步长太大又难以保证效率
采用区间不断对分的方法，取$n = 2^k$，反复使用复合求积公式
$T^{(k)}=\frac{1}{2}T^{(k-1)}+\frac{h_{k-1}}{2}\sum_{i=0}^{2^{k-1}-1}f(a+ih_{k-1} + 0.5h_{k-1})$
其中$h_{k-1} = \frac{b-a}{2^{k-1}}$
Code
import numpy as np def f(x): return np.sin(x) def Calc(): eps = 1e-7 Flag = True l = 1.0 r = 2.0 h = r - l t1 = 1.0*(h/2)*(1+f(r)) t2 = 0.0 while Flag: sum = 0 x = l + h/2 while x &amp;lt; r: sum += f(x) x += h t2 = t1/2 + h*sum/2 h /= 2.</description>
    </item>
    
    <item>
      <title>三种插值方法及实现</title>
      <link>https://ez4zzw.github.io/p/%E4%B8%89%E7%A7%8D%E6%8F%92%E5%80%BC%E6%96%B9%E6%B3%95%E5%8F%8A%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Mon, 19 Apr 2021 22:22:57 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/%E4%B8%89%E7%A7%8D%E6%8F%92%E5%80%BC%E6%96%B9%E6%B3%95%E5%8F%8A%E5%AE%9E%E7%8E%B0/</guid>
      <description>插值方法 插值属于数值分析领域中的一种方法，是一种通过已知的离散的数据点，来拟合原函数根据给定的自变量估算因变量的方法。
常用的插值方法有很多，本文章给出三种常见的插值方法的实现。
使用语言: Python
使用下面的数据，预测函数在x=1处的值
x = np.array([0.5, 0.6, 0.4, 0.7]) y = np.array([-0.6931, -0.5108, -0.9163, -0.3567]) 线性插值 线性插值及求一次多项式$p(x)$，满足$p(x_0), p(x_1) = y_1$ 可以根据点斜式方程求解 即
$p(x) =y_0 \frac{y_{1}-y_{0}}{x_1-x_0}(x-x_0)$ 还可以将公式整理成如下形式
$p(x) = y_0 \frac{x - x_1}{x_0 - x_1} + y_1 \frac{x- x_0}{x_1 - x_0}$
我们令这里的$l_0(x)=\frac{x-x_1}{x_0 - x_1}, l_1(x)=\frac{x-x_0}{x_1-x_0}$
将其线性组合之后即为
$p(x)=y_0 l_0(x)+y_1 l_1(x)$
是Lagrange插值的特殊形式
此处给出线性插值的代码实现：
import numpy as np def linear(x, y, x0): &amp;#39;&amp;#39;&amp;#39; x : 为横坐标数组 y : 为纵坐标数组 x0: 为需要预测点的横坐标 res: 预测结果 &amp;#39;&amp;#39;&amp;#39; res = y[1] + (y[1] - y[0])*(x0 - x[1])/(x[1] - x[0]) # 根据公式计算结果 return res x = np.</description>
    </item>
    
    <item>
      <title>OJ部署debug记录</title>
      <link>https://ez4zzw.github.io/p/oj%E9%83%A8%E7%BD%B2debug%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Sat, 03 Apr 2021 22:22:14 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/oj%E9%83%A8%E7%BD%B2debug%E8%AE%B0%E5%BD%95/</guid>
      <description>&lt;p&gt;学校重构之后的OJ终于进入了前后端对接的阶段，经过了一周的紧张对接环境，项目依然是(正在稳定推进的阶段)，和前端对接口的一周里，我感觉到自己之前工作的不足，在此做出反思，以后要改掉这些错误。同时在和运维一起部署的过程中，也发现了许许多多的问题，在此一并记录一下。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Git学习笔记</title>
      <link>https://ez4zzw.github.io/p/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 02 Apr 2021 22:33:25 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;p&gt;对于git，很早很早就在用了，但是还没有系统整理过，并且有些命令使用时需要注意的事项，在此也一并标出。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>记录一次Go项目的部署</title>
      <link>https://ez4zzw.github.io/p/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1go%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Tue, 30 Mar 2021 12:23:42 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1go%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%83%A8%E7%BD%B2/</guid>
      <description>最近写了一个go项目，需要部署到服务器进行测试，如果只是go run main.go难免也太麻烦了点，于是学习了项目部署的相关知识。 项目的部署有多种方式，Jenkins,nginx等方式，本文只讲解一下简单的shell脚本部署。
系统信息 系统信息: CentOS Linux release 8.3.2011 x86_64 Go version: go version go1.14.12 linux/amd64
几条命令的介绍 nohup nohup命令的全称为no hang up不挂起，可以在系统后台不挂断的运行命令，退出终端后程序也会正常运行。 语法格式： nohup ./xxx &amp;gt; xxx.log 2&amp;gt;&amp;amp;1 &amp;amp; 解释： &amp;gt; xxx.log表示将输出重定向至该文件，可以记录运行时的日志 2&amp;gt;&amp;amp;1将标准错误2重定向到标准输出&amp;amp;1，然后标准输出&amp;amp;1再被重定向至xxx.log文件
git pull git pull origin dev 为了方便项目的及时更新，使用改名了保证运行时与上游仓库的代码保持一致。
ps ps命令为 process status,可以查看系统当前的进程状态
例如
~&amp;gt; ps PID TTY TIME CMD 255873 pts/0 00:00:02 zsh 258517 pts/0 00:00:00 sh 258519 pts/0 00:00:00 OnlineJudge 263021 pts/0 00:00:00 ps 我们将用ps命令与grep等命令筛选出项目的pid ps命令有很多参数选择，这里介绍一下用到的两条命令:
ps -e 列出所有进程 ps -f 显示进程的全部信息 grep grep命令可以查找文本中符合条件的字符串，用于匹配进程的名称， 还可以匹配文本中的各种信息，本文不再具体展开，后续打算更一篇具体记录Linux命令的博客。</description>
    </item>
    
    <item>
      <title>汇编语言笔记</title>
      <link>https://ez4zzw.github.io/p/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 16 Mar 2021 10:29:27 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/</guid>
      <description>简介 本学期选了汇编语言这门选修课，我认为还是有很大的学习价值的，虽然学习的还是年代久远的8086CPU指令集，但对后续接触更多汇编语言还是有很大帮助，方便我们调试程序，多了一种查错的方式。 其实关于调试自己很久之前就想学了，高中的时候看紫书，发现lrj老师讲了一段的gdb调试方法，当时感觉一点都看不懂，现在借此机会学习一下gdb的调试。 本文除了将总结一些汇编语言学习过程中的笔记之外，还计划穿插一些cs213/CSAPP 的内容以及bomb lab的解析。
准备工作 dos系统现在以及年代久远，想使用8086CPU指令集调试的话需要借助DosBox来实现。 DosBox官网
由于macOS下没有DOSbox需要的调试工具，因此下载之后需要挂载debug.exe等Windows下的调试工具 在DOSbox中输入
mount C ~/dos C: debug 即可进入debug模式
实验1 前置知识 几条汇编指令
mov 目标操作对象,源操作数 add 目标操作对象,源操作数 jmp 寄存器 //修改IP寄存器的值 or jmp CS:IP eg: jmp ax == (let IP = ax) jmp 2AE3:3 == let CS = 2AE3H and let IP = 0003H sub ax,bx ax = ax - bx inc and dec inc 操作对象 eg: inc ax == ax+=1 dec ax == ax-=1 注意：不可用mov指令修改段寄存器的值。（代码段寄存器CS，指令指针寄存器IP） CPU中识别CS:IP为执行指令 操作对象可以是寄存器，也可以是地址</description>
    </item>
    
    <item>
      <title>计算机组成原理笔记</title>
      <link>https://ez4zzw.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 15 Mar 2021 19:53:04 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;p&gt;本文随机更新机组笔记&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Katex测试及其语法总结</title>
      <link>https://ez4zzw.github.io/p/katex%E6%B5%8B%E8%AF%95%E5%8F%8A%E5%85%B6%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 14 Mar 2021 20:50:48 +0800</pubDate>
      
      <guid>https://ez4zzw.github.io/p/katex%E6%B5%8B%E8%AF%95%E5%8F%8A%E5%85%B6%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/</guid>
      <description>文章总结自KaTex Support 待更新
KATEX Support
KATEX测试 $$ \frac{\sum_{i=1}^Nf(x_i)}{\int_1^\infin \frac{1}{e^x}} $$</description>
    </item>
    
    <item>
      <title>博客迁移记录</title>
      <link>https://ez4zzw.github.io/p/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Sat, 13 Mar 2021 23:28:31 +0800</pubDate>
      
      <guid>https://ez4zzw.github.io/p/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%AE%B0%E5%BD%95/</guid>
      <description>从hexo到hugo 从高中开始就采用hexo+GitHub Pages的方式搭建博客，hexo确实很强大，但是由于需要借助node的原因，用起来总是没那么舒服，尤其是在换了电脑之后，配置环境比较麻烦，npm install也比较臃肿，于是决定采用hugo。
hugo是一个使用go语言开发的博客框架，由于是go编写的，所以渲染速度总的来说比hexo快不少，而且安装起来也很简单，也有不少美观的主题，方便部署到各个平台。
环境配置 系统环境：macOS arm64 (M1 Silicon) Go Version: go1.16beta1 darwin/arm64 homebrew版本：3.0.5
我是用的为arm平台的golang，没有测试过用intel平台的go版本进行配置
安装hugo brew install hugo 创建一个新网站 hugo new site blog 添加一个主题 git init // 初始化git git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack //主题下载 添加篇文章 我的主题文章保存在了content文件夹中的post目录
hugo new /post/first.md 本地进行渲染预览 hugo server -D 之后可以通过打开localhost:1313来进行预览
部署到GitHub仓库 hugo -D cd public git init git add . git commit -m &amp;quot;first commit&amp;quot; git remote add origin https://github.com/yourname/yourname.github.io git push origin master </description>
    </item>
    
    <item>
      <title>Luogu3964-松鼠聚会</title>
      <link>https://ez4zzw.github.io/p/luogu3964-%E6%9D%BE%E9%BC%A0%E8%81%9A%E4%BC%9A/</link>
      <pubDate>Sun, 11 Oct 2020 19:45:39 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/luogu3964-%E6%9D%BE%E9%BC%A0%E8%81%9A%E4%BC%9A/</guid>
      <description>&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.luogu.com.cn/problem/P3964&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Luogu3964&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;
&lt;p&gt;草原上住着一群小松鼠，每个小松鼠都有一个家。时间长了，大家觉得应该聚一聚。但是草原非常大，松鼠们都很头疼应该在谁家聚会才最合理。
每个小松鼠的家可以用一个点$(x,y)$表示,两个点的距离定义为点 $(x,y)$ 和它周围的8个点 $(x-1,y)，(x+1,y),(x,y-1)，(x,y+1)$
$(x−1,y+1),(x-1,y-1),(x+1,y+1),(x+1,y-1)$距离为1。输出一个整数，表示松鼠为了聚会走的路程和最小是多少。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>51nod3143-切比雪夫距离与曼哈顿距离</title>
      <link>https://ez4zzw.github.io/p/51nod3143-%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB%E4%B8%8E%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB/</link>
      <pubDate>Sun, 11 Oct 2020 19:45:25 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/51nod3143-%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB%E4%B8%8E%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB/</guid>
      <description>&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.51nod.com/Challenge/Problem.html#problemId=3143&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;51nod3143&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;
&lt;p&gt;n位战士即将奔赴战场，他们每个人都有一个攻击值ai和一个防御值bi，现在你想设计一种装备给这n位战士，如果这件装备的攻击值为A，防御值为B，那么对于第i位战士这件装备的不匹配度为$max(|A−a_i|,|B−b_i|)$
A，B都是正整数，要让所有战士的不匹配度之和最小，求出最小的不匹配度之和$2\le N \le 100000$&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>莫队-小B的询问洛谷P2709</title>
      <link>https://ez4zzw.github.io/p/%E8%8E%AB%E9%98%9F-%E5%B0%8Fb%E7%9A%84%E8%AF%A2%E9%97%AE%E6%B4%9B%E8%B0%B7p2709/</link>
      <pubDate>Wed, 07 Oct 2020 22:04:49 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/%E8%8E%AB%E9%98%9F-%E5%B0%8Fb%E7%9A%84%E8%AF%A2%E9%97%AE%E6%B4%9B%E8%B0%B7p2709/</guid>
      <description>Description P2709 小B 有一个长为n的整数序列$a$，值域为$[1,k]$。 他一共有m个询问，每个询问给定一个区间$[l,r]$ 求：$\sum_{i=1}^k c_i^2$ 其中 $c_i$ 表示数字 $i$ 在$[l,r]$ 中的出现次数。 小B请你帮助他回答询问。
Solution 莫队算法板子题 mark
Code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#define mem(a,b) memset(a,b,sizeof(a)) #define debug cout&amp;lt;&amp;lt;0&amp;lt;&amp;lt;endl #define ll long long const int MAXN = 5e4 + 10; const int MOD = 1e9 + 7; using namespace std; struct Q{ int l, r, k; } q[MAXN]; int N, M, K; int pos[MAXN], a[MAXN], cnt[MAXN]; ll ans[MAXN]; ll res; inline void Add(int n) { cnt[a[n]]++; res += 2ll*cnt[a[n]] - 1; } inline void Sub(int n) { cnt[a[n]]--; res -= 2ll*cnt[a[n]] + 1; } int main() { ios::sync_with_stdio(false); cin.</description>
    </item>
    
    <item>
      <title>GCD-兔八哥与猎人</title>
      <link>https://ez4zzw.github.io/p/gcd-%E5%85%94%E5%85%AB%E5%93%A5%E4%B8%8E%E7%8C%8E%E4%BA%BA/</link>
      <pubDate>Wed, 07 Oct 2020 22:04:23 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/gcd-%E5%85%94%E5%85%AB%E5%93%A5%E4%B8%8E%E7%8C%8E%E4%BA%BA/</guid>
      <description>Description 兔八哥躲藏在树林旁边的果园里。果园有M × N棵树，组成一个M行N列的矩阵，水平或垂直相邻的两棵树的距离为1。兔八哥在一棵果树下。 猎人背着猎枪走进了果园，他爬上一棵果树，准备杀死兔八哥。 如果猎人与兔八哥之间没有其它的果树，猎人就可以看到兔八哥。 现己知猎人和兔八哥的位置，编写程序判断兔子所在的位置是否安全. 输入：　第一行为n，表示有n(n ≤ 100,000)组数据，每组数据的第一行为两个正整数ax和ay，表示猎人的位置，第二行为两个正整数bx和by，表示兔八哥的位置(1 ≤ ax, ay, bx, by ≤ 100,000,000)。 输出： 共有n行，每行为“yes”或“no”表示兔八哥的位置是否安全。
Solution 容易想到，兔八哥和猎人只要连线上无整数点即可，可以转化成$|a_x - b_x| 和 |a_y - b_y|$互质，即$gcd(|a_x - b_x|,|a_y - b_y|)=1$
Code #include&amp;lt;bits/stdc++.h&amp;gt;#define mem(a,b) memset(a,b,sizeof(a)) typedef long long ll; typedef unsigned long long ull; using namespace std; inline int gcd(int a, int b) { return b == 0 ? a : gcd(b,a%b); } int main() { //freopen(&amp;#34;test.txt&amp;#34;, &amp;#34;r&amp;#34;, stdin); 	ios::sync_with_stdio(false); cin.</description>
    </item>
    
    <item>
      <title>统计硬币-递推/DP</title>
      <link>https://ez4zzw.github.io/p/%E7%BB%9F%E8%AE%A1%E7%A1%AC%E5%B8%81-%E9%80%92%E6%8E%A8/dp/</link>
      <pubDate>Wed, 07 Oct 2020 22:04:23 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/%E7%BB%9F%E8%AE%A1%E7%A1%AC%E5%B8%81-%E9%80%92%E6%8E%A8/dp/</guid>
      <description>Description HDU 2566 假设一堆由1分、2分、5分组成的n个硬币总面值为m分，求一共有多少种可能的组合方式（某种面值的硬币可以数量可以为0）。
Solution 坑题，没给数据范围，只能瞎猜，一发搜索挂掉发现无法去重，但是考虑到该问题满足从1开始分配并无后效性，可以直接递推（类似背包），三种物品可选任意次
Code #include&amp;lt;bits/stdc++.h&amp;gt;#define mem(a,b) memset(a,b,sizeof(a)) typedef long long ll; typedef unsigned long long ull; using namespace std; int main() { //freopen(&amp;#34;test.txt&amp;#34;, &amp;#34;r&amp;#34;, stdin); 	ios::sync_with_stdio(false); int N, M; int ans;	int dp[2000][2000]; int n[] = {1,2,5}; cin.tie(0); int T; cin &amp;gt;&amp;gt; T; while (T--) { cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M; mem(dp,0); dp[0][0] = 1; for (int i = 0; i &amp;lt; 3; ++i) { for (int j = 1; j &amp;lt;= N; ++j) { for (int k = n[i]; k &amp;lt;= M; ++k) { dp[j][k] += dp[j-1][k-n[i]]; } } } cout &amp;lt;&amp;lt; dp[N][M] &amp;lt;&amp;lt; endl; } return 0; } </description>
    </item>
    
    <item>
      <title>中缀表达式求值</title>
      <link>https://ez4zzw.github.io/p/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</link>
      <pubDate>Wed, 07 Oct 2020 22:03:17 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</guid>
      <description>中缀表达式求值 对于表达式求值，我们通常用栈来操作。 常用的做法是先转换为后缀表达式，再利用栈来求值。 步骤如下：
 开一个栈一个储存运算符，再开一个结构存后缀表达式，可以选择string数组 每遇到一个数字，将其加入到后缀表达式种 遇到左括号，加入到符号栈种 遇到右括号，不断将栈顶元素添加到后缀表达式中，直到遇到左括号，然后弹出左括号 遇到普通运算符，只要栈顶符号的优先级不低于新符号，就不断取出栈顶元素存到后缀表达式，然后将新符号入栈，优先级顺序为乘除&amp;gt;加减&amp;gt;左括号 依次取出符号栈中剩余元素，加入到后缀表达式中 将得到的后缀表达式求值  Note 代码在取栈顶元素时容易出错，需要注意对栈为空时的判断
Code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#define mem(a,b) memset(a,b,sizeof(a)) #define debug cout&amp;lt;&amp;lt;0&amp;lt;&amp;lt;endl #define ll long long const int MAXN = 1e4 + 10; const int MOD = 1e9 + 7; using namespace std; stack&amp;lt;int&amp;gt; stnumber; stack&amp;lt;char&amp;gt; stsign; stack&amp;lt;int&amp;gt; ans; struct node { string s=&amp;#34;&amp;#34;; } a[MAXN]; int oder(char c) { if (c == &amp;#39;+&amp;#39; || c == &amp;#39;-&amp;#39;) return 1; else if (c == &amp;#39;*&amp;#39; || c == &amp;#39;/&amp;#39;) return 2; return 0; } int toInt(string ss) { int res = 0; for (int i = 0; i &amp;lt; ss.</description>
    </item>
    
    <item>
      <title>余数求和-整除分块</title>
      <link>https://ez4zzw.github.io/p/%E4%BD%99%E6%95%B0%E6%B1%82%E5%92%8C-%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/</link>
      <pubDate>Wed, 07 Oct 2020 21:47:20 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/%E4%BD%99%E6%95%B0%E6%B1%82%E5%92%8C-%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/</guid>
      <description>Description 给出整数$n,k$,计算$G(n,k)=\sum\limits_{i=1}^n=k \ mod \ i$,$1&amp;lt;=n,k&amp;lt;=1e9$
Solution 将k mod i展开可以得到$k - i*\lfloor \frac{k}{i} \rfloor$ 将求和式子展开可以得到$ \sum\limits_{i=1}^n = n*k-\sum\limits_{i=1}^n i * \lfloor\frac{k}{i} \rfloor $ 利用整除分块，可以发现，对于相同的$\lfloor\frac{k}{i} \rfloor$，即每个区间$l 到 r$，每次只需要再对i求和即可 即每次计算$(r-l+1)*\lfloor \frac{k}{i} \rfloor * (l+r)/2$
Note 在分块的时候误写为r=N/(N/i)导致调试耽误大量时间，而且交了四发才发现
for (ll l = 1, r; l &amp;lt;= N; l = r + 1) { if (l &amp;gt; K) { break; } r = min(N, K/(K/l)); ans -= (r - l + 1)*(K/l)*(l + r)/2; } Code //https://www.</description>
    </item>
    
    <item>
      <title>计算几何-平行四边形</title>
      <link>https://ez4zzw.github.io/p/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95-%E5%B9%B3%E8%A1%8C%E5%9B%9B%E8%BE%B9%E5%BD%A2/</link>
      <pubDate>Wed, 13 May 2020 22:05:25 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95-%E5%B9%B3%E8%A1%8C%E5%9B%9B%E8%BE%B9%E5%BD%A2/</guid>
      <description>Description 求平面上n个点构成的平行四边形个数。 输入 一行一个数n。 接下来n行，每行两个数x,y，表示这个点的坐标为(x,y)。 保证任意两点不重合，任意三点不共线。 输出 一行一个整数表示平行四边形个数。
Solution 按照平行四边形的性质，两组顶点的中点重合，可以统计出每组顶点的中点，再统计每个顶点的个数，排列组合一下
Note 第一发对于顶点的统计出锅了，排序条件写错，提交都要检查排序</description>
    </item>
    
    <item>
      <title>Fibonacci 矩阵快速幂</title>
      <link>https://ez4zzw.github.io/p/fibonacci-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</link>
      <pubDate>Fri, 13 Dec 2019 18:58:24 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/fibonacci-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</guid>
      <description>Description 请输出$Fib(n) mod 10000$ $n \leq 1000000000$
Solution 由于$n$的范围在$1e9$直接递推铁TLE，考虑矩阵快速幂 Fibonacci数列有如下性质 通过多次迭代 算是个板子题吧，记得在WUST新生赛做过一道想矩阵快速幂的题，然而正解是找规律QAQ，在此贴个板子。
Code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;string&amp;gt;typedef long long LL; const int MOD = 1e4; using namespace std; struct Matrix{ LL m[2][2]; void print(){ for (int i = 0; i &amp;lt; 2; i++) { for (int j = 0; j &amp;lt; 2; j++) cout &amp;lt;&amp;lt; m[i][j] &amp;lt;&amp;lt; &amp;#39; &amp;#39;; cout &amp;lt;&amp;lt; endl;	} } } base, ans; Matrix times(Matrix a, Matrix b) { Matrix ans; ans.</description>
    </item>
    
    <item>
      <title>Triangle Fibonacci&#43;二分查找</title>
      <link>https://ez4zzw.github.io/p/triangle-fibonacci-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Fri, 13 Dec 2019 18:58:14 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/triangle-fibonacci-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</guid>
      <description>Description 有$n$个木棍，长度为$1,2,3&amp;hellip;n$，现在要从中删掉一些木棍，使得剩下的木棍不能构成三角形，使删掉木棍的数量最少。T组数组，$T \leq 20$ $n \leq 20$
Solution 由于数据范围很小，可以直接暴力求解，依次选取两个数$a,b(a&amp;lt;b)$相加，要知道不能有任何一个数小于这个值，直接删掉$(a,a+b)$范围中的数即可 如果$n$的范围是$1e9$呢？ 通过找规律发现我们剩下的数是这样的 $1,2,3,5,8,13,21&amp;hellip;$ 这是Fibonacci数列!!!! 所以我们只需要找到$\leq n$的Fibonacci数有几个，减去就是答案 可以直接lower_bound注意处理极限数据！！！即$n==1||n==2$的情况 也可手写二分，但是二分貌似常数有点大，又考虑到第$88$个Fibonacci数就爆掉$1e9$了，所以直接便利也完全没问题
Code 暴力版本 #include &amp;lt;iostream&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std; bool vis[23]; int main() { int T; cin &amp;gt;&amp;gt; T; for (int i = 1; i &amp;lt;= T; i++) { int N, ans = 0; cin &amp;gt;&amp;gt; N; memset(vis, false, sizeof(vis)); for (int j = 1; j &amp;lt;= N - 1; j++) if (!</description>
    </item>
    
    <item>
      <title>DP? 素数筛&#43;Lucas定理&#43;费马小定理</title>
      <link>https://ez4zzw.github.io/p/dp-%E7%B4%A0%E6%95%B0%E7%AD%9B-lucas%E5%AE%9A%E7%90%86-%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/</link>
      <pubDate>Fri, 13 Dec 2019 18:57:13 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/dp-%E7%B4%A0%E6%95%B0%E7%AD%9B-lucas%E5%AE%9A%E7%90%86-%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/</guid>
      <description>Description 在杨辉三角中，从第一行第一列$(0,0)$开始，每次可选择向正下方走或向右下方走，走到第$n$行时不能超过第$n$行第$k$个元素，询问所经过路径的值的和的最小值$mod(p)$，一共有T组询问，$T \leq 100000$， $0 \leq k \leq n \leq 1e9$, 保证$p$是质数， 其中$p &amp;lt; 1e4$
Solution 名字虽然是DP，但是可以找出最优方案。 优先考虑$k \leq \frac{n}{2}$的情况，先向下走$n-k$步到达$(n-k-1,0)$ 再一路沿着右下方走，直到到达底部，即有$C_{n-k}^{0}+C_{n-k+1}^{1}+C_{n-k+2}^{2}+&amp;hellip;+C_{n}^{k}=C_{n+1}^{k}$ 通过变换$C_{n-k}^{0} = C_{n-k+1}{0}$ 再通过公式$C_{n}^{m}=C_{n-1}^{m}+C_{n-1}^{m-1}$可将上述公式合并 得到$C_{n+1}^{k}$ 所以答案为$C_{n+1}^{k}+n-k$ 当$k &amp;gt; \frac{n}{2}$时，根据对称性，令$k=n-k$即可转化成上一种情况 又发现题目涉及组合数取模，所以要用到**费马小定理**
 费马小定理: 假如$a$是一个整数，$p$是一个质数，且$gcd(a,p)=1$，即$a,p$互质，那么有$a^{p−1}≡1(modp)$
 已知$a^{p-1}≡1$，可以得到$a \cdot a^{p-2}≡1$，我们称$a$和$a^{p-2}$为在$mod(p)$意义下的乘法逆元 然而这只解决了除法取模的问题，注意到$n$的范围在$1e9$直接计算组合数又是铁套老鹅(TLE)，于是借助Lucas定理
对于质数$p$,有$C_n^m\ mod \ p = C_{\lfloor \frac{n}{p} \rfloor}^{\lfloor \frac{m}{p} \rfloor} \cdot C_{n\ mod\ p}^{m\ mod\ p} \ mod \ p$
可知$n\ mod\ p$和$m\ mod\ p$一定是小于$p$的数，可直接求解，其余部分继续用Lucas定理求解，当$m=0$的时候返回$1$
long long Lucas(long long n, long long m, long long p) { if (m == 0) return 1; return (C(n % p, m % p, p) * Lucas(n / p, m / p, p)) % p; } 有了这些工具之后就可以预处理阶乘和逆元了</description>
    </item>
    
    <item>
      <title>小兔的棋盘 组合数学</title>
      <link>https://ez4zzw.github.io/p/%E5%B0%8F%E5%85%94%E7%9A%84%E6%A3%8B%E7%9B%98-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/</link>
      <pubDate>Fri, 13 Dec 2019 18:56:57 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/%E5%B0%8F%E5%85%94%E7%9A%84%E6%A3%8B%E7%9B%98-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/</guid>
      <description>Description 小兔的叔叔从外面旅游回来给她带来了一个礼物，小兔高兴地跑回自己的房间，拆开一看是一个棋盘，小兔有所失望。不过没过几天发现了棋盘的好玩之处。从起点$(0，0)$走到终点$(n,n)$的最短路径数是$C_{2n}^{n}$,现在小兔又想如果不穿越对角线(但可接触对角线上的格点)，这样的路径数有多少?小兔想了很长时间都没想出来，现在想请你帮助小兔解决这个问题，对于你来说应该不难吧! $n \leq 35$
Solution 由于规定不能超过对角线，可用分治的思想，只考虑沿对角线分隔开的三角形的情况，对于一个三角形中，求从$(0，0)$走到终点$(n,n)$的最短路径，观察发现无论怎么走，设到达某一点时向上走了$i$步，向右走了$j$步，都有$i \leq j$这也能通过线性规划相关知识证明。不难发现只是一个类括号匹配问题，可用$Catalan$数求解，计算$C(n)$后即是在一个三角形中的解，答案是$2C(n)$
$C(n) = \sum_{i=0}^{n-1} C(i) \cdot C(n-i-1)$ 通项公式$C(n)=\frac{C_{2n}^{n}}{n+1}$
预处理$C(n)$即可
Code #include &amp;lt;iostream&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;queue&amp;gt;typedef long long LL; using namespace std; LL C[100]; int main() { C[0] = 1; C[1] = 1; for (int i = 2; i &amp;lt;= 80; i++) { LL t = 0; for (int j = 0; j &amp;lt; i; j++) t += C[j]*C[i - j - 1]; C[i] = t; } LL N; int cnt = 1; while (cin &amp;gt;&amp;gt; N) { if (N == -1) break; cout &amp;lt;&amp;lt; cnt++ &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; N &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; C[N]*2 &amp;lt;&amp;lt; endl; } return 0; } </description>
    </item>
    
    <item>
      <title>WHUT新生赛&#34;游记&#34;</title>
      <link>https://ez4zzw.github.io/p/whut%E6%96%B0%E7%94%9F%E8%B5%9B%E6%B8%B8%E8%AE%B0/</link>
      <pubDate>Sat, 16 Nov 2019 21:48:04 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/whut%E6%96%B0%E7%94%9F%E8%B5%9B%E6%B8%B8%E8%AE%B0/</guid>
      <description>&lt;h1 id=&#34;day--n&#34;&gt;Day -N&lt;/h1&gt;
&lt;p&gt;快新生赛了啊啊啊啊，半个多月没碰算法题了，一直在搞ToKen的前端任务，还在搞服务器的事，感觉要凉凉。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
