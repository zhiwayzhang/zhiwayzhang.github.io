<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Coding_Panda&#39;s Blog</title>
  
  
  <link href="https://ez4zzw.github.io/atom.xml" rel="self"/>
  
  <link href="https://ez4zzw.github.io/"/>
  <updated>2022-03-01T08:12:40.666Z</updated>
  <id>https://ez4zzw.github.io/</id>
  
  <author>
    <name>Coding_Panda</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis设计与实现读书笔记</title>
    <link href="https://ez4zzw.github.io/2022/03/01/redisdesign/"/>
    <id>https://ez4zzw.github.io/2022/03/01/redisdesign/</id>
    <published>2022-03-01T08:11:42.000Z</published>
    <updated>2022-03-01T08:12:40.666Z</updated>
    
    <content type="html"><![CDATA[<p>redis设计与实现</p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;redis设计与实现&lt;/p&gt;</summary>
    
    
    
    <category term="Note" scheme="https://ez4zzw.github.io/categories/Note/"/>
    
    
    <category term="Note" scheme="https://ez4zzw.github.io/tags/Note/"/>
    
    <category term="Redis" scheme="https://ez4zzw.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习笔记</title>
    <link href="https://ez4zzw.github.io/2022/01/25/godesign/"/>
    <id>https://ez4zzw.github.io/2022/01/25/godesign/</id>
    <published>2022-01-25T12:14:16.000Z</published>
    <updated>2022-02-03T13:41:21.273Z</updated>
    
    <content type="html"><![CDATA[<p>Go语言源码阅读与原理分析</p><span id="more"></span><h1 id="Go的编译"><a href="#Go的编译" class="headerlink" title="Go的编译"></a>Go的编译</h1><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>声明</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">3</span>]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">[...]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;语法糖</span><br></pre></td></tr></table></figure><p>第二种编译器会进行上限推导</p><p>语句转换</p><p>由字面量（具体整数，浮点数，字符串）组成的数组，根据长度进行优化</p><ul><li>元素数量<code>&lt;=</code>4，元素放在栈上</li><li><code>&gt;</code>4时，元素保存在静态区，运行时取出</li></ul><p>元素数量<code>&lt;=</code>4时，简化为赋值表达式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="review"><a href="#review" class="headerlink" title="review"></a>review</h3><p>编译之后的二进制文件包含：栈，堆，数据段，代码段</p><p>堆栈为动态区域，数据段和代码段为静态区域</p><p>栈：编译器自动分配释放，存放参数值，局部变量等</p><p>堆：程序动态申请的内存，malloc，用链表实现</p><p>代码区：函数体的二进制代码</p><p>数据段：包含</p><ol><li>只读数据段 const</li><li>已初始化的读写数据段 初始化的全局变量，初始化的静态局部变量static</li><li>未初始化段 未初始化的全局变量和静态变量</li></ol><p>当数组元素个数大于四个时</p><p>获取一个唯一的staticname，在静态存储区进行初始化，之后再拷贝到栈上</p><p>访问和赋值</p><p>编译器的静态类型检查时检测数组越界，索引是否为非负整数，索引越界</p><p>使用变量作为索引时，无法编译检查，需要运行时阻止</p><p>发现数组切片字符串越界时通过运行时的<code>runtime.panicIndex</code>和<code>runtime.goPanicIndex</code>触发panic</p><p>下标没有越界时，编译器获取数组的内存地址和访问下标，计算出目标地址，使用Load将元素加载到内存中</p><p>赋值时先确定目标元素地址，使用Store指令将数据存入地址，在编译阶段而不是运行时</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Go语言源码阅读与原理分析&lt;/p&gt;</summary>
    
    
    
    <category term="Note" scheme="https://ez4zzw.github.io/categories/Note/"/>
    
    
    <category term="Note" scheme="https://ez4zzw.github.io/tags/Note/"/>
    
    <category term="Go" scheme="https://ez4zzw.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>【操作系统】虚拟内存</title>
    <link href="https://ez4zzw.github.io/2022/01/18/virtualmem/"/>
    <id>https://ez4zzw.github.io/2022/01/18/virtualmem/</id>
    <published>2022-01-18T07:27:22.000Z</published>
    <updated>2022-01-18T07:36:51.405Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟内存提供了三个重要能力：</p><ul><li>将主存看做是 存储在磁盘上地址空间的 高速缓存，主存按照需要在磁盘和主存中传递数据</li><li>每个进程提供一致的地址空间，简化内存管理</li><li>保护每个进程的地址空间不被其他进程破坏</li></ul><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;虚拟内存提供了三个重要能力：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将主存看做是 存储在磁盘上地址空间的 高速缓存，主存按照需要在磁盘和主存中传递数据&lt;/li&gt;
&lt;li&gt;每个进程提供一致的地址空间，简化内存管理&lt;/li&gt;
&lt;li&gt;保护每个进程的地址空间不被其他进程破坏&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Note" scheme="https://ez4zzw.github.io/categories/Note/"/>
    
    
    <category term="Note" scheme="https://ez4zzw.github.io/tags/Note/"/>
    
    <category term="CSAPP" scheme="https://ez4zzw.github.io/tags/CSAPP/"/>
    
  </entry>
  
  <entry>
    <title>Mysql学习笔记</title>
    <link href="https://ez4zzw.github.io/2022/01/17/mysql/"/>
    <id>https://ez4zzw.github.io/2022/01/17/mysql/</id>
    <published>2022-01-17T15:16:08.000Z</published>
    <updated>2022-01-27T14:22:51.641Z</updated>
    
    
    
    
    <category term="Note" scheme="https://ez4zzw.github.io/categories/Note/"/>
    
    
    <category term="Note" scheme="https://ez4zzw.github.io/tags/Note/"/>
    
    <category term="MySQL" scheme="https://ez4zzw.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP读书笔记</title>
    <link href="https://ez4zzw.github.io/2022/01/16/tujiehttp/"/>
    <id>https://ez4zzw.github.io/2022/01/16/tujiehttp/</id>
    <published>2022-01-16T14:25:00.000Z</published>
    <updated>2022-01-27T14:22:00.669Z</updated>
    
    <content type="html"><![CDATA[<p>图解HTTP读书笔记</p><span id="more"></span><h1 id="Web及网络基础"><a href="#Web及网络基础" class="headerlink" title="Web及网络基础"></a>Web及网络基础</h1><p><code>HTTP/0.9</code> 不是http的正式标准，临时版本</p><p><code>HTTP/1.0</code> RFC1945</p><p><code>HTTP/1.1</code> 目前应用较广 RFC2616</p><p><code>HTTP/2.0</code> 大幅提高了web性能</p><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><p>互联网运行与TCP IP协议族之上，HTTP包含于其中</p><p>ip，dns，udp，ftp，http，tcp。。。</p><p>TCP/IP的分层管理</p><p>应用层：决定了向用户提供服务时通信的活动，ftp，dns，http</p><p>传输层：对应用层提供连接的两台计算机的数据传输，TCP Transmission Control Protocol传输控制协议和UDP User Data Protocol用户数据报协议</p><p>网络层：处理网络上的数据包，数据包是网络传输的最小数据单位，规定如何传输路线，传输数据包</p><p>数据链路层：处理连接网络的硬件，网络适配器NIC网卡</p><p>物理层</p><blockquote><p>层次化好处：1.设计好接口，每个层次内部的设计可以自由改动 2.使设计变得更简单，应用层上的应用不需要考虑接收方的地理位置等</p></blockquote><h2 id="IP、TCP、DNS"><a href="#IP、TCP、DNS" class="headerlink" title="IP、TCP、DNS"></a>IP、TCP、DNS</h2><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>IP协议位于网络层</p><p>mac地址为网卡的固定地址，使用ARP协议（address resolution Protocol地址解析协议）凭借mac地址进行通信，解析ip到mac地址</p><p>选择传输路线叫做路由选择</p><h3 id="TCP协议的可靠性"><a href="#TCP协议的可靠性" class="headerlink" title="TCP协议的可靠性"></a>TCP协议的可靠性</h3><p>位于传输层</p><p>将大数据块分割为报文段segment确保传输准确可靠</p><p>将请求报文按照序号分为多个报文段，将每个报文段可靠的传输，收到后再根据序列号重组报文</p><p>确保数据可到达：</p><p>三次握手three way handshaking</p><p>TCP标志 SYN synchronize和ACK acknowledgement</p><p>具体过程：</p><ul><li>发送端发送一个带有SYN标志的数据包</li><li>接收端收到后回传带有SYN/ACK标志的数据包</li><li>发送端传回带有ACK标志的数据包，握手结束</li></ul><p>如果握手中的某个阶段中断，TCP协议会再次发送相同的数据包</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>域名解析</p><h2 id="URI和URL"><a href="#URI和URL" class="headerlink" title="URI和URL"></a>URI和URL</h2><p>URL是URI的子集</p><h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><p>http是无状态协议</p><p>使用cookie管理状态</p><p>使用URI定位资源</p><p>持久连接：任意一端未提出断开，则保持tcp连接状态，减少tcp连接重复建立和断开的开销</p><p>HTTP 1.1中，所有连接默认为持久连接</p><p>pipeline技术：连续发送请求，不必等待上一个请求返回</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>服务器响应报文中Set-Cookie header字段，告知客户端保存</p><p>客户端再次请求时自动在header中加入cookie</p><h1 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h1><p>换行符CR+LF，CR回车符<code>0x0d</code>，LF换行符<code>0x0a</code></p><p>header + CR+LF + Body</p><p>报文message是通信基本单位，8位组字节流</p><p>实体entity 请求或响应的在和，包含实体header和实体body</p><p>传输过程中可以对实体进行压缩</p><p>实体可以分割传输</p><h2 id="获取部分内容的请求"><a href="#获取部分内容的请求" class="headerlink" title="获取部分内容的请求"></a>获取部分内容的请求</h2><p>传输中断的恢复机制</p><p>在header中加Range</p><p><code>Range: bytes= 1-5000</code></p><p>断点续传</p><h1 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h1><p>1XX，正在处理 信息性状态<br>2XX，处理完毕 成功<br>3XX，重定向状态码<br>4XX，客户端错误状态码<br>5XX，服务器错误状态码</p><p>200 OK </p><p>HEAD方法不会返回body</p><p>204 No Content 处理成功，但是response中不包含实体</p><p>206 Partial Content 客户端进行了范围请求</p><p>301 Moved Permanently 永久重定向，资源分配了新的URI</p><p>302 Found 临时重定向</p><p>303 See Other 客户端用GET，临时重定向（比如POST访问时返回303，需要改GET方法重定向到另一个URI）</p><p>304 Not modified 我有你要的资源但是不让你访问</p><p>307 Temporary Redirect 临时重定向</p><p>400 Bad request</p><p>401 Unauthorized</p><p>403 Forbidden 不允许访问</p><p>404 Not Found 找不到资源</p><p>500 Internal Server Error 内部错误</p><p>503 Service Unavailable 服务器超负荷</p><h1 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h1><h2 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h2><p>一台服务器可以绑定多个域名</p><p>通过dns解析</p><h2 id="代理-网关-隧道"><a href="#代理-网关-隧道" class="headerlink" title="代理 网关 隧道"></a>代理 网关 隧道</h2><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>转发中间人</p><p>每次转发会追加写入via首部</p><p>代理服务功能：缓存技术，访问控制，获取日志</p><p>缓存代理：将资源缓存在代理服务器上，不从原服务器获取（有点像redis</p><p>透明代理：转发请求和响应，不添加其他内容</p><h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>转发客户端请求到实际程序</p><p>网关与服务器使用非http通信</p><h3 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h3><p>在客户端和服务器直接中转，保持双方的通信连接</p><p>本身不解析http请求，只传输</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>客户端缓存和服务器缓存</p><p>客户端缓存存储在浏览器</p><p>各种header的作用</p><h2 id="Cookie相关header"><a href="#Cookie相关header" class="headerlink" title="Cookie相关header"></a>Cookie相关header</h2><p>Set-Cookie: 后跟name=value的序列</p><p>Cookie: 发送cookie</p><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>http缺点：</p><ul><li>明文被窃听</li><li>不验证双方身份，可伪装</li><li>无法验证完整性，可以篡改</li></ul><p>使用SSL secure socket layer或TLS transport layer security安全层传输协议</p><p>SSL使用证书确定身份</p><p>防止篡改：使用md5或sha-1等校验方法校验报文完整性</p><p>HTTP+通信加密+证书+完整性保护</p><p>通信接口部分用ssl和tls协议代替</p><p>http先和ssl通信，ssl再和tcp通信</p><p>非对称加密 公钥进行加密，私钥进行解密</p><h2 id="通信步骤"><a href="#通信步骤" class="headerlink" title="通信步骤"></a>通信步骤</h2><ol><li>客户端发送client hello开始ssl通信</li><li>服务器响应server hello</li><li>服务器发送certificate报文，包含公钥证书</li><li>服务器发送server hello done</li><li>客户端发送client key exchange报文响应，ssl握手部分结束</li><li>客户端发送change cipher spec</li><li>客户端发送finished</li><li>服务器发送change cipher spec</li><li>ssl连接建立成功，开始进行http请求</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;图解HTTP读书笔记&lt;/p&gt;</summary>
    
    
    
    <category term="Note" scheme="https://ez4zzw.github.io/categories/Note/"/>
    
    
    <category term="Note" scheme="https://ez4zzw.github.io/tags/Note/"/>
    
    <category term="计算机网络" scheme="https://ez4zzw.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>【操作系统】异常控制流</title>
    <link href="https://ez4zzw.github.io/2022/01/14/ecf/"/>
    <id>https://ez4zzw.github.io/2022/01/14/ecf/</id>
    <published>2022-01-14T02:12:15.000Z</published>
    <updated>2022-01-18T07:28:52.580Z</updated>
    
    <content type="html"><![CDATA[<p>异常控制流</p><p>CSAPP CH-8</p><p>指令地址间的过度为控制转移，控制转移序列叫做控制流</p><p>ECF Exceptional Control Flow 异常控制流是系统实现IO，进程和虚拟内存的基本机制</p><p>ECF用于应用程序和操作系统的交互</p><p>try catch等语句基于ECF</p><span id="more"></span><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>硬件实现，操作系统实现</p><p>异常是控制流中的突变</p><p>比如虚拟内存缺页， 算术溢出， 除以0</p><p>事件：处理器状态变化</p><p>处理器检测到事件发生，通过异常表的跳转表，进行间接过程调用，由异常处理程序处理异常，根据异常事件类型，进行：</p><ul><li>将控制返回给当前指令I-curr</li><li>控制返回给I-next，则没有发生异常，执行下一条指令</li><li>终止被中断的程序</li></ul><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>每种异常分配一个异常号，是异常表中的索引</p><p>系统启动时操作系统预处理一张异常表，第k个元素包含异常k的处理程序的地址</p><p>异常表基地址寄存器存放异常表的起始地址</p><p>过程调用和异常的区别：</p><ul><li>过程调用，跳转回处理程序前，处理器将返回地址入栈；异常为根据异常以及处理结果进行跳转</li><li>处理器会将额外处理器状态入栈</li><li>控制从用户程序转移到内核，都被压入内核栈</li><li>异常处理运行在内核模式</li></ul><p>硬件触发异常，异常处理程序在软件中完成</p><h2 id="异常类型"><a href="#异常类型" class="headerlink" title="异常类型"></a>异常类型</h2><p>中断 interrupt 来自IO设备 异步 返回到下一条指令</p><p>陷阱 trap 有意异常 同步 返回到下一条指令</p><p>故障 fault 潜在的可恢复错误 同步 可能返回当前指令</p><p>终止 abort 不可恢复错误 同步 不会返回</p><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>异步发生，来自处理器外部的IO设备</p><p>异步的含义：中断不是由一个专门指令造成的</p><p>异常由中断处理程序处理</p><h3 id="trap和系统调用"><a href="#trap和系统调用" class="headerlink" title="trap和系统调用"></a>trap和系统调用</h3><p>trap是指向指令的结果，用于在用户程序和内核之间提供一个接口，叫做系统调用</p><p>读文件，创建进程fork，加载程序</p><h3 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h3><p>由错误情况引起，被故障处理程序修正，控制返回到引起故障的指令，从而重新执行，否则返回到内核的abort，将引起故障的程序终止。</p><h3 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h3><p>硬件错误，dram或者sram损坏 会返回abort然后终止应用程序</p><h2 id="Linux-x86-64系统中的异常"><a href="#Linux-x86-64系统中的异常" class="headerlink" title="Linux x86-64系统中的异常"></a>Linux x86-64系统中的异常</h2><p>故障号和cpu架构有关</p><h3 id="Linux中的故障和终止"><a href="#Linux中的故障和终止" class="headerlink" title="Linux中的故障和终止"></a>Linux中的故障和终止</h3><p>除法错误：除以0，Unix会直接终止程序 floating exception</p><p>一般故障保护：神秘的错误，如程序引用了未定义的虚拟内存地址，或者访问只读的文本，也就是段错误segmentation fault</p><p>缺页：会从新执行产生故障的指令，将磁盘上的虚拟内存的一个页面映射到物理内存的一个页面，然后重新执行这条指令</p><p>机器检查：是在导致故障的指令执行中检测到致命的硬件错误时发生的</p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>请求内核的服务</p><p>每个系统调用有一个编号，对应内核中跳转表的偏移量</p><p>c语言中syscall函数，c一般封装了系统调用库函数，带着参数陷入内核，将系统调用的执行状态返回</p><p>Linux系统调用的参数通过寄存器传递</p><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>执行中程序的实例，每个程序运行在某个进程的上下文context中</p><p>上下文包括内存中程序的代码和数据，栈，通用目的寄存器，程序计数器，环境变量，文件描述符集合</p><p>提供抽象：独立的逻辑控制流，假象程序独占处理器；私有地址空间，假象程序独占内存</p><p>逻辑控制流是交错的，进程轮流使用处理器，每个进程执行流的一部分</p><h1 id="并发流"><a href="#并发流" class="headerlink" title="并发流"></a>并发流</h1><p>逻辑流可以是进程、线程等</p><p>并发：多个流并发的执行</p><p>运行在同一个处理器上</p><p>并行：运行在不同处理器核上</p><p>每个控制流中的一部分是时间片</p><h1 id="私有地址空间"><a href="#私有地址空间" class="headerlink" title="私有地址空间"></a>私有地址空间</h1><p>进程为每个程序提供假象，n位地址机器，地址空间<code>2^n</code>，</p><p>底部用于用户程序：包括代码，数据，堆，栈</p><p>顶部给内核</p><h1 id="用户模式和内核模式"><a href="#用户模式和内核模式" class="headerlink" title="用户模式和内核模式"></a>用户模式和内核模式</h1><p>通过模式位寄存器控制</p><p>/proc文件系统，包含系统属性，如内核数，cpu类型，某进程使用的内存段地址</p><h1 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h1><p>实现多任务</p><p>内核为每个进程维护一个上下文，包含重新启动一个进程所需的状态</p><p>包含通用目的寄存器，浮点寄存器，程序计数器，用户栈，状态寄存器，内核栈，内核数据结构（描述地址空间的页表、当前进程信息的进程表、已打开文件的文件表）</p><p>内核可以通过调度决定执行哪个进程</p><ol><li>保存当前进程上下文</li><li>恢复先前被抢占进程的上下文</li><li>控制传递给新恢复的进程</li></ol><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>全局变量 errno，strerror(errno)</p><h1 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h1><h2 id="获取进程id"><a href="#获取进程id" class="headerlink" title="获取进程id"></a>获取进程id</h2><p>pid</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;异常控制流&lt;/p&gt;
&lt;p&gt;CSAPP CH-8&lt;/p&gt;
&lt;p&gt;指令地址间的过度为控制转移，控制转移序列叫做控制流&lt;/p&gt;
&lt;p&gt;ECF Exceptional Control Flow 异常控制流是系统实现IO，进程和虚拟内存的基本机制&lt;/p&gt;
&lt;p&gt;ECF用于应用程序和操作系统的交互&lt;/p&gt;
&lt;p&gt;try catch等语句基于ECF&lt;/p&gt;</summary>
    
    
    
    <category term="Note" scheme="https://ez4zzw.github.io/categories/Note/"/>
    
    
    <category term="Note" scheme="https://ez4zzw.github.io/tags/Note/"/>
    
    <category term="CSAPP" scheme="https://ez4zzw.github.io/tags/CSAPP/"/>
    
  </entry>
  
  <entry>
    <title>redis实战读书笔记</title>
    <link href="https://ez4zzw.github.io/2022/01/03/redis/"/>
    <id>https://ez4zzw.github.io/2022/01/03/redis/</id>
    <published>2022-01-03T08:22:27.000Z</published>
    <updated>2022-01-15T13:37:06.333Z</updated>
    
    <content type="html"><![CDATA[<p>redis基础知识以及一些应用场景总结</p><span id="more"></span><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>内存数据库</p><p>优于memcached，速度上功能上</p><p>基础数据结构：</p><ul><li>String，List，Set，Hash，ZSet</li></ul><p><a href="https://redis.io/commands">redis命令手册</a></p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>key-value</p><p>指令GET，SET，DEL</p><h2 id="LIST"><a href="#LIST" class="headerlink" title="LIST"></a>LIST</h2><p>key-list</p><p>指令</p><ul><li>LPUSH，RPUSH 推入列表的左端和右端<br>LPUSH listname item<br>返回值为列表长度</li><li>LPOP，RPOP，从左端和右端删除元素</li><li>LINDEX，获取列表指定位置的元素<br>LINDEX listname 1</li><li>LRANGE，获取给定范围内的所有元素<br>LRANGE listname 0 -1<br>0为开始索引，-1位结束索引</li></ul><h2 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h2><p>key-set</p><p>SADD, SMEMBERS, SISMEMBER, SREM</p><h2 id="HASH"><a href="#HASH" class="headerlink" title="HASH"></a>HASH</h2><p>key-hash table</p><p>内部也是key-value </p><p>HSET, HGET, HGETALL, HDEL</p><h2 id="ZSET"><a href="#ZSET" class="headerlink" title="ZSET"></a>ZSET</h2><p>key-zset</p><p>ZADD, ZRANGE, ZRANGEBYSCORE, ZREM</p><h2 id="一个文章投票系统的设计"><a href="#一个文章投票系统的设计" class="headerlink" title="一个文章投票系统的设计"></a>一个文章投票系统的设计</h2><h3 id="基础功能设计"><a href="#基础功能设计" class="headerlink" title="基础功能设计"></a>基础功能设计</h3><p>根据文章的发布时间和投票数量计算一个评分，根据该评分来排序和展示文章</p><p>要求：如果有一篇文章符合有趣文章的要求（支持票至少200张），放在排行榜前100位至少一天</p><p>构造分数</p><p>$$<br>score = up\ vote\ *C + post\ time<br>$$</p><p>常量C可以选择432</p><p>分析：一天的秒数为86400，文章达到有趣需要200票，可以利用86400/200=432来作为每个投票对得分的贡献</p><p>保存评分以及存储文章信息</p><p>使用hash结构存储文章的标题，文章的url，发布文章的用户，发布时间，得票数量等信息</p><p>关于key的设置，可以使用任意字符作为分隔符，如<code>article:ID</code></p><p>使用两个zset，其中一个成员为文章id，分值为文章的发布时间，另一个成员为文章id，分值为文章的评分，使得网站可以按照发布时间和评分两种方式展示文章</p><p>防止用户重复投票，建立已投票用户名单，使用set结构，key为<code>voted:article_id</code></p><p>需要用到的一些指令：</p><ul><li>ZSCORE 获取文章发布时间的有序集合，判断发布时间是否在一周内</li><li>SADD 若可投票，将用户添加到已投票的set中，操作成功则说明用户未向该文章投过票</li><li>ZINCRBY 将文章的评分增加432</li><li>HINCRBY 对hash结构中的文章投票数量进行更新</li></ul><h3 id="发布获取文章"><a href="#发布获取文章" class="headerlink" title="发布获取文章"></a>发布获取文章</h3><p>发布文章需要新增id，使用计数器，执行incr指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incr keyname</span><br></pre></td></tr></table></figure><p>可以得到计数器++之后的值</p><p>使用sadd将发布者id添加到文章投票的用户集合中（避免自己给自己投票）</p><p>集合的过期时间为一周，一周后自动释放expire</p><p>HMSET存储文章相关信息</p><p>执行zadd添加文章初始评分到保存评分的zset</p><p>执行zadd添加文章发布时间到保存时间的zset</p><p>使用HGETALL获取存储在hash中的文章结构</p><p>使用ZREVRANGE取出评分最高的文章和最新发布的文章：</p><ul><li>使用ZREVRANGE获取文章的id</li><li>使用HGETALL获取详细内容</li></ul><h3 id="文章分组"><a href="#文章分组" class="headerlink" title="文章分组"></a>文章分组</h3><p>TODO</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;redis基础知识以及一些应用场景总结&lt;/p&gt;</summary>
    
    
    
    <category term="Note" scheme="https://ez4zzw.github.io/categories/Note/"/>
    
    
    <category term="Note" scheme="https://ez4zzw.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>【操作系统】网络编程</title>
    <link href="https://ez4zzw.github.io/2022/01/03/netprog/"/>
    <id>https://ez4zzw.github.io/2022/01/03/netprog/</id>
    <published>2022-01-03T05:37:02.000Z</published>
    <updated>2022-01-04T18:17:21.131Z</updated>
    
    <content type="html"><![CDATA[<p>承接Unix I/O这一章节，了解网络如何构建以及客户端和服务器如何通信，socket函数相关内容的学习</p><p>CSAPP Ch-11 笔记</p><span id="more"></span><h2 id="CS编程模型"><a href="#CS编程模型" class="headerlink" title="CS编程模型"></a>CS编程模型</h2><p>客户端服务器模型</p><p>一个服务器进程，多个客户端进程</p><p>基本操作是事务transaction</p><p>有四步</p><ol><li>客户端向服务器发送请求，发起一个事务</li><li>服务器解释请求，用响应的方式操作资源</li><li>服务器返回响应，等待下一个请求</li><li>客户端接受响应并处理</li></ol><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>网络是一种IO设备，是数据源和数据接收方</p><p>网络数据接收后经IO和内存总线复制到内存，双向传输</p><p>以太网Ethernet是局域网技术</p><p>电缆链接主机和集线器，集线器广播每个端口的信息到所有主机</p><p>主机发送帧frame开头的信息，包括header，随后是有效载荷，payload，网内每个主机都可以见，只有目的主机读取</p><p>桥接以太网，主机…-集线器-桥-桥-集线器-…主机，网桥会根据通信需要来选择是否转发帧到其他网桥</p><p>连接多个局域网使用路由器</p><p>协议解决网络传输中的差异，提供命名机制（网络地址）和传输机制（包头+有效载荷）</p><p>数据发送过程：</p><ol><li>主机A通过系统调用从虚存加载数据到内核缓冲区</li><li>主机A上的协议软件添加互联网包头和接口帧头，互联网包头指向主机B，接口帧头指向主机LAN1。是封装关系。<br>帧头的包数据为互联网包头以及数据，帧头为其自己的互联网包头</li><li>LAN1适配器复制数据到网络</li><li>路由器读取数据猴传送到协议软件</li><li>协议软件读取目标互联网地址，作为路由表的索引转发到对应的LAN2适配器</li><li>LAN2适配器复制帧到网络</li><li>到达主机B，从适配器读取帧，传输到协议软件</li><li>协议软件去除包头和帧头，读取数据，主机B通过系统调用拷贝数据到虚拟地址空间</li></ol><h2 id="全球IP"><a href="#全球IP" class="headerlink" title="全球IP"></a>全球IP</h2><p>客户端（用户）-【socket接口系统调用】-TCP/IP（内核）-【硬件接口，中断】-网络适配器（硬件）-全局IP因特网</p><p>使用socket接口函数和Unix IO函数通信，socket函数为系统调用，调用内核的TCP/IP函数</p><p>TCP/IP是一个协议族，IP协议提供命名方法和传递机制，数据报</p><p>IP机制不可靠，数据报丢失不会自动恢复</p><p>UDP UNreliable datagram protocol，不可靠数据报协议对其进行了扩展，包可以在进程之间传递，而不是主机之间</p><p>TCP是基于IP的协议，进程间可靠的全双工连接</p><p>因特网的特性：</p><ul><li>主机集合映射到32位ip地址</li><li>ip地址映射为一组域名</li><li>主机上的进程能够通过连接其他主机的进程通信</li></ul><p>ipv4和ipv6：</p><ul><li>version 4：32位地址</li><li>version 6：128位地址</li></ul><h3 id="ip地址"><a href="#ip地址" class="headerlink" title="ip地址"></a>ip地址</h3><p>32位无符号整数，8*4</p><p>TCP/IP统一了字节顺序，大端法</p><p>使用点分十进制表示，Linux查看主机地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostname -i</span><br></pre></td></tr></table></figure><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>一级域名mil，edu，gov，com，cn</p><p>二级域名whut.edu</p><p>hosts文件手工维护ip和域名的映射</p><p>DNS，domain name system</p><p>Linux使用nslookup查看域名ip</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup baidu.com</span><br></pre></td></tr></table></figure><p>通常域名和ip一一对应，多个域名也可以对应同一ip，泛域名cs.whut.edu, ee.whut.edu</p><p>多个域名可以映射到同一组的多个ip，如<a href="http://www.twitter.com和twitter.com映射到199.16.156/">www.twitter.com和twitter.com映射到199.16.156</a>.*</p><h3 id="因特网连接"><a href="#因特网连接" class="headerlink" title="因特网连接"></a>因特网连接</h3><p>客户端和服务器在连接上发送和接收字节流来通信，点对点，全双工，可以同时双向流动</p><p>socket是连接的端点，每个socket都有socket地址，由<code>地址:端口</code>构成，十六位端口号0-65535</p><p>客户端发起请求时，客户端socket地址端口由内核自动分配，临时端口；服务器的为默认端口</p><p>web使用80（http），电子邮件地址使用25（SMTP）</p><p>可以通过<code>/etc/services</code>看查<strong>知名</strong>服务默认端口</p><p>一个连接两端的socket地址是唯一确定的，socket pair，格式<code>(cliaddr:cliport, servaddr:servport)</code>，即<code>(客户端IP:客户端端口,服务器IP:服务器端口)</code></p><h2 id="socket接口"><a href="#socket接口" class="headerlink" title="socket接口"></a>socket接口</h2><p>一组函数实现，和Unix IO配合创建网络应用</p><p>流程：</p><p>客户端getaddrinfo-&gt;socket-&gt;connect发送连接请求-&gt;rio_writen-&gt;rio_readlineb-&gt;close发送EOF</p><p>服务器getaddrinfo-&gt;socket-&gt;bind-&gt;listen-&gt;accept接受请求-&gt;rio_readlineb读客户端的write-&gt;rio_writen写入response-&gt;rio_readlineb读取EOF-close</p><h3 id="socket地址结构"><a href="#socket地址结构" class="headerlink" title="socket地址结构"></a>socket地址结构</h3><p>对于Linux内核，socket就是一个有描述符的打开文件</p><p>socket地址存放与<code>sockaddr_in</code>，包含<code>AF_INET</code>，<code>sin_port</code>为16位端口号，<code>sin_addr</code>为32位ip地址，都是以大端法存放</p><h3 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h3><p>客户端和服务器使用socket函数创建socket描述符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clientfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><code>AF_INET</code>表示使用32位IP地址，<code>SOCK_STREAM</code>表示该socket为连接端点</p><p>该函数返回的描述符为部分打开的，不能读写，将有客户端完成打开socket的工作</p><h3 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h3><p>客户端调用connect函数建立和服务器连接</p><p>connect函数会阻塞一直到连接成功建立或者错误，成功后clientfd为可读写状态</p><p>由getaddrinfo函数获取connect的参数</p><h3 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h3><p>bind函数通知内核将addr中的服务器socket地址和socket描述符socketfd联系到一起</p><p>由getaddrinfo函数获取bind的参数</p><h3 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h3><p>客户端是发起请求的主动实体，服务器是被动实体</p><p>默认，内核认为socket函数创建的描述符为主动socket，服务器通过listen函数通知内核描述符是被服务器使用而不是客户端</p><p>将socketfd从主动socket转化为监听socket，监听socket可以接受客户端的连接请求</p><p>参数backlog为队列中未完成的请求数量，一般设置较大的数</p><h3 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h3><p>服务器使用accept函数等待客户端的连接请求</p><p>已经获得监听描述符connfd，listenfd，返回一个已连接描述符，该描述符可以被Unix IO读写，可以和客户端通信，将connfd返回给客户端</p><p>与监听描述符不太，监听描述符是客户端连接请求的端点，只创建一次，存在于服务器的整个生命周期</p><p>已连接描述符为客户端和服务器直接已经建立连接的端点，服务器每次接受请求都会创建</p><p>可以理解为后端程序当前已经监听系统的某个端口，此时客户端请求后后端在该基础上创建一个线程去处理该请求</p><h3 id="主机和服务的转换"><a href="#主机和服务的转换" class="headerlink" title="主机和服务的转换"></a>主机和服务的转换</h3><ol><li><code>getaddrinfo</code><br>将主机名、主机地址、服务名端口号转为socket地址结构<br>返回result为一个addrinfo链表，每个结构对应一个host和service的socket地址结构<br>客户端调用之后，遍历链表，尝试每个地址，直到socket和connect成功，建立连接<br>服务器会遍历每个地址，直到socket和bind成功<br>避免内存泄露，最后调用freeaddrinfo释放链表<br>参数讲解跳了</li><li><code>getnameinfo</code><br>将socket地址转换为主机和服务名字符串</li></ol><h3 id="socket接口辅助函数"><a href="#socket接口辅助函数" class="headerlink" title="socket接口辅助函数"></a>socket接口辅助函数</h3><p>以上接口的整合封装</p><ol><li>open_clientfd<br><code>int open_clientfd(char *hostname, char *port)</code></li></ol><p>open_clientfd建立和服务器的连接，返回描述符，可以直接用于Unix IO函数读写</p><p>流程：getaddrinfo，返回addrinfo链表，遍历链表尝试建立连接，失败则关闭描述符，成功后释放链表将描述符（connfd）返回给客户端</p><ol start="2"><li>open_listenfd<br>服务器创建监听描述符</li></ol><p><code>int open_listenfd(char *port)</code></p><p>遍历链表直到调用socket和bind成功</p><h3 id="echo实例"><a href="#echo实例" class="headerlink" title="echo实例"></a>echo实例</h3><p>简单的单线程处理服务器</p><p>EOF概念，并不是字符，而是内核检测的一个条件，read函数返回0时，程序检测到EOF条件。磁盘文件读写，文件位置超出长度，判断EOF。网络连接，进程关闭连接其中一端，触发EOF。尝试读取通信中字节流的最后一个字节之后的字节，触发EOF。</p><h2 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h2><h3 id="Web基础"><a href="#Web基础" class="headerlink" title="Web基础"></a>Web基础</h3><p>HTTP协议，Hypertext Transfer Protocol超文本传输协议</p><h3 id="Web内容"><a href="#Web内容" class="headerlink" title="Web内容"></a>Web内容</h3><p>内容是MIME，多用途的网际邮件扩充协议，类型相关的字节序列</p><ul><li>读取一个磁盘文件，将内容返回给客户端，磁盘文件为静态内容</li><li>运行可执行文件，将输出返回</li></ul><p>使用URL标识每个文件</p><p>根据目录指定返回规则</p><p>根目录为网页静态内容的根目录</p><p>后缀为<code>/</code>时服务器自动补全默认文件名</p><h3 id="HTTP事务"><a href="#HTTP事务" class="headerlink" title="HTTP事务"></a>HTTP事务</h3><p>使用Linux的Telnet和任何web服务器执行事务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet url port</span><br></pre></td></tr></table></figure><p>HTTP请求</p><p>请求行<code>method URI version</code></p><p>0个或多个请求报头</p><p>一个空的文本行终止报头列表</p><p>body</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F; HTTP&#x2F;1.1  </span><br><span class="line">Host: www.baidu.com</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>请求方法GET、POST、OPTIONS、HEAD、PUT、DELETE、TRACE</p><p>URI是相应URL的后缀，包括文件名和参数</p><p>version为http版本</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Request_header">Mozilla文档</a></p><p>header可以存放多种信息，比如cookie等</p><p>host请求头在HTTP 1.1位必须，1.0中不必须。代理缓存proxy cache会使用host报头，理解为反向代理？</p><p>客户端和服务器直接可以由代理，<code>代理链</code></p><p>HTTP响应组成：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">响应行</span><br><span class="line">0个或多个响应头</span><br><span class="line">终止报头的空行</span><br><span class="line">响应主体body</span><br></pre></td></tr></table></figure><p>响应行格式</p><p><code>version status-code status-message</code></p><p>version对于HTTP版本，code为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1**</span><br><span class="line">200</span><br><span class="line">301 </span><br><span class="line">400</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">501</span><br><span class="line">505</span><br></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status">更多状态码</a></p><p>响应头中应有Content-Type，告知客户端主体内容的MIME类型，Content-Length，告知主体的字节大小</p><ol><li>传递参数</li></ol><p>URI或者请求主体<br>2. 服务器传递参数给子进程</p><p>fork一个子进程，调用execve在子进程上下文中执行对应的程序，通过环境变量，如QUERY_STRING, REQUEST_METHOD等信息，程序做出对应的处理</p><ol start="3"><li>子进程的输出到哪里？<br>CGI程序（通用网关接口Common Gateway Interface），将内容发送到标准输出，在子进程调用CGI程序之前，使用Linux dup2函数将标准输出重定向到和客户端相连的已连接描述符，CGI程序写入到标准输出的内容都会直接到达客户端</li></ol><h1 id="实现一个Web服务器"><a href="#实现一个Web服务器" class="headerlink" title="实现一个Web服务器"></a>实现一个Web服务器</h1><p>使用c配合CSAPP提供的封装搭建一个简易的web服务器</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本章主要了解了Unix如何建立一个网络连接，以及数据传输的具体过程，socket的设计巧妙之处，以及Linux一切皆文件的进一步理解。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;承接Unix I/O这一章节，了解网络如何构建以及客户端和服务器如何通信，socket函数相关内容的学习&lt;/p&gt;
&lt;p&gt;CSAPP Ch-11 笔记&lt;/p&gt;</summary>
    
    
    
    <category term="Note" scheme="https://ez4zzw.github.io/categories/Note/"/>
    
    
    <category term="Note" scheme="https://ez4zzw.github.io/tags/Note/"/>
    
    <category term="CSAPP" scheme="https://ez4zzw.github.io/tags/CSAPP/"/>
    
  </entry>
  
  <entry>
    <title>【操作系统】系统级IO</title>
    <link href="https://ez4zzw.github.io/2022/01/03/sysio/"/>
    <id>https://ez4zzw.github.io/2022/01/03/sysio/</id>
    <published>2022-01-03T02:31:33.000Z</published>
    <updated>2022-01-03T05:39:31.182Z</updated>
    
    <content type="html"><![CDATA[<p>高级别的IO程序，如c中的printf和scanf，c++中的<code>&gt;&gt;</code>和<code>&lt;&lt;</code>，都依赖Unix 系统级IO</p><p>CSAPP Ch-10 笔记</p><span id="more"></span><h2 id="Unix-IO"><a href="#Unix-IO" class="headerlink" title="Unix IO"></a>Unix IO</h2><p>Linux文件即是m个字节的序列$B_0, B_1, …, B_k, …, B_{m-1}$</p><p>所有的IO设备（网络，磁盘，终端）被抽象为文件，输入和输出被作为相应文件的读和写进行，Linux内核只需要暴露一个简单低级的应用接口</p><p>输入和输出的统一方式:</p><ul><li>打开文件：应用程序请求IO设备，内核返回描述符</li><li>Linux Shell创建的进程开始时有三个文件：标准输入0，标准输出1，标准错误2</li><li>改变当前的文件位置：内核存储文件位置k，初始为0，通过seek改变这个偏移量</li><li>读写文件：读为复制字节到内存，当k&gt;=m时，会触发EOF条件；写为复制字节到一个文件中，从当前位置k开始，然后更新k</li><li>关闭文件：通知内核，内核释放文件打开时创建的数据结构，释放描述符，进程终止时内核会释放打开的文件以及内存</li></ul><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><ul><li>普通文件：文本文件：ASCII或Unicode字符文件，其他的都是二进制文件，对内核而言无区别，换行符<code>\n</code>对应ASCII LF</li><li>目录：包含一组链接的文件，链接将文件名映射到一个文件</li><li>套接字socket：与另一个进程进行跨网络通信的文件</li><li>命名通道named pipe，符号链接，字符和块设备</li></ul><p>绝对路径：以斜杠开始<code>/home/test</code></p><p>相对路径：以文件名开始,<code>../test</code></p><h2 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h2><p>open函数打开或创建文件</p><p>返回一个文件描述符，在进程中没有打开的最小描述符<br>几种控制参数flags</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">O_RDONLY 只读</span><br><span class="line">O_WRONLY 只写</span><br><span class="line">O_RDWR 可读可写</span><br><span class="line">O_CREAT 文件不存在则创建空文件</span><br><span class="line">O_TRUNC 存在则截断，清空</span><br><span class="line">O_APPEND 追加写入</span><br></pre></td></tr></table></figure><p>mode参数控制读写权限</p><p>每个进程都有umask</p><p>访问权限为<code>mode &amp; ~umask</code></p><p>close(int fd)关闭文件，成功返回0，失败-1</p><h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><p>read和write</p><p>输入的size为unsigned long类型，ssize_t为long类型，因为read和write函数需要返回-1</p><p>read和write读写遇到不足的情况：</p><ul><li>读取时遇到EOF</li><li>从终端读文本行</li><li>读写socket：网络延迟导致read和write返回值不足</li></ul><h2 id="RIO包-Robust-IO"><a href="#RIO包-Robust-IO" class="headerlink" title="RIO包 Robust IO"></a>RIO包 Robust IO</h2><h2 id="读取文件元数据"><a href="#读取文件元数据" class="headerlink" title="读取文件元数据"></a>读取文件元数据</h2><p>stat和fstat函数，读取文件信息</p><h2 id="读取目录内容"><a href="#读取目录内容" class="headerlink" title="读取目录内容"></a>读取目录内容</h2><p>opendir函数</p><h2 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h2><ul><li>描述符表，每个进程之间独立</li><li>文件表，打开文件的集合，所有进程共享，包含文件位置，引用计数，指向vnode表的指针，当引用计数为0时，操作系统删除表项</li><li>v-node，进程间共享，包含stat中的信息，st mode，st size</li></ul><h2 id="IO重定向"><a href="#IO重定向" class="headerlink" title="IO重定向"></a>IO重定向</h2><p><strong>标准输出</strong>重定向到磁盘文件</p><p>覆盖写入文件之前的内容</p><p>使用dup2函数，将终端的输出关闭，改为磁盘文件，磁盘文件引用次数+1</p><h2 id="标准IO"><a href="#标准IO" class="headerlink" title="标准IO"></a>标准IO</h2><p>标准IO将打开的文件模型化为一个流，减少系统级IO操作的调用</p><p>第一次getc调用IO read函数读取到缓冲区，之后调用将缓冲区第一个字节返回给应用程序</p><h2 id="选取IO函数问题"><a href="#选取IO函数问题" class="headerlink" title="选取IO函数问题"></a>选取IO函数问题</h2><p>socket中不要使用标准IO，可能会导致崩溃，使用RIO函数/Unix IO</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;高级别的IO程序，如c中的printf和scanf，c++中的&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;，都依赖Unix 系统级IO&lt;/p&gt;
&lt;p&gt;CSAPP Ch-10 笔记&lt;/p&gt;</summary>
    
    
    
    <category term="Note" scheme="https://ez4zzw.github.io/categories/Note/"/>
    
    
    <category term="Note" scheme="https://ez4zzw.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>编译原理笔记</title>
    <link href="https://ez4zzw.github.io/2022/01/02/compiler/"/>
    <id>https://ez4zzw.github.io/2022/01/02/compiler/</id>
    <published>2022-01-02T02:33:48.000Z</published>
    <updated>2022-01-04T18:15:29.764Z</updated>
    
    <content type="html"><![CDATA[<p>编译原理笔记，词法语法分析</p><span id="more"></span><h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><h2 id="有穷自动机-DFA"><a href="#有穷自动机-DFA" class="headerlink" title="有穷自动机 DFA"></a>有穷自动机 DFA</h2><p>$$f: K \times \sum \to K$$是一个单值函数，任何输入符号都唯一的确定了下一个状态</p><h2 id="不确定的有穷自动机-NFA"><a href="#不确定的有穷自动机-NFA" class="headerlink" title="不确定的有穷自动机 NFA"></a>不确定的有穷自动机 NFA</h2><p>至少一个初态节点，若干个终态节点<br>DFA是NFA的特例</p><h2 id="子集法-NFA转换为DFA"><a href="#子集法-NFA转换为DFA" class="headerlink" title="子集法 NFA转换为DFA"></a>子集法 NFA转换为DFA</h2><p>对于状态集合$I$，定义两个运算</p><ol><li>集合$I$的$\epsilon-Closure(I)$，是一个状态集$I$中的任何状态经过任意条$\epsilon$弧能到达的状态集合<br> 因为当输入符号为空时，则自动机停留在原来的位置上，所以有关系$\forall S \in I \ \ , S \in \epsilon-Closure(I)$</li><li>状态集合$I$的$a$弧转换，表示为$move(I,a)$，定义为状态集合J，其中$J$是所有那些可以从$I$中的某一状态经过一条$a$弧而到达的状态的全体<br> 有关系$\forall S_i \in I \ \ , move(I,a)=f(S_1,a)\bigcup f(S_2,a) \bigcup f(S_3,a)…$<br>算法流程：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let C as a <span class="built_in">set</span> save Status-Set</span><br><span class="line">let K_0 = epsilon-Closure(<span class="number">0</span>)</span><br><span class="line">C &lt;- epsilon-Closure(K_0)</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">if</span> C have <span class="built_in">set</span> <span class="keyword">not</span> visit) &#123;</span><br><span class="line">visit[T] = <span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> a in Char Set &#123;</span><br><span class="line">U := epsilon-Closure(Move(T,a))</span><br><span class="line"><span class="keyword">if</span> (U <span class="keyword">not</span> in C) &#123;</span><br><span class="line">C &lt;- U</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>经过状态重新命名可以得到DFA<h2 id="DFA的化简"><a href="#DFA的化简" class="headerlink" title="DFA的化简"></a>DFA的化简</h2>化简 的DFA：没有多余状态，没有两个状态是互相等价的。<br>DFA可以通过消除无用状态和合并等价状态二转换成一个与之等价的最小状态的DFA</li></ol><p>无用状态：从开始状态触发，任何输入串都无法到达<br>                或者从这个状态没有通路到达终态<br>![[Pasted image 20211230203930.png]]<br>如s4，s6，s8，可以直接消除</p><p>DFA中的状态等价条件：</p><ol><li>一致性条件-状态s和t必须同时为可接受状态或不可接受状态</li><li>蔓延性条件-对于所有输入符号，状态s和t必须转换到等价的状态</li></ol><p>分割法分解DFA状态：<br>步骤：</p><ol><li>先将终态和非终态分割，作为两个子集，作为一个划分</li><li>在划分中对每个子集加上可输入字符，将可区别的状态拆分，得到新的划分</li><li>重复直到划分不可以再分割</li></ol><p>化简后的DFA便于在计算机上实现</p><h2 id="由DFA化简为正规式"><a href="#由DFA化简为正规式" class="headerlink" title="由DFA化简为正规式"></a>由DFA化简为正规式</h2><p>很简单<br>缩缩缩</p><h2 id="由正规式生成NFA"><a href="#由正规式生成NFA" class="headerlink" title="由正规式生成NFA"></a>由正规式生成NFA</h2><p>$L(G)$表示文法G产生的语言的集合<br>$L(G1) = L(G2)$ 则两个文法等价<br>反正就是构造一个等价的$\mathbb{NFA}$</p><h3 id="语法制导"><a href="#语法制导" class="headerlink" title="语法制导"></a>语法制导</h3><p>按照语法结构构造<br>将正规式分解为子表达式<br> <br>闭包：终态输入epsilon到达初态<br>分解方式不唯一<br>可以从头开始，也可以分部进行</p><p>处理步骤：</p><ul><li>如$r_1 r_2$，顺序拼接两个NFA</li><li>如$r1^*$处理闭包，终态输入epsilon链接到初态</li><li>如$r_1|r_2$，由初态输入epsilon到两个NFA，由两个NFA输入epsilon到达终态</li></ul><h1 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h1><h2 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h2><p>文法特点：</p><ol><li>每个产生式右部都由终结符号开始</li><li>若两个产生式都由相同的左部，右部都由不同的终结符开始<br>分析过程是唯一的</li></ol><p>FIRST集<br>$FIRST(\alpha)={以\alpha为左部的，产生式右部的第一个非终结符集合}$<br>为a的开始符号集</p><p>FOLLOW集<br>对于上下文无关文法，S是开始符号<br>$FOLLOW(A)={状态A后跟符号}$<br>若A可以引导终止epsilon ，则加入#到FOLLOW集</p><h4 id="构造算法"><a href="#构造算法" class="headerlink" title="构造算法"></a>构造算法</h4><p>对文法中每一非终结符A，构造FOLLOW(A)的算法如下：反复使用如下规则，直至FOLLOW集不再增大为止。<br>⑴若A是文法的开始符号,则把输入结束符＃加入FOLLOW(A)中；<br>⑵若B→αAaβ,a是终结符,则把a加入FOLLOW(A)中；<br>⑶若B→αAXβ,X是非终结符,则把FIRST(Xβ)加入FOLLOW(A)中；<br>⑷若B→αA或B→αAβ,且β可以推导至ε，则把FOLLOW(B)加入FOLLOW(A)中。 </p><p>SELECT集<br>$SELECT(A  \to a)=(FIRST(a)-{\epsilon})\bigcup FOLLOW(A)$</p><p>LL(1)文法：第一个L表示自顶向下分析是从左到右扫描输入串，第二个L表明分析过程中将用最左推导，1表明只需要向右看一个符号便可以决定如何推导。<br>充要条件:<br>对于每个非终结符A，的两个不同产生式<br>$SELECT(A \to \alpha)\bigcap SELECT(A \to \beta)=\varnothing$</p><h2 id="非LL-1-文法到LL-1-文法的等价转换"><a href="#非LL-1-文法到LL-1-文法的等价转换" class="headerlink" title="非LL(1)文法到LL(1)文法的等价转换"></a>非LL(1)文法到LL(1)文法的等价转换</h2><p>LL(1)文法的性质：<br>① LL(1)文法是无二义性的；<br>② LL(1)文法不含左递归；<br>③ LL(1)文法没有公共左因子。</p><p>消除左递归<br>消除回溯：提取左公因子<br>改造成LL1文法</p><h3 id="消除直接左递归："><a href="#消除直接左递归：" class="headerlink" title="消除直接左递归："></a>消除直接左递归：</h3><p>例如：<br> A→Aα|β<br>对A引入一个新的非终结符A′，把上式改写为：<br>A →βA′<br>A′→αA′|ε<br>例2：<br>E→E +T | T<br>T→T * F | F<br>F→i |（E）<br>改造为<br>E→TE′<br>E′→+T E′|ε<br>T→FT ′<br>T′→* FT′|ε<br>F→i |（E）</p><h3 id="消除间接左递归"><a href="#消除间接左递归" class="headerlink" title="消除间接左递归"></a>消除间接左递归</h3><p>把式子带入，然后按照消除直接左递归的方法去消除<br>S → Aα|β      ⑴<br>A → Sγ           ⑵<br>得到<br>S → Sγα|β     ⑶<br>消除左递归<br>S → βS′<br>S ′→γαS′|ε </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;编译原理笔记，词法语法分析&lt;/p&gt;</summary>
    
    
    
    <category term="Note" scheme="https://ez4zzw.github.io/categories/Note/"/>
    
    
    <category term="Note" scheme="https://ez4zzw.github.io/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title>【操作系统】程序的机器级表示</title>
    <link href="https://ez4zzw.github.io/2021/12/10/csapp-ch3/"/>
    <id>https://ez4zzw.github.io/2021/12/10/csapp-ch3/</id>
    <published>2021-12-10T13:19:54.000Z</published>
    <updated>2022-01-04T18:17:10.110Z</updated>
    
    <content type="html"><![CDATA[<p>讲解机器代码以及汇编</p><p>TODO了，有个bomb lab</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;讲解机器代码以及汇编&lt;/p&gt;
&lt;p&gt;TODO了，有个bomb lab&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Note" scheme="https://ez4zzw.github.io/categories/Note/"/>
    
    
    <category term="Note" scheme="https://ez4zzw.github.io/tags/Note/"/>
    
    <category term="CSAPP" scheme="https://ez4zzw.github.io/tags/CSAPP/"/>
    
  </entry>
  
  <entry>
    <title>【操作系统】信息的表示和处理</title>
    <link href="https://ez4zzw.github.io/2021/12/10/csapp-ch2/"/>
    <id>https://ez4zzw.github.io/2021/12/10/csapp-ch2/</id>
    <published>2021-12-10T05:02:03.000Z</published>
    <updated>2022-01-04T18:17:14.287Z</updated>
    
    <content type="html"><![CDATA[<p>本章为CSAPP Ch-2的读书笔记，复习了数据的存储方式</p><span id="more"></span><h1 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h1><p>最小可寻址内存单位 -字节byte 一般为8位的块</p><p>内存被视为一个很大的字节数组，也就是虚拟内存，每个字节用地址标识</p><p>地址的集合为虚拟地址空间</p><p>虚拟内存中包含程序的数据，指令，控制信息</p><h2 id="十六进制表示"><a href="#十六进制表示" class="headerlink" title="十六进制表示"></a>十六进制表示</h2><p>跳</p><h2 id="字数据大小"><a href="#字数据大小" class="headerlink" title="字数据大小"></a>字数据大小</h2><p>字长为数据标称大小</p><p>字长决定了虚拟地址空间的最大大小，字长为w的机器虚拟地址范围是[0, $$2^w-1$$]</p><p>最多访问$$2^w$$个字节</p><p>32位和64位</p><p><code>gcc -m32</code>可以编译32位程序</p><p><code>gcc -m64</code>可以编译64位程序</p><h2 id="寻址和字节顺序"><a href="#寻址和字节顺序" class="headerlink" title="寻址和字节顺序"></a>寻址和字节顺序</h2><p>最低有效字节在前-小端法</p><p>最高有效字节在前-大端法</p><p>部分cpu支持双端法 ，但是操作系统只支持小端模式（iOS &amp; Android）</p><h3 id="大小端的影响"><a href="#大小端的影响" class="headerlink" title="大小端的影响"></a>大小端的影响</h3><ol><li>网络收发统一顺序</li><li>汇编阅读字节顺序</li><li>按字节打印</li></ol><h2 id="字符串表示"><a href="#字符串表示" class="headerlink" title="字符串表示"></a>字符串表示</h2><p>以null结尾的字符数组</p><p>每个字符使用ASCII码，在各个系统都相同，因此文本数据的表示有更高的平台独立性（than二进制数据）</p><p>终止字符<code>0x00</code></p><p>UTF-8，每个字符使用一个字节来编码</p><h2 id="布尔代数"><a href="#布尔代数" class="headerlink" title="布尔代数"></a>布尔代数</h2><p>null</p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>掩码运算</p><blockquote><p>掩码：表示从一个字中选出来位的集合</p></blockquote><h1 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h1><p>跳</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本章为CSAPP Ch-2的读书笔记，复习了数据的存储方式&lt;/p&gt;</summary>
    
    
    
    <category term="Note" scheme="https://ez4zzw.github.io/categories/Note/"/>
    
    
    <category term="Note" scheme="https://ez4zzw.github.io/tags/Note/"/>
    
    <category term="CSAPP" scheme="https://ez4zzw.github.io/tags/CSAPP/"/>
    
  </entry>
  
  <entry>
    <title>【算法题】幸运数字</title>
    <link href="https://ez4zzw.github.io/2021/12/10/luckynumber/"/>
    <id>https://ez4zzw.github.io/2021/12/10/luckynumber/</id>
    <published>2021-12-10T04:46:33.000Z</published>
    <updated>2022-01-04T18:15:48.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给定一个数字N，给定一个数字的集合，使用集合里的数字构造出小于数字N的最大数。</p><p>如N = 23131，集合为{2, 4, 9}</p><p>则构造出22999</p><span id="more"></span><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>分两种情况讨论，构造的数字长度和N一样，或者比N少一位，若长度一样，则是从头开始按照比数字N小的数构造，若长度少一位可以直接用集合中的最大数填满。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// 23131</span></span><br><span class="line"><span class="comment">// 2 4 9</span></span><br><span class="line"><span class="comment">// 22999</span></span><br><span class="line"><span class="comment">// 229</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 22</span></span><br><span class="line"><span class="keyword">int</span> N, x;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">int</span> maxv = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">    v.clear();</span><br><span class="line">    nums.clear();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; x) &#123;</span><br><span class="line">        v.push_back(x);</span><br><span class="line">        maxv = max(maxv, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> temp = N;</span><br><span class="line">    <span class="keyword">int</span> setNumber = v.size();</span><br><span class="line">    sort(v.begin(), v.end());</span><br><span class="line">    <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">        nums.push_back(temp % <span class="number">10</span>);</span><br><span class="line">        temp /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(nums.begin(), nums.end());</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> done = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        number = number*<span class="number">10</span> + nums[i];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;number = &quot;</span> &lt;&lt; number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">bool</span> find = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = setNumber - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[j] &lt;= number) &#123;</span><br><span class="line">                ans = ans*<span class="number">10</span> + v[j];</span><br><span class="line">                find = <span class="literal">true</span>;</span><br><span class="line">                number -= v[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!find) &#123;</span><br><span class="line">            done = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;size &quot;</span> &lt;&lt; nums.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; maxv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;给定一个数字N，给定一个数字的集合，使用集合里的数字构造出小于数字N的最大数。&lt;/p&gt;
&lt;p&gt;如N = 23131，集合为{2, 4, 9}&lt;/p&gt;
&lt;p&gt;则构造出22999&lt;/p&gt;</summary>
    
    
    
    <category term="algorithm" scheme="https://ez4zzw.github.io/categories/algorithm/"/>
    
    
    <category term="leetcode" scheme="https://ez4zzw.github.io/tags/leetcode/"/>
    
    <category term="思维" scheme="https://ez4zzw.github.io/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode-179】最大数</title>
    <link href="https://ez4zzw.github.io/2021/12/09/leetcode-179/"/>
    <id>https://ez4zzw.github.io/2021/12/09/leetcode-179/</id>
    <published>2021-12-09T13:22:30.000Z</published>
    <updated>2022-01-04T18:15:38.972Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/largest-number/">https://leetcode-cn.com/problems/largest-number/</a></p><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给定一组非负整数 <code>nums</code>，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。</p><p>注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p><span id="more"></span><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>将数字全部转为字符串，进行逐个比较，比较规则为：</p><ul><li>从最高位开始比较，如果第一个数字较大，则把较大的排在前面</li><li>比较后续数字，将出现更大数字的数排在前面</li><li>若数字a为数字b的前缀，或相反，则返回a+b&gt;b+a，判断如何构造可以使得数字更大</li></ul><p>注意数字全为0的情况</p><p>sort里用lambda很香</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; nums_str;</span><br><span class="line">        <span class="keyword">bool</span> zero_flag = <span class="literal">false</span>;</span><br><span class="line">        nums_str.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num != <span class="number">0</span>) zero_flag = <span class="literal">true</span>;</span><br><span class="line">            nums_str.push_back(to_string(num));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!zero_flag) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        sort(nums_str.begin(), nums_str.end(), [](<span class="keyword">const</span> <span class="built_in">string</span> &amp;a, <span class="keyword">const</span> <span class="built_in">string</span> &amp;b) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">0</span>] != b[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>];</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; min(a.size(), b.size()); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] == b[i]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">return</span> a[i] &gt; b[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> a + b &gt; b + a;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> str : nums_str) &#123;</span><br><span class="line">            ans += str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/largest-number/&quot;&gt;https://leetcode-cn.com/problems/largest-number/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;给定一组非负整数 &lt;code&gt;nums&lt;/code&gt;，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。&lt;/p&gt;
&lt;p&gt;注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。&lt;/p&gt;</summary>
    
    
    
    <category term="algorithm" scheme="https://ez4zzw.github.io/categories/algorithm/"/>
    
    
    <category term="leetcode" scheme="https://ez4zzw.github.io/tags/leetcode/"/>
    
    <category term="字符串" scheme="https://ez4zzw.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="https://ez4zzw.github.io/2021/12/09/csapp/"/>
    <id>https://ez4zzw.github.io/2021/12/09/csapp/</id>
    <published>2021-12-09T11:58:54.000Z</published>
    <updated>2022-01-04T18:16:58.292Z</updated>
    
    <content type="html"><![CDATA[<p>CSAPP读书笔记 Ch-1 宏观看一看操作系统，很多知识之前确实没了解到，值得一读</p><span id="more"></span><h1 id="Ch1"><a href="#Ch1" class="headerlink" title="Ch1"></a>Ch1</h1><p>源程序 -&gt; 预处理器 (cpp) —hello.i—&gt; 编译器(ccl) —–hello.s—–&gt; 汇编器(as) —-hello.o(binary) with printf.o—&gt; 连接器 ——-&gt; 可执行二进制文件</p><ul><li><p>主存：临时存储设备 DRAM组成 </p></li><li><p>进程：并发执行多个进程-上下文切换</p></li></ul><p>进程运行所需的所有状态信息 <strong>上下文</strong></p><p>例如：PC和寄存器文件的当前值，主存的内容    </p><ul><li><p>并发执行 ：一个进程的指令和另一个进程的指令交错执行</p></li><li><p>线程：进程是由多个线程的执行单元组成 ，运行在进程的上下文中，共享同样的代码和全局数据</p></li></ul><p>多线程共享数据比多进程容易</p><ul><li><p>虚拟内存：对于进程，提供虚拟地址空间</p><p>包含 程序代码和数据，堆malloc 和free，共享库so，栈，内核虚拟内存为内核保留，不允许应用程序读写这个区域</p><p>基本思想：一个进程虚拟内存的内容存储在磁盘，利用主存座位磁盘的高速缓存</p></li><li><p>并发和并行：</p><ul><li>并发：同时具有多个活动的系统</li><li>并行：用并发是一个系统运行的更快</li><li>线程级并发：在一个进程中执行多个控制流</li><li>指令级并行：流水线技术</li><li>单指令，多数据并行 SIMD并行</li></ul></li><li><p>操作系统的抽象：</p><ul><li>文件是对I/O设备的抽象</li><li>虚拟内存是对主存和磁盘的抽象</li><li>进程是对处理器，主存和IO设备的抽象</li></ul></li><li><p>网络可以看做一种IO设备</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;CSAPP读书笔记 Ch-1 宏观看一看操作系统，很多知识之前确实没了解到，值得一读&lt;/p&gt;</summary>
    
    
    
    <category term="Note" scheme="https://ez4zzw.github.io/categories/Note/"/>
    
    
    <category term="Note" scheme="https://ez4zzw.github.io/tags/Note/"/>
    
    <category term="CSAPP" scheme="https://ez4zzw.github.io/tags/CSAPP/"/>
    
  </entry>
  
  <entry>
    <title>127.0.0.1,localhost和0.0.0.0暨🐼一次两次的神神秘秘的debug记录</title>
    <link href="https://ez4zzw.github.io/2021/07/26/localhost/"/>
    <id>https://ez4zzw.github.io/2021/07/26/localhost/</id>
    <published>2021-07-26T14:23:38.000Z</published>
    <updated>2021-07-26T15:29:20.639Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h1><p>潘达某天在本机docker部署了他的服务，但是发现无论如何都无法ping通，他冥(疯)思(狂)苦(谷)想(歌)，逛遍了GitHub上的各种issues，stack overflow上的各种回答，各种博客文章，都没有解决他的问题，直到他的mentor来到他的电脑前，一通命令猛如虎啊，发现他竟然在docker内监听了容器中的<code>127.0.0.1</code>的端口，那必然会访问不到，检查发现原来是在服务的config中写了magic number，让服务开在了<code>127.0.0.1</code>，在本地这样必然是没问题的，但是如果要与外部进行通信，那就要改成<code>0.0.0.0</code>了。</p><p>又是一天，潘达又部署起了他的rpc服务，想在服务器上部署一个微服务然后本机去访问，测试框架是否可以通过域名通信各个微服务，然而，服务器上启动成功，本地依然迟迟无法连接，上来就是一个<code>curl: (7) Failed to connect to ababab.ababab port ababa: Connection refused</code>，安全组也放行了对应的端口，然后他看到了一行<code>127.0.0.1</code>，但是他感觉不是这个问题，继续debug，然后再次呼叫他的mentor，希望得到帮助，还是一顿操作猛如虎，找到了那个<code>127.0.0.1</code>的监听服务，乐。</p><p>于是，这篇blog就诞生了。<br><a href="https://imgtu.com/i/WhQRUK"><img src="https://z3.ax1x.com/2021/07/26/WhQRUK.png" alt="WhQRUK.png"></a></p><span id="more"></span><h1 id="127-0-0-1-和-localhost"><a href="#127-0-0-1-和-localhost" class="headerlink" title="127.0.0.1 和 localhost"></a>127.0.0.1 和 localhost</h1><p><code>127.0.0.1</code>是回路地址中的一个，在计算机中<code>127.*.*.*</code>被称为回路地址，所有对这些地址的请求都会让本机接收，最最重要的是，外部设备也不能通过这个地址访问到本机的服务。<br>localhost其实是一个域名，他一般指代本机的网络，大多数机器都会默认localhost指向<code>127.0.0.1</code>，可以自行修改为其他地址。</p><h1 id="0-0-0-0"><a href="#0-0-0-0" class="headerlink" title="0.0.0.0"></a>0.0.0.0</h1><p>可能我们都会以为localhost为本地的网络地址，但实际上真正的本地网络是<code>0.0.0.0</code>，但是他是不能被ping通的。在服务器中，<code>0.0.0.0</code>并不是一个真实的的IP地址，它表示本机中所有的ipv4地址。监听<code>0.0.0.0</code>的端口，就是监听本机中所有IP的端口。如果服务监听在<code>0.0.0.0</code>，那么外部访问的所有ip都可以通过对应的端口访问这个服务。</p><p>所以问题得到了解答，如果是在本机的话，127.0.0.1的话显然是没问题的，但是如果要将服务上云或者容器，就需要进行调整，首先要避开127.0.0.1，再根据是否只允许内网ip访问进行端口映射和服务监听。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这两次问题前前后后折腾了半天，本想自己找到解决办法，查了不少资料后还是要寻求运维☁️的帮助，其实问题并不是很大，还是自己的知识储备不够，不能准确定位的问题的所在。另外，计网应该开始看了。🐼。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前记&quot;&gt;&lt;a href=&quot;#前记&quot; class=&quot;headerlink&quot; title=&quot;前记&quot;&gt;&lt;/a&gt;前记&lt;/h1&gt;&lt;p&gt;潘达某天在本机docker部署了他的服务，但是发现无论如何都无法ping通，他冥(疯)思(狂)苦(谷)想(歌)，逛遍了GitHub上的各种issues，stack overflow上的各种回答，各种博客文章，都没有解决他的问题，直到他的mentor来到他的电脑前，一通命令猛如虎啊，发现他竟然在docker内监听了容器中的&lt;code&gt;127.0.0.1&lt;/code&gt;的端口，那必然会访问不到，检查发现原来是在服务的config中写了magic number，让服务开在了&lt;code&gt;127.0.0.1&lt;/code&gt;，在本地这样必然是没问题的，但是如果要与外部进行通信，那就要改成&lt;code&gt;0.0.0.0&lt;/code&gt;了。&lt;/p&gt;
&lt;p&gt;又是一天，潘达又部署起了他的rpc服务，想在服务器上部署一个微服务然后本机去访问，测试框架是否可以通过域名通信各个微服务，然而，服务器上启动成功，本地依然迟迟无法连接，上来就是一个&lt;code&gt;curl: (7) Failed to connect to ababab.ababab port ababa: Connection refused&lt;/code&gt;，安全组也放行了对应的端口，然后他看到了一行&lt;code&gt;127.0.0.1&lt;/code&gt;，但是他感觉不是这个问题，继续debug，然后再次呼叫他的mentor，希望得到帮助，还是一顿操作猛如虎，找到了那个&lt;code&gt;127.0.0.1&lt;/code&gt;的监听服务，乐。&lt;/p&gt;
&lt;p&gt;于是，这篇blog就诞生了。&lt;br&gt;&lt;a href=&quot;https://imgtu.com/i/WhQRUK&quot;&gt;&lt;img src=&quot;https://z3.ax1x.com/2021/07/26/WhQRUK.png&quot; alt=&quot;WhQRUK.png&quot;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Tech" scheme="https://ez4zzw.github.io/categories/Tech/"/>
    
    
    <category term="Linux" scheme="https://ez4zzw.github.io/tags/Linux/"/>
    
    <category term="Docker" scheme="https://ez4zzw.github.io/tags/Docker/"/>
    
    <category term="计算机网络" scheme="https://ez4zzw.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Bilibili视频网站排行榜评分的线性回归分析</title>
    <link href="https://ez4zzw.github.io/2021/07/02/bilibili/"/>
    <id>https://ez4zzw.github.io/2021/07/02/bilibili/</id>
    <published>2021-07-02T06:05:48.000Z</published>
    <updated>2021-07-03T12:08:22.525Z</updated>
    
    <content type="html"><![CDATA[<p>Bilibili（哔哩哔哩）是当下最热门的视频播放网站，人们在该网站对视频进行浏览，会根据自己喜好对视频进行点赞、投币、收藏、分享、回复等操作，Bilibili同时还有一个排行榜机制，记录了近期比较热门的视频，并给出了一个评分，排行榜的排序规则即根据该评分，本文将根据这些排行榜视频的各项数据，进行线性回归分析，结合实际情况找出对评分影响最大的数据。</p><p>Bilibili提供了获取排行榜数据的API，因此我们可以利用该API获取实时的排行榜数据，获取的数据为json格式，经过解析，已将数据保存至Bilibili.csv文件中。</p><p>本文的思路即为多元线性回归，在统计学中，线性回归（linear regression）是利用称为线性回归方程的最小二乘函数对一个或多个自变量和因变量之间关系进行建模的一种回归分析。这种函数是一个或多个称为回归系数的模型参数的线性组合。只有一个自变量的情况称为简单回归，大于一个自变量情况的叫做多元回归（multivariable linear regression）。</p><p>完成了对各个自变量权重的计算，找出了对评分影响权重最高的因素，并得到了验证。</p><span id="more"></span><h1 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h1><p>在哔哩哔哩官网首页处获取排行榜信息的API，得到为</p><p><a href="https://api.bilibili.com/x/web-interface/ranking/v2?rid=0">https://api.bilibili.com/x/web-interface/ranking/v2?rid=0</a></p><p>请求参数为</p><ul><li>rid 分类，0代表全部分类</li></ul><p>返回格式为json格式，json中的data字段为视频信息数组。</p><p>为了防止请求次数过多增加服务器压力，导致本机IP禁止访问哔哩哔哩，先将请求的response保存到data.txt文件中。</p><p>使用python的json包进行解析</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;aid&quot;</span>: <span class="number">375696064</span>,</span><br><span class="line"><span class="attr">&quot;videos&quot;</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">&quot;tid&quot;</span>: <span class="number">17</span>,</span><br><span class="line"><span class="attr">&quot;tname&quot;</span>: <span class="string">&quot;单机游戏&quot;</span>,</span><br><span class="line"><span class="attr">&quot;copyright&quot;</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">&quot;pic&quot;</span>: <span class="string">&quot;http://i0.hdslb.com/bfs/archive/85005893d4c4959ff096d6fb061040e223842bcb.jpg&quot;</span>,</span><br><span class="line"><span class="attr">&quot;title&quot;</span>: <span class="string">&quot;史上最骚魔法师！(第二集)&quot;</span>,</span><br><span class="line"><span class="attr">&quot;pubdate&quot;</span>: <span class="number">1621566911</span>,</span><br><span class="line"><span class="attr">&quot;ctime&quot;</span>: <span class="number">1621566912</span>,</span><br><span class="line"><span class="attr">&quot;desc&quot;</span>: <span class="string">&quot;本期请到了Warma参与配音！鼓掌！！！！！\n游戏：Darkside Detective\n第一集：BV1M64y1m7gA\n各位如果看得开心，希望三连支持一下！&quot;</span>,</span><br><span class="line"><span class="attr">&quot;state&quot;</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">&quot;duration&quot;</span>: <span class="number">658</span>,</span><br><span class="line"><span class="attr">&quot;mission_id&quot;</span>: <span class="number">24025</span>,</span><br><span class="line"><span class="attr">&quot;rights&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;bp&quot;</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">&quot;elec&quot;</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">&quot;download&quot;</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">&quot;movie&quot;</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">&quot;pay&quot;</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">&quot;hd5&quot;</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">&quot;no_reprint&quot;</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">&quot;autoplay&quot;</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">&quot;ugc_pay&quot;</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">&quot;is_cooperation&quot;</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">&quot;ugc_pay_preview&quot;</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">&quot;no_background&quot;</span>: <span class="number">0</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">&quot;owner&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;mid&quot;</span>: <span class="number">546195</span>,</span><br><span class="line"><span class="attr">&quot;name&quot;</span>: <span class="string">&quot;老番茄&quot;</span>,</span><br><span class="line"><span class="attr">&quot;face&quot;</span>: <span class="string">&quot;http://i0.hdslb.com/bfs/face/bc5ca101313d4db223c395d64779e76eb3482d60.jpg&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">&quot;stat&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;aid&quot;</span>: <span class="number">375696064</span>,</span><br><span class="line"><span class="attr">&quot;view&quot;</span>: <span class="number">1149043</span>,</span><br><span class="line"><span class="attr">&quot;danmaku&quot;</span>: <span class="number">7300</span>,</span><br><span class="line"><span class="attr">&quot;reply&quot;</span>: <span class="number">3278</span>,</span><br><span class="line"><span class="attr">&quot;favorite&quot;</span>: <span class="number">37490</span>,</span><br><span class="line"><span class="attr">&quot;coin&quot;</span>: <span class="number">98319</span>,</span><br><span class="line"><span class="attr">&quot;share&quot;</span>: <span class="number">1780</span>,</span><br><span class="line"><span class="attr">&quot;now_rank&quot;</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">&quot;his_rank&quot;</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">&quot;like&quot;</span>: <span class="number">210211</span>,</span><br><span class="line"><span class="attr">&quot;dislike&quot;</span>: <span class="number">0</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">&quot;dynamic&quot;</span>: <span class="string">&quot;用魔法击败魔法&quot;</span>,</span><br><span class="line"><span class="attr">&quot;cid&quot;</span>: <span class="number">341808079</span>,</span><br><span class="line"><span class="attr">&quot;dimension&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;width&quot;</span>: <span class="number">1920</span>,</span><br><span class="line"><span class="attr">&quot;height&quot;</span>: <span class="number">1080</span>,</span><br><span class="line"><span class="attr">&quot;rotate&quot;</span>: <span class="number">0</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">&quot;short_link&quot;</span>: <span class="string">&quot;https://b23.tv/BV1jo4y117Vf&quot;</span>,</span><br><span class="line"><span class="attr">&quot;short_link_v2&quot;</span>: <span class="string">&quot;https://b23.tv/BV1jo4y117Vf&quot;</span>,</span><br><span class="line"><span class="attr">&quot;bvid&quot;</span>: <span class="string">&quot;BV1jo4y117Vf&quot;</span>,</span><br><span class="line"><span class="attr">&quot;score&quot;</span>: <span class="number">2446535</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过解析json格式文件并整理得到bilibili.csv</p><p>数据处理的代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> Request, urlopen</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getDataFromFile</span>():</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isfile(<span class="string">&#x27;./data.txt&#x27;</span>):</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">&quot;file not exist&quot;</span>)</span><br><span class="line"></span><br><span class="line">    text = <span class="built_in">open</span>(<span class="string">&#x27;./data.txt&#x27;</span>).read()</span><br><span class="line">    <span class="keyword">return</span> text</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getResponse</span>(<span class="params">url</span>):</span></span><br><span class="line">    headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.8    5 Safari/537.36&#x27;</span>&#125;</span><br><span class="line">    data = requests.get(url = url, headers=headers).text</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://api.bilibili.com/x/web-interface/ranking/v2?rid=0&amp;type=all&#x27;</span></span><br><span class="line">res = getDataFromFile()</span><br><span class="line">jsonData = json.loads(res)</span><br><span class="line"></span><br><span class="line">title = [] <span class="comment"># 标题</span></span><br><span class="line">author= [] <span class="comment"># up🐷</span></span><br><span class="line">view  = [] <span class="comment"># 播放量</span></span><br><span class="line">danmu = [] <span class="comment"># 弹幕数</span></span><br><span class="line">coins = [] <span class="comment"># 投币</span></span><br><span class="line">share = [] <span class="comment"># 分享</span></span><br><span class="line">like  = [] <span class="comment"># 点赞</span></span><br><span class="line">score = [] <span class="comment"># 分数</span></span><br><span class="line">favor = [] <span class="comment"># 收藏</span></span><br><span class="line">reply = [] <span class="comment"># 评论</span></span><br><span class="line">rank  = [] <span class="comment"># 排名</span></span><br><span class="line"></span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">104</span>):</span><br><span class="line">    temp = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        videoData = jsonData[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;list&#x27;</span>][i]</span><br><span class="line">        score.append(videoData[<span class="string">&#x27;score&#x27;</span>])</span><br><span class="line">        title.append(videoData[<span class="string">&#x27;title&#x27;</span>])</span><br><span class="line">        author.append(videoData[<span class="string">&#x27;owner&#x27;</span>][<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line">        </span><br><span class="line">        videoStat = videoData[<span class="string">&#x27;stat&#x27;</span>]</span><br><span class="line">        danmu.append(videoStat[<span class="string">&#x27;danmaku&#x27;</span>])</span><br><span class="line">        view.append(videoStat[<span class="string">&#x27;view&#x27;</span>])</span><br><span class="line">        rank.append(videoStat[<span class="string">&#x27;his_rank&#x27;</span>])</span><br><span class="line">        reply.append(videoStat[<span class="string">&#x27;reply&#x27;</span>])</span><br><span class="line">        favor.append(videoStat[<span class="string">&#x27;favorite&#x27;</span>])</span><br><span class="line">        coins.append(videoStat[<span class="string">&#x27;coin&#x27;</span>])</span><br><span class="line">        share.append(videoStat[<span class="string">&#x27;share&#x27;</span>])</span><br><span class="line">        like.append(videoStat[<span class="string">&#x27;like&#x27;</span>])</span><br><span class="line">        cnt = cnt + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">outfile = pd.DataFrame(&#123;<span class="string">&quot;title&quot;</span>: title ,<span class="string">&quot;author&quot;</span>: author, <span class="string">&quot;rank&quot;</span>: rank, <span class="string">&quot;score&quot;</span>: score, <span class="string">&quot;view&quot;</span>: view, <span class="string">&quot;coins&quot;</span>: coins, <span class="string">&quot;favorite&quot;</span>: favor, <span class="string">&quot;reply&quot;</span>: reply, <span class="string">&quot;danmu&quot;</span>: danmu&#125;)</span><br><span class="line">outfile.to_csv(<span class="string">&quot;bilibili2.csv&quot;</span>, index = <span class="literal">False</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><p>数据加载</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd <span class="comment"># csv文件读写分析</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  <span class="comment"># 线性代数</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt <span class="comment"># 制图</span></span><br><span class="line"></span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;./bilibili.csv&#x27;</span>, index_col=<span class="string">&#x27;title&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 评分</span></span><br><span class="line">score = data[<span class="string">&#x27;score&#x27;</span>] </span><br><span class="line"><span class="comment"># 播放量</span></span><br><span class="line">view = data[<span class="string">&#x27;view&#x27;</span>] </span><br><span class="line"><span class="comment"># 投币</span></span><br><span class="line">coins = data[<span class="string">&#x27;coins&#x27;</span>]</span><br><span class="line"><span class="comment"># 收藏</span></span><br><span class="line">favor = data[<span class="string">&#x27;favorite&#x27;</span>]</span><br><span class="line"><span class="comment"># 评论</span></span><br><span class="line">reply = data[<span class="string">&#x27;reply&#x27;</span>]</span><br><span class="line"><span class="comment"># 点赞</span></span><br><span class="line">like = data[<span class="string">&#x27;like&#x27;</span>]</span><br><span class="line"><span class="comment"># 弹幕数量</span></span><br><span class="line">danmu = data[<span class="string">&#x27;danmu&#x27;</span>]</span><br><span class="line"><span class="comment"># 分享次数</span></span><br><span class="line">share = data[<span class="string">&#x27;share&#x27;</span>]</span><br></pre></td></tr></table></figure><p>绘制图像，观察数据之前的关系<br><a href="https://imgtu.com/i/R2qfcn"><img src="https://z3.ax1x.com/2021/07/03/R2qfcn.png" alt="R2qfcn.png"></a><br><a href="https://imgtu.com/i/R2qW1s"><img src="https://z3.ax1x.com/2021/07/03/R2qW1s.png" alt="R2qW1s.png"></a><br><a href="https://imgtu.com/i/R2qhXq"><img src="https://z3.ax1x.com/2021/07/03/R2qhXq.png" alt="R2qhXq.png"></a><br><a href="https://imgtu.com/i/R2qRpj"><img src="https://z3.ax1x.com/2021/07/03/R2qRpj.png" alt="R2qRpj.png"></a><br><a href="https://imgtu.com/i/R2qghQ"><img src="https://z3.ax1x.com/2021/07/03/R2qghQ.png" alt="R2qghQ.png"></a><br><a href="https://imgtu.com/i/R2q5n0"><img src="https://z3.ax1x.com/2021/07/03/R2q5n0.png" alt="R2q5n0.png"></a><br><a href="https://imgtu.com/i/R2qIBV"><img src="https://z3.ax1x.com/2021/07/03/R2qIBV.png" alt="R2qIBV.png"></a><br><a href="https://imgtu.com/i/R2qo7T"><img src="https://z3.ax1x.com/2021/07/03/R2qo7T.png" alt="R2qo7T.png"></a><br>由图像可以得出，b站综合打分的评分和各个数据之前有一定的相关性，主要为正相关。</p><h1 id="多元线性回归"><a href="#多元线性回归" class="headerlink" title="多元线性回归"></a>多元线性回归</h1><p>我们的目的是得到<br>$$f(x_i) = w^{T} x_i + b $$<br>类似的，使用最小二乘法估计w和b</p><p>利用求解公式<br>$$ \hat w^{} = (X^{T}X)^{-1}X^{T}y$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算系数矩阵w-hat</span></span><br><span class="line">w_hat = np.dot(np.dot(np.linalg.inv(np.dot(X.T, X)), X.T), Y)</span><br><span class="line"><span class="comment"># 获取b矩阵</span></span><br><span class="line">b = w_hat[-<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 获取w系数矩阵</span></span><br><span class="line">w = w_hat[:-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>看查w的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[ <span class="number">0.53588246</span>]</span><br><span class="line"> [ <span class="number">2.01063732</span>]</span><br><span class="line"> [ <span class="number">5.79443124</span>]</span><br><span class="line"> [-<span class="number">4.91889223</span>]</span><br><span class="line"> [<span class="number">17.51523907</span>]</span><br><span class="line"> [-<span class="number">3.73019387</span>]</span><br><span class="line"> [ <span class="number">0.89537493</span>]]</span><br></pre></td></tr></table></figure><p>这里发现w系数矩阵中出现了负值，经检查发现该项目对应的自变量为like和reply，即视频的点赞次数和评论数，这与实际情况是不符的，猜测是因为该自变量对结果的影响过小，导致预测出现了偏差，同时发现弹幕数量对视频评分的影响过大，远超于其他参数，显然与实际生活不符，并且作为对视频质量的估计，弹幕数也的确不能作为一个重要的参数。</p><p>因此我们对弹幕数进行剔除重新进行拟合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取自变量矩阵，剔除弹幕数</span></span><br><span class="line">X = data.iloc[:,[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>]].values</span><br><span class="line"><span class="comment"># 获取因变量矩阵</span></span><br><span class="line">Y = data.iloc[:,<span class="number">2</span>].values.reshape(-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 生成设计矩阵</span></span><br><span class="line">om = np.ones(X.shape[<span class="number">0</span>]).reshape(-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">X = np.hstack((X, om))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算系数矩阵w-hat</span></span><br><span class="line">w_hat = np.dot(np.dot(np.linalg.inv(np.dot(X.T, X)), X.T), Y)</span><br><span class="line"><span class="comment"># 获取b矩阵</span></span><br><span class="line">b = w_hat[-<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 获取w系数矩阵</span></span><br><span class="line">w = w_hat[:-<span class="number">1</span>]</span><br><span class="line">print(w)</span><br></pre></td></tr></table></figure><p>得到w的值为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[ <span class="number">0.60269881</span>]</span><br><span class="line"> [ <span class="number">2.82157809</span>]</span><br><span class="line"> [ <span class="number">5.35461617</span>]</span><br><span class="line"> [ <span class="number">3.04630747</span>]</span><br><span class="line"> [-<span class="number">3.9125348</span> ]</span><br><span class="line"> [ <span class="number">0.33063835</span>]]</span><br></pre></td></tr></table></figure><p>观察发现此时各项参数对于评分的影响已经较为接近正常水平。但是share，视频分享数对于评分的影响仍为负值，依然根据上述猜测，share对于总分的影响过小，导致拟合的结果差，因此再次剔除share字段。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取自变量矩阵，剔除弹幕数，分享数</span></span><br><span class="line">X = data.iloc[:,[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>]].values</span><br><span class="line"><span class="comment"># 获取因变量矩阵</span></span><br><span class="line">Y = data.iloc[:,<span class="number">2</span>].values.reshape(-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 生成设计矩阵</span></span><br><span class="line">om = np.ones(X.shape[<span class="number">0</span>]).reshape(-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">X = np.hstack((X, om))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算系数矩阵w-hat</span></span><br><span class="line">w_hat = np.dot(np.dot(np.linalg.inv(np.dot(X.T, X)), X.T), Y)</span><br><span class="line"><span class="comment"># 获取b矩阵</span></span><br><span class="line">b = w_hat[-<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 获取w系数矩阵</span></span><br><span class="line">w = w_hat[:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">X_test = data.iloc[:, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>]].values</span><br><span class="line">Y_predict = np.dot(X_test, w) + b</span><br></pre></td></tr></table></figure><p>得到w矩阵为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">0.59149795</span>]</span><br><span class="line"> [<span class="number">2.85961313</span>]</span><br><span class="line"> [<span class="number">4.47955342</span>]</span><br><span class="line"> [<span class="number">0.34492927</span>]</span><br><span class="line"> [<span class="number">0.35243338</span>]]</span><br></pre></td></tr></table></figure><p>绘制预测值与实际值图像<br><a href="https://imgtu.com/i/R2q7AU"><img src="https://z3.ax1x.com/2021/07/03/R2q7AU.png" alt="R2q7AU.png"></a><br><a href="https://imgtu.com/i/R2qHNF"><img src="https://z3.ax1x.com/2021/07/03/R2qHNF.png" alt="R2qHNF.png"></a><br><a href="https://imgtu.com/i/R2qbh4"><img src="https://z3.ax1x.com/2021/07/03/R2qbh4.png" alt="R2qbh4.png"></a></p><p>观察预测值与实际值的差距，发现拟合的趋势基本吻合，但仍有较大的误差</p><p>分析得出，该线性模型的拟合误差较为集中，集中在[0, 181348.81788162683]即平均误差之间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0.59149795</span>]</span><br><span class="line"> [<span class="number">2.85961313</span>]</span><br><span class="line"> [<span class="number">4.47955342</span>]</span><br><span class="line"> [<span class="number">0.34492927</span>]</span><br><span class="line"> [<span class="number">0.35243338</span>]</span><br></pre></td></tr></table></figure><p>根据权重分析各个数据对总分的影响，可以发现，收藏对于视频总评分的影响占比最高，其次是硬币数，播放数，说明哔哩哔哩对与视频的质量高低评判有一定的综合考量，播放量属于可以由视频制作人通过其他方式刷取，但是收藏量是由用户对于视频质量的高低做出的决定，因而更具代表性，更有说服力。反观实际观看体验中，有些视频制作人会以视频收藏满几万后，更新下一期视频，因为该项对视频的收益影响最大，更能给视频制作人带来实际收益。</p><p>本次线性回归的拟合可以较为准确的判断出各各数据对于视频评分的影响，但是对于视频评分的预测误差较大，但是仍能较准确的判断出视频评分所影响的视频排名，认为有如下原因：</p><ul><li>数据量过少，导致拟合程度不足</li><li>评分规则非线形模型，应该更换模型</li><li>还有其他未考虑的因素<br>如果要更准确的对视频评分进行预测，应该综合分析数据的特性，或者采用机器学习等更优秀的手段来进行求解和预测，线性回归仍有一定的局限性。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Bilibili（哔哩哔哩）是当下最热门的视频播放网站，人们在该网站对视频进行浏览，会根据自己喜好对视频进行点赞、投币、收藏、分享、回复等操作，Bilibili同时还有一个排行榜机制，记录了近期比较热门的视频，并给出了一个评分，排行榜的排序规则即根据该评分，本文将根据这些排行榜视频的各项数据，进行线性回归分析，结合实际情况找出对评分影响最大的数据。&lt;/p&gt;
&lt;p&gt;Bilibili提供了获取排行榜数据的API，因此我们可以利用该API获取实时的排行榜数据，获取的数据为json格式，经过解析，已将数据保存至Bilibili.csv文件中。&lt;/p&gt;
&lt;p&gt;本文的思路即为多元线性回归，在统计学中，线性回归（linear regression）是利用称为线性回归方程的最小二乘函数对一个或多个自变量和因变量之间关系进行建模的一种回归分析。这种函数是一个或多个称为回归系数的模型参数的线性组合。只有一个自变量的情况称为简单回归，大于一个自变量情况的叫做多元回归（multivariable linear regression）。&lt;/p&gt;
&lt;p&gt;完成了对各个自变量权重的计算，找出了对评分影响权重最高的因素，并得到了验证。&lt;/p&gt;</summary>
    
    
    
    <category term="数学建模" scheme="https://ez4zzw.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
    
    <category term="线性回归" scheme="https://ez4zzw.github.io/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>方程求根的迭代法</title>
    <link href="https://ez4zzw.github.io/2021/04/25/equtaion/"/>
    <id>https://ez4zzw.github.io/2021/04/25/equtaion/</id>
    <published>2021-04-25T05:04:57.000Z</published>
    <updated>2021-04-25T05:06:18.759Z</updated>
    
    <content type="html"><![CDATA[<h1 id="迭代法求解方程的根"><a href="#迭代法求解方程的根" class="headerlink" title="迭代法求解方程的根"></a>迭代法求解方程的根</h1><p>求解方程的根，即$f(x)=0$的数值解等问题，对于经典的二次方程等函数我们可以直接进行求解，但是对于超越方程我们不能用常规方法进行求解。因此我们可以通过使用计算机实现某些求解算法进行计算。</p><p>选取样例</p><p>$f(x) =x^3 - x - 2$</p><p>$\frac{dy}{dx} = 3x^2-1$</p><p>求解$f(x)$在[1, 2]上的零点</p><span id="more"></span><h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><p>在高中数学课本我们就接触过二分法求函数零点，根据零点存在性定理，可以保证我们得到符合要求的一个根，但是该方法局限性太大，只能求解区间内的一个根。</p><p>大致流程如下</p><p>先确定要求解的区间[x, y]，然后不断对区间进行二分，根据精度要求判断根是否合法，再根据中点值与端点值的符号是否相同缩小二分范围。</p><p>$if \ f(mid)\times f(l) &gt; 0$</p><p>$let \ l = mid$</p><p>$or \ r = mid$</p><p>Code </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math <span class="keyword">as</span> m</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x**<span class="number">3</span>-x-<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    eps = <span class="number">1e-3</span></span><br><span class="line">    h = <span class="number">1e-3</span></span><br><span class="line">    l = x</span><br><span class="line">    r = y</span><br><span class="line">    <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">        mid = (l+r)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(f(mid)-<span class="number">0</span>) &lt; eps:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">if</span> f(mid)*f(x) &gt; <span class="number">0</span>:</span><br><span class="line">            l = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            r = mid</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">answer = binary(<span class="number">1.0</span>, <span class="number">2.0</span>)</span><br><span class="line">print(np.around(answer, <span class="number">4</span>))</span><br></pre></td></tr></table></figure><p>运算结果为1.5215</p><h1 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h1><p>牛顿迭代法的基本思想为将非线性方程线性化，选取一个初始点，做切线交与x轴一点，然后继续该操作，直到根收敛或者达到精度要求。</p><p>基本流程为</p><ol><li>取任意的迭代初始值$x_0$</li><li>计算 $x_1 = x_0 - \frac{f(x_0)}{f’(x_0)}$</li><li>判断收敛性：如果$|x_1 - x_0|&lt; \epsilon \ or |f(x_1)-0| &lt; \epsilon$</li><li>令$x_0 = x_1$，保存上一步结果，继续迭代</li></ol><p>Code</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math <span class="keyword">as</span> m</span><br><span class="line"></span><br><span class="line"><span class="comment"># f(x) = x**3 - x - 2</span></span><br><span class="line"><span class="comment"># df/dx = 3x**2 -1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">df</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>*x**<span class="number">2</span> - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x**<span class="number">3</span> - x - <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">newton</span>(<span class="params">x</span>):</span></span><br><span class="line">    eps = <span class="number">1e-7</span></span><br><span class="line">    x0 = x</span><br><span class="line">    x1 = x0 - f(x0)/df(x0)</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">abs</span>(x1-x0) &gt; eps:</span><br><span class="line">        t = x1</span><br><span class="line">        x1 = t - f(t)/df(t)</span><br><span class="line">        x0 = t</span><br><span class="line">    <span class="keyword">return</span> x1</span><br><span class="line"></span><br><span class="line">answer = newton(<span class="number">1.0</span>)</span><br><span class="line">print(np.around(answer, <span class="number">4</span>))</span><br></pre></td></tr></table></figure><p>运算结果为1.5214</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;迭代法求解方程的根&quot;&gt;&lt;a href=&quot;#迭代法求解方程的根&quot; class=&quot;headerlink&quot; title=&quot;迭代法求解方程的根&quot;&gt;&lt;/a&gt;迭代法求解方程的根&lt;/h1&gt;&lt;p&gt;求解方程的根，即$f(x)=0$的数值解等问题，对于经典的二次方程等函数我们可以直接进行求解，但是对于超越方程我们不能用常规方法进行求解。因此我们可以通过使用计算机实现某些求解算法进行计算。&lt;/p&gt;
&lt;p&gt;选取样例&lt;/p&gt;
&lt;p&gt;$f(x) =x^3 - x - 2$&lt;/p&gt;
&lt;p&gt;$\frac{dy}{dx} = 3x^2-1$&lt;/p&gt;
&lt;p&gt;求解$f(x)$在[1, 2]上的零点&lt;/p&gt;</summary>
    
    
    
    <category term="Math" scheme="https://ez4zzw.github.io/categories/Math/"/>
    
    
    <category term="Math" scheme="https://ez4zzw.github.io/tags/Math/"/>
    
    <category term="Numpy" scheme="https://ez4zzw.github.io/tags/Numpy/"/>
    
  </entry>
  
  <entry>
    <title>迭代法求解线性方程组</title>
    <link href="https://ez4zzw.github.io/2021/04/25/matrix/"/>
    <id>https://ez4zzw.github.io/2021/04/25/matrix/</id>
    <published>2021-04-24T16:38:16.000Z</published>
    <updated>2021-04-25T06:34:56.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="求解线性方程组"><a href="#求解线性方程组" class="headerlink" title="求解线性方程组"></a>求解线性方程组</h1><p>在线性代数中，有一类经典问题，就是求解线性方程组，我们熟知的解法有高斯消元法，但是高斯消元法属于直接求解的方法，不适合编程计算，因此引入更适合计算机求解的迭代法。</p><p>以线性方程组：</p><p>$$<br> \left[<br> \begin{matrix}<br>   10 &amp; -1 &amp; -2 \<br>   -1 &amp; 10 &amp; -2 \<br>   -1 &amp; -1 &amp; 5<br>  \end{matrix}<br>  \right] x =<br>  \left[<br> \begin{matrix}<br>   7.2  \<br>   8.3  \<br>   4.2<br>  \end{matrix}<br>  \right]<br>$$<br>为例</p><h1 id="Jacobi迭代法"><a href="#Jacobi迭代法" class="headerlink" title="Jacobi迭代法"></a>Jacobi迭代法</h1><p>考虑线性方程组$Ax=b$</p><p>用L和U分别表示严格下三角矩阵和严格上三角矩阵</p><p>可以利用迭代公式</p><p>$x^{k+1}=D^{-1}(b-(L+U)x^{k}))$</p><p>进行迭代求解，可以通过精度控制迭代次数，还需要控制迭代是否收敛，不然迭代次数再多也无法求解。</p><p>迭代法需要给定解列向量的初值，因此初值的选取也很重要。</p><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Jacobi</span>(<span class="params">A, B, N, x</span>):</span></span><br><span class="line">    <span class="comment"># Ax=B N为迭代次数</span></span><br><span class="line">    <span class="comment"># 获得对角矩阵的数组</span></span><br><span class="line">    D = np.diag(A)</span><br><span class="line">    <span class="comment"># 获得L+U矩阵，减去对角矩阵即可</span></span><br><span class="line">    <span class="comment"># diagflat为D数组转为对角矩阵</span></span><br><span class="line">    R = A - np.diagflat(D)</span><br><span class="line">    <span class="comment"># R = L + U</span></span><br><span class="line">    print(R/D)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        <span class="comment"># 迭代过程，可以直接/D表示逆矩阵</span></span><br><span class="line">        x = (B - np.dot(R, x))/D </span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">A = np.array([[<span class="number">10</span>, -<span class="number">1</span>, -<span class="number">2</span>], [-<span class="number">1</span>, <span class="number">10</span>, -<span class="number">2</span>], [-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">5</span>]]    )</span><br><span class="line">B = np.array([<span class="number">7.2</span>, <span class="number">8.3</span>, <span class="number">4.2</span>])</span><br><span class="line"><span class="comment"># 设定迭代初始值</span></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">answer = Jacobi(A, B, <span class="number">30</span>, x)</span><br><span class="line"></span><br><span class="line">print(answer)</span><br></pre></td></tr></table></figure><p>求解结果为<br>x = [1.1, 1.2, 1.3]</p><h1 id="Gauss-Seidel迭代法"><a href="#Gauss-Seidel迭代法" class="headerlink" title="Gauss Seidel迭代法"></a>Gauss Seidel迭代法</h1><p>Gauss Seidel法使用了另一种迭代格式，获得了快的收敛速度</p><p>首先我们利用迭代求解的特性，新得到的值总会比老值更优，因此使用新值来进行迭代，即</p><p>$x^{k+1}=D^{-1}(b+Lx^{k+1}+Ux^k)$</p><p>化简</p><p>$x^{k+1}=(D-L)^{-1}(Ux^k+b)$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GaussSeidel</span>(<span class="params">A, B, N, x</span>):</span></span><br><span class="line">    <span class="comment"># 下三角矩阵</span></span><br><span class="line">    L = np.tril(A)</span><br><span class="line">    <span class="comment"># 严格上三角矩阵</span></span><br><span class="line">    U = A - L</span><br><span class="line">    <span class="comment"># 获得对角矩阵</span></span><br><span class="line">    D = np.diagflat(np.diag(A))</span><br><span class="line">    LL = L - D</span><br><span class="line">    <span class="comment"># x^&#123;k+1&#125; = (D + L)^-1 (b - Ux^&#123;k&#125;)</span></span><br><span class="line">    <span class="comment"># 输出迭代矩阵</span></span><br><span class="line">    print(np.dot(np.linalg.inv(D-LL), U))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        <span class="comment"># 使用linalg包中的inv函数求出L矩阵的逆矩阵</span></span><br><span class="line">        <span class="comment"># 使用上述迭代公式求解</span></span><br><span class="line">        x = np.dot(np.linalg.inv(L), B - np.dot(U, x))</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">A = np.array([[<span class="number">10</span>, -<span class="number">1</span>, -<span class="number">2</span>], [-<span class="number">1</span>, <span class="number">10</span>, -<span class="number">2</span>], [-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">5</span>]]    )</span><br><span class="line">B = np.array([<span class="number">7.2</span>, <span class="number">8.3</span>, <span class="number">4.2</span>])</span><br><span class="line"><span class="comment"># 设定迭代初始值</span></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">answer = GaussSeidel(A, B, <span class="number">30</span>, x)</span><br><span class="line"></span><br><span class="line">print(answer)</span><br></pre></td></tr></table></figure><p>解得x = [1.1, 1.2, 1.3]</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;求解线性方程组&quot;&gt;&lt;a href=&quot;#求解线性方程组&quot; class=&quot;headerlink&quot; title=&quot;求解线性方程组&quot;&gt;&lt;/a&gt;求解线性方程组&lt;/h1&gt;&lt;p&gt;在线性代数中，有一类经典问题，就是求解线性方程组，我们熟知的解法有高斯消元法，但是高斯消元法属于直接求解的方法，不适合编程计算，因此引入更适合计算机求解的迭代法。&lt;/p&gt;
&lt;p&gt;以线性方程组：&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt; \left[&lt;br&gt; \begin{matrix}&lt;br&gt;   10 &amp;amp; -1 &amp;amp; -2 \&lt;br&gt;   -1 &amp;amp; 10 &amp;amp; -2 \&lt;br&gt;   -1 &amp;amp; -1 &amp;amp; 5&lt;br&gt;  \end{matrix}&lt;br&gt;  \right] x =&lt;br&gt;  \left[&lt;br&gt; \begin{matrix}&lt;br&gt;   7.2  \&lt;br&gt;   8.3  \&lt;br&gt;   4.2&lt;br&gt;  \end{matrix}&lt;br&gt;  \right]&lt;br&gt;$$&lt;br&gt;为例&lt;/p&gt;
&lt;h1 id=&quot;Jacobi迭代法&quot;&gt;&lt;a href=&quot;#Jacobi迭代法&quot; class=&quot;headerlink&quot; title=&quot;Jacobi迭代法&quot;&gt;&lt;/a&gt;Jacobi迭代法&lt;/h1&gt;&lt;p&gt;考虑线性方程组$Ax=b$&lt;/p&gt;
&lt;p&gt;用L和U分别表示严格下三角矩阵和严格上三角矩阵&lt;/p&gt;
&lt;p&gt;可以利用迭代公式&lt;/p&gt;
&lt;p&gt;$x^{k+1}=D^{-1}(b-(L+U)x^{k}))$&lt;/p&gt;
&lt;p&gt;进行迭代求解，可以通过精度控制迭代次数，还需要控制迭代是否收敛，不然迭代次数再多也无法求解。&lt;/p&gt;
&lt;p&gt;迭代法需要给定解列向量的初值，因此初值的选取也很重要。&lt;/p&gt;</summary>
    
    
    
    <category term="Math" scheme="https://ez4zzw.github.io/categories/Math/"/>
    
    
    <category term="Math" scheme="https://ez4zzw.github.io/tags/Math/"/>
    
    <category term="Numpy" scheme="https://ez4zzw.github.io/tags/Numpy/"/>
    
  </entry>
  
  <entry>
    <title>常微分方程初值问题求解方法</title>
    <link href="https://ez4zzw.github.io/2021/04/23/ode/"/>
    <id>https://ez4zzw.github.io/2021/04/23/ode/</id>
    <published>2021-04-23T15:26:18.000Z</published>
    <updated>2021-04-25T07:24:31.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常微分方程初值问题"><a href="#常微分方程初值问题" class="headerlink" title="常微分方程初值问题"></a>常微分方程初值问题</h1><p>常微分方程描述了不同变量之间的变化关系，通过该关系我们可以确定变量之间的具体函数关系，但是微分方程不一定总是可解的，并且有些求解起来相当困难。给出积分曲线初始位置的状态，求解需要预测点的状态，为常微分方程的初值问题，我们可以在求解微分方程即的情况下对结果做出复合精度要求的预测。</p><p>以$f(x) = \sqrt{1+2x}$为例</p><p>有$y’=\frac{dy}{dx}=y-\frac{2x}{y}$</p><span id="more"></span><p>本文给出几种算法的原理与实现。</p><h1 id="Euler方法及其改进"><a href="#Euler方法及其改进" class="headerlink" title="Euler方法及其改进"></a>Euler方法及其改进</h1><p>从初始点开始，根据不同离散点的导数值对曲线进行预测，导数值可以通过对ODE的化简求解，做出一条折线图，最终曲线会逼近预测值。</p><p>该方法有明显的缺点就是在每一步做出抉择时，只考虑了当前的状态，并没有考虑后面的状态，因此必然会造成较大的误差，因此采用下一个结点的导数值进行修正。</p><p>具体流程如下</p><p>选取一定的步长h，一般为区间的n等分</p><p>预测下一个值$\overline{y}_{i+1} = y_i + hf(x_i, y_i)$</p><p>校正预测值$y_{i+1} = y_i + \frac{h}{2}[f(x_i, y_i)+f(x_{i+1}, \overline{y}_{i+1})]$</p><p>改写成平均化形式</p><p>$y_p = y_i +hf(x_i, y_i)$</p><p>$y_c = y_i + hf(x_{i+1}, y_p)$</p><p>$y_{i+1} = \frac{1}{2} (y_p+y_c), i =0,1,2,3,…,n-1$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 常微分方程化简</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ode</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> y - <span class="number">2</span> * x / y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> np.sqrt(<span class="number">1</span>+<span class="number">2</span>*x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Euler</span>(<span class="params">bound, start</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    bound : 预测边界值</span></span><br><span class="line"><span class="string">    start : 起始点</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    h = <span class="number">0.1</span></span><br><span class="line">    <span class="comment"># 对步长h等分</span></span><br><span class="line">    n = <span class="built_in">int</span>(bound/h)</span><br><span class="line">    x = np.zeros(n)</span><br><span class="line">    y = np.zeros(n)</span><br><span class="line">    sample = np.zeros(n)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n):</span><br><span class="line">        <span class="comment"># 获取均分后的所有点</span></span><br><span class="line">        x[i] = <span class="number">0</span>+i*h</span><br><span class="line">        <span class="comment"># 生成标准值做对比</span></span><br><span class="line">        sample[i] = f(x[i])</span><br><span class="line">    y[<span class="number">0</span>] = start</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        <span class="comment"># 预测值</span></span><br><span class="line">        yp = y[i-<span class="number">1</span>] + h*ode(x[i-<span class="number">1</span>], y[i-<span class="number">1</span>])</span><br><span class="line">        yc = y[i-<span class="number">1</span>] + h*ode(x[i], yp)</span><br><span class="line">        <span class="comment"># 使用预测值求加权平均值</span></span><br><span class="line">        y[i] = (yp+yc)/<span class="number">2.0</span></span><br><span class="line">    <span class="keyword">return</span> y, sample</span><br><span class="line"></span><br><span class="line">answer,sample = Euler(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">print(answer)</span><br><span class="line">print(sample)</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>标准值</p><p>[1.         1.09544512 1.18321596 1.26491106 1.34164079 1.41421356<br> 1.4832397  1.54919334 1.61245155 1.67332005 1.73205081 1.78885438<br> 1.84390889 1.8973666  1.94935887 2.         2.04939015 2.0976177<br> 2.14476106 2.19089023]</p><p>预测值</p><p>[1.         1.09590909 1.18409657 1.26620136 1.34336015 1.41640193<br> 1.4859556  1.55251409 1.61647478 1.67816636 1.7378674  1.79581974<br> 1.8522386  1.90732042 1.96124939 2.01420304 2.06635728 2.11789132<br> 2.16899248 2.21986124]</p><h1 id="Runge-Kuta法"><a href="#Runge-Kuta法" class="headerlink" title="Runge-Kuta法"></a>Runge-Kuta法</h1><p>Runge-Kuta法在思想上与之前的方法大致相同，都是通过若干个斜率的加权平均值来做出下一步选择。此处只给出常用的四阶Runge-Kuta的处理方式。</p><p>$K_1=f(x_i,y_i)$</p><p>$K_2 =f(x_i + \frac{h}{2}, y_i + \frac{h}{2}K_1)$</p><p>$K_3=f(x_i + \frac{h}{2}, y_i + \frac{h}{2}K_2)$</p><p>$K_4=f(x_i + h, y_i + hK_3)$</p><p>$y_{i+1}= y_i + \frac{h}{6}(K_1+K_2+K_3+K_4)$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ode</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> y - <span class="number">2</span> * x / y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> np.sqrt(<span class="number">1</span>+<span class="number">2</span>*x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RungeKutta</span>(<span class="params">bound, start</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    bound : 计算边界</span></span><br><span class="line"><span class="string">    start : 初始值f(0)</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    h = <span class="number">0.1</span></span><br><span class="line">    n = <span class="built_in">int</span>(bound/h)</span><br><span class="line">    x = np.zeros(n)</span><br><span class="line">    y = np.zeros(n)</span><br><span class="line">    sample = np.zeros(n)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n):</span><br><span class="line">        x[i] = <span class="number">0</span>+i*h</span><br><span class="line">        sample[i] = f(x[i])</span><br><span class="line">    y[<span class="number">0</span>] = start</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        <span class="comment"># 求各个点的斜率</span></span><br><span class="line">        k1 = ode(x[i-<span class="number">1</span>], y[i-<span class="number">1</span>])</span><br><span class="line">        k2 = ode(x[i-<span class="number">1</span>] + h/<span class="number">2</span>, y[i-<span class="number">1</span>] + h/<span class="number">2</span>*k1)</span><br><span class="line">        k3 = ode(x[i-<span class="number">1</span>] + h/<span class="number">2</span>, y[i-<span class="number">1</span>] + h/<span class="number">2</span>*k2)</span><br><span class="line">        k4 = ode(x[i-<span class="number">1</span>] + h, y[i-<span class="number">1</span>] + h * k3)</span><br><span class="line">        <span class="comment"># 对斜率求平均值并进行预测</span></span><br><span class="line">        y[i] = y[i-<span class="number">1</span>] + h/<span class="number">6</span>*(k1 + <span class="number">2</span> * k2 + <span class="number">2</span> * k3 + k4)</span><br><span class="line">    </span><br><span class="line">    plt.show()</span><br><span class="line">    <span class="keyword">return</span> y, sample</span><br><span class="line"></span><br><span class="line">y, sample = RungeKutta(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">print(y)</span><br><span class="line">print(sample)</span><br></pre></td></tr></table></figure><p>运行结果 ：<br>预测值</p><p>[1.         1.09544553 1.18321675 1.26491223 1.34164235 1.41421558<br> 1.48324222 1.54919645 1.61245535 1.67332466 1.73205637 1.78886107<br> 1.84391692 1.89737622 1.9493704  2.00001382 2.0494067  2.09763752<br> 2.14478481 2.1909187 ]</p><p>标准值</p><p>[1.         1.09544512 1.18321596 1.26491106 1.34164079 1.41421356<br> 1.4832397  1.54919334 1.61245155 1.67332005 1.73205081 1.78885438<br> 1.84390889 1.8973666  1.94935887 2.         2.04939015 2.0976177<br> 2.14476106 2.19089023]</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;常微分方程初值问题&quot;&gt;&lt;a href=&quot;#常微分方程初值问题&quot; class=&quot;headerlink&quot; title=&quot;常微分方程初值问题&quot;&gt;&lt;/a&gt;常微分方程初值问题&lt;/h1&gt;&lt;p&gt;常微分方程描述了不同变量之间的变化关系，通过该关系我们可以确定变量之间的具体函数关系，但是微分方程不一定总是可解的，并且有些求解起来相当困难。给出积分曲线初始位置的状态，求解需要预测点的状态，为常微分方程的初值问题，我们可以在求解微分方程即的情况下对结果做出复合精度要求的预测。&lt;/p&gt;
&lt;p&gt;以$f(x) = \sqrt{1+2x}$为例&lt;/p&gt;
&lt;p&gt;有$y’=\frac{dy}{dx}=y-\frac{2x}{y}$&lt;/p&gt;</summary>
    
    
    
    <category term="Math" scheme="https://ez4zzw.github.io/categories/Math/"/>
    
    
    <category term="Math" scheme="https://ez4zzw.github.io/tags/Math/"/>
    
    <category term="Note" scheme="https://ez4zzw.github.io/tags/Note/"/>
    
    <category term="Numpy" scheme="https://ez4zzw.github.io/tags/Numpy/"/>
    
  </entry>
  
</feed>
