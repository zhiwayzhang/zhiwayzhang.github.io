<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ACM on Coding_Panda&#39;s Blog</title>
    <link>https://ez4zzw.github.io/categories/acm/</link>
    <description>Recent content in ACM on Coding_Panda&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 11 Oct 2020 19:45:39 +0000</lastBuildDate><atom:link href="https://ez4zzw.github.io/categories/acm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Luogu3964-松鼠聚会</title>
      <link>https://ez4zzw.github.io/p/luogu3964-%E6%9D%BE%E9%BC%A0%E8%81%9A%E4%BC%9A/</link>
      <pubDate>Sun, 11 Oct 2020 19:45:39 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/luogu3964-%E6%9D%BE%E9%BC%A0%E8%81%9A%E4%BC%9A/</guid>
      <description>&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.luogu.com.cn/problem/P3964&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Luogu3964&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;
&lt;p&gt;草原上住着一群小松鼠，每个小松鼠都有一个家。时间长了，大家觉得应该聚一聚。但是草原非常大，松鼠们都很头疼应该在谁家聚会才最合理。
每个小松鼠的家可以用一个点$(x,y)$表示,两个点的距离定义为点 $(x,y)$ 和它周围的8个点 $(x-1,y)，(x+1,y),(x,y-1)，(x,y+1)$
$(x−1,y+1),(x-1,y-1),(x+1,y+1),(x+1,y-1)$距离为1。输出一个整数，表示松鼠为了聚会走的路程和最小是多少。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>51nod3143-切比雪夫距离与曼哈顿距离</title>
      <link>https://ez4zzw.github.io/p/51nod3143-%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB%E4%B8%8E%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB/</link>
      <pubDate>Sun, 11 Oct 2020 19:45:25 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/51nod3143-%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB%E4%B8%8E%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB/</guid>
      <description>&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.51nod.com/Challenge/Problem.html#problemId=3143&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;51nod3143&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;
&lt;p&gt;n位战士即将奔赴战场，他们每个人都有一个攻击值ai和一个防御值bi，现在你想设计一种装备给这n位战士，如果这件装备的攻击值为A，防御值为B，那么对于第i位战士这件装备的不匹配度为$max(|A−a_i|,|B−b_i|)$
A，B都是正整数，要让所有战士的不匹配度之和最小，求出最小的不匹配度之和$2\le N \le 100000$&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>莫队-小B的询问洛谷P2709</title>
      <link>https://ez4zzw.github.io/p/%E8%8E%AB%E9%98%9F-%E5%B0%8Fb%E7%9A%84%E8%AF%A2%E9%97%AE%E6%B4%9B%E8%B0%B7p2709/</link>
      <pubDate>Wed, 07 Oct 2020 22:04:49 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/%E8%8E%AB%E9%98%9F-%E5%B0%8Fb%E7%9A%84%E8%AF%A2%E9%97%AE%E6%B4%9B%E8%B0%B7p2709/</guid>
      <description>Description P2709 小B 有一个长为n的整数序列$a$，值域为$[1,k]$。 他一共有m个询问，每个询问给定一个区间$[l,r]$ 求：$\sum_{i=1}^k c_i^2$ 其中 $c_i$ 表示数字 $i$ 在$[l,r]$ 中的出现次数。 小B请你帮助他回答询问。
Solution 莫队算法板子题 mark
Code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#define mem(a,b) memset(a,b,sizeof(a)) #define debug cout&amp;lt;&amp;lt;0&amp;lt;&amp;lt;endl #define ll long long const int MAXN = 5e4 + 10; const int MOD = 1e9 + 7; using namespace std; struct Q{ int l, r, k; } q[MAXN]; int N, M, K; int pos[MAXN], a[MAXN], cnt[MAXN]; ll ans[MAXN]; ll res; inline void Add(int n) { cnt[a[n]]++; res += 2ll*cnt[a[n]] - 1; } inline void Sub(int n) { cnt[a[n]]--; res -= 2ll*cnt[a[n]] + 1; } int main() { ios::sync_with_stdio(false); cin.</description>
    </item>
    
    <item>
      <title>GCD-兔八哥与猎人</title>
      <link>https://ez4zzw.github.io/p/gcd-%E5%85%94%E5%85%AB%E5%93%A5%E4%B8%8E%E7%8C%8E%E4%BA%BA/</link>
      <pubDate>Wed, 07 Oct 2020 22:04:23 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/gcd-%E5%85%94%E5%85%AB%E5%93%A5%E4%B8%8E%E7%8C%8E%E4%BA%BA/</guid>
      <description>Description 兔八哥躲藏在树林旁边的果园里。果园有M × N棵树，组成一个M行N列的矩阵，水平或垂直相邻的两棵树的距离为1。兔八哥在一棵果树下。 猎人背着猎枪走进了果园，他爬上一棵果树，准备杀死兔八哥。 如果猎人与兔八哥之间没有其它的果树，猎人就可以看到兔八哥。 现己知猎人和兔八哥的位置，编写程序判断兔子所在的位置是否安全. 输入：　第一行为n，表示有n(n ≤ 100,000)组数据，每组数据的第一行为两个正整数ax和ay，表示猎人的位置，第二行为两个正整数bx和by，表示兔八哥的位置(1 ≤ ax, ay, bx, by ≤ 100,000,000)。 输出： 共有n行，每行为“yes”或“no”表示兔八哥的位置是否安全。
Solution 容易想到，兔八哥和猎人只要连线上无整数点即可，可以转化成$|a_x - b_x| 和 |a_y - b_y|$互质，即$gcd(|a_x - b_x|,|a_y - b_y|)=1$
Code #include&amp;lt;bits/stdc++.h&amp;gt;#define mem(a,b) memset(a,b,sizeof(a)) typedef long long ll; typedef unsigned long long ull; using namespace std; inline int gcd(int a, int b) { return b == 0 ? a : gcd(b,a%b); } int main() { //freopen(&amp;#34;test.txt&amp;#34;, &amp;#34;r&amp;#34;, stdin); 	ios::sync_with_stdio(false); cin.</description>
    </item>
    
    <item>
      <title>统计硬币-递推/DP</title>
      <link>https://ez4zzw.github.io/p/%E7%BB%9F%E8%AE%A1%E7%A1%AC%E5%B8%81-%E9%80%92%E6%8E%A8/dp/</link>
      <pubDate>Wed, 07 Oct 2020 22:04:23 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/%E7%BB%9F%E8%AE%A1%E7%A1%AC%E5%B8%81-%E9%80%92%E6%8E%A8/dp/</guid>
      <description>Description HDU 2566 假设一堆由1分、2分、5分组成的n个硬币总面值为m分，求一共有多少种可能的组合方式（某种面值的硬币可以数量可以为0）。
Solution 坑题，没给数据范围，只能瞎猜，一发搜索挂掉发现无法去重，但是考虑到该问题满足从1开始分配并无后效性，可以直接递推（类似背包），三种物品可选任意次
Code #include&amp;lt;bits/stdc++.h&amp;gt;#define mem(a,b) memset(a,b,sizeof(a)) typedef long long ll; typedef unsigned long long ull; using namespace std; int main() { //freopen(&amp;#34;test.txt&amp;#34;, &amp;#34;r&amp;#34;, stdin); 	ios::sync_with_stdio(false); int N, M; int ans;	int dp[2000][2000]; int n[] = {1,2,5}; cin.tie(0); int T; cin &amp;gt;&amp;gt; T; while (T--) { cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M; mem(dp,0); dp[0][0] = 1; for (int i = 0; i &amp;lt; 3; ++i) { for (int j = 1; j &amp;lt;= N; ++j) { for (int k = n[i]; k &amp;lt;= M; ++k) { dp[j][k] += dp[j-1][k-n[i]]; } } } cout &amp;lt;&amp;lt; dp[N][M] &amp;lt;&amp;lt; endl; } return 0; } </description>
    </item>
    
    <item>
      <title>中缀表达式求值</title>
      <link>https://ez4zzw.github.io/p/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</link>
      <pubDate>Wed, 07 Oct 2020 22:03:17 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</guid>
      <description>中缀表达式求值 对于表达式求值，我们通常用栈来操作。 常用的做法是先转换为后缀表达式，再利用栈来求值。 步骤如下：
 开一个栈一个储存运算符，再开一个结构存后缀表达式，可以选择string数组 每遇到一个数字，将其加入到后缀表达式种 遇到左括号，加入到符号栈种 遇到右括号，不断将栈顶元素添加到后缀表达式中，直到遇到左括号，然后弹出左括号 遇到普通运算符，只要栈顶符号的优先级不低于新符号，就不断取出栈顶元素存到后缀表达式，然后将新符号入栈，优先级顺序为乘除&amp;gt;加减&amp;gt;左括号 依次取出符号栈中剩余元素，加入到后缀表达式中 将得到的后缀表达式求值  Note 代码在取栈顶元素时容易出错，需要注意对栈为空时的判断
Code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#define mem(a,b) memset(a,b,sizeof(a)) #define debug cout&amp;lt;&amp;lt;0&amp;lt;&amp;lt;endl #define ll long long const int MAXN = 1e4 + 10; const int MOD = 1e9 + 7; using namespace std; stack&amp;lt;int&amp;gt; stnumber; stack&amp;lt;char&amp;gt; stsign; stack&amp;lt;int&amp;gt; ans; struct node { string s=&amp;#34;&amp;#34;; } a[MAXN]; int oder(char c) { if (c == &amp;#39;+&amp;#39; || c == &amp;#39;-&amp;#39;) return 1; else if (c == &amp;#39;*&amp;#39; || c == &amp;#39;/&amp;#39;) return 2; return 0; } int toInt(string ss) { int res = 0; for (int i = 0; i &amp;lt; ss.</description>
    </item>
    
    <item>
      <title>余数求和-整除分块</title>
      <link>https://ez4zzw.github.io/p/%E4%BD%99%E6%95%B0%E6%B1%82%E5%92%8C-%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/</link>
      <pubDate>Wed, 07 Oct 2020 21:47:20 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/%E4%BD%99%E6%95%B0%E6%B1%82%E5%92%8C-%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/</guid>
      <description>Description 给出整数$n,k$,计算$G(n,k)=\sum\limits_{i=1}^n=k \ mod \ i$,$1&amp;lt;=n,k&amp;lt;=1e9$
Solution 将k mod i展开可以得到$k - i*\lfloor \frac{k}{i} \rfloor$ 将求和式子展开可以得到$ \sum\limits_{i=1}^n = n*k-\sum\limits_{i=1}^n i * \lfloor\frac{k}{i} \rfloor $ 利用整除分块，可以发现，对于相同的$\lfloor\frac{k}{i} \rfloor$，即每个区间$l 到 r$，每次只需要再对i求和即可 即每次计算$(r-l+1)*\lfloor \frac{k}{i} \rfloor * (l+r)/2$
Note 在分块的时候误写为r=N/(N/i)导致调试耽误大量时间，而且交了四发才发现
for (ll l = 1, r; l &amp;lt;= N; l = r + 1) { if (l &amp;gt; K) { break; } r = min(N, K/(K/l)); ans -= (r - l + 1)*(K/l)*(l + r)/2; } Code //https://www.</description>
    </item>
    
    <item>
      <title>计算几何-平行四边形</title>
      <link>https://ez4zzw.github.io/p/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95-%E5%B9%B3%E8%A1%8C%E5%9B%9B%E8%BE%B9%E5%BD%A2/</link>
      <pubDate>Wed, 13 May 2020 22:05:25 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95-%E5%B9%B3%E8%A1%8C%E5%9B%9B%E8%BE%B9%E5%BD%A2/</guid>
      <description>Description 求平面上n个点构成的平行四边形个数。 输入 一行一个数n。 接下来n行，每行两个数x,y，表示这个点的坐标为(x,y)。 保证任意两点不重合，任意三点不共线。 输出 一行一个整数表示平行四边形个数。
Solution 按照平行四边形的性质，两组顶点的中点重合，可以统计出每组顶点的中点，再统计每个顶点的个数，排列组合一下
Note 第一发对于顶点的统计出锅了，排序条件写错，提交都要检查排序</description>
    </item>
    
    <item>
      <title>Fibonacci 矩阵快速幂</title>
      <link>https://ez4zzw.github.io/p/fibonacci-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</link>
      <pubDate>Fri, 13 Dec 2019 18:58:24 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/fibonacci-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</guid>
      <description>Description 请输出$Fib(n) mod 10000$ $n \leq 1000000000$
Solution 由于$n$的范围在$1e9$直接递推铁TLE，考虑矩阵快速幂 Fibonacci数列有如下性质 通过多次迭代 算是个板子题吧，记得在WUST新生赛做过一道想矩阵快速幂的题，然而正解是找规律QAQ，在此贴个板子。
Code #include &amp;lt;cstdio&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;string&amp;gt;typedef long long LL; const int MOD = 1e4; using namespace std; struct Matrix{ LL m[2][2]; void print(){ for (int i = 0; i &amp;lt; 2; i++) { for (int j = 0; j &amp;lt; 2; j++) cout &amp;lt;&amp;lt; m[i][j] &amp;lt;&amp;lt; &amp;#39; &amp;#39;; cout &amp;lt;&amp;lt; endl;	} } } base, ans; Matrix times(Matrix a, Matrix b) { Matrix ans; ans.</description>
    </item>
    
    <item>
      <title>Triangle Fibonacci&#43;二分查找</title>
      <link>https://ez4zzw.github.io/p/triangle-fibonacci-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Fri, 13 Dec 2019 18:58:14 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/triangle-fibonacci-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</guid>
      <description>Description 有$n$个木棍，长度为$1,2,3&amp;hellip;n$，现在要从中删掉一些木棍，使得剩下的木棍不能构成三角形，使删掉木棍的数量最少。T组数组，$T \leq 20$ $n \leq 20$
Solution 由于数据范围很小，可以直接暴力求解，依次选取两个数$a,b(a&amp;lt;b)$相加，要知道不能有任何一个数小于这个值，直接删掉$(a,a+b)$范围中的数即可 如果$n$的范围是$1e9$呢？ 通过找规律发现我们剩下的数是这样的 $1,2,3,5,8,13,21&amp;hellip;$ 这是Fibonacci数列!!!! 所以我们只需要找到$\leq n$的Fibonacci数有几个，减去就是答案 可以直接lower_bound注意处理极限数据！！！即$n==1||n==2$的情况 也可手写二分，但是二分貌似常数有点大，又考虑到第$88$个Fibonacci数就爆掉$1e9$了，所以直接便利也完全没问题
Code 暴力版本 #include &amp;lt;iostream&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std; bool vis[23]; int main() { int T; cin &amp;gt;&amp;gt; T; for (int i = 1; i &amp;lt;= T; i++) { int N, ans = 0; cin &amp;gt;&amp;gt; N; memset(vis, false, sizeof(vis)); for (int j = 1; j &amp;lt;= N - 1; j++) if (!</description>
    </item>
    
    <item>
      <title>DP? 素数筛&#43;Lucas定理&#43;费马小定理</title>
      <link>https://ez4zzw.github.io/p/dp-%E7%B4%A0%E6%95%B0%E7%AD%9B-lucas%E5%AE%9A%E7%90%86-%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/</link>
      <pubDate>Fri, 13 Dec 2019 18:57:13 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/dp-%E7%B4%A0%E6%95%B0%E7%AD%9B-lucas%E5%AE%9A%E7%90%86-%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/</guid>
      <description>Description 在杨辉三角中，从第一行第一列$(0,0)$开始，每次可选择向正下方走或向右下方走，走到第$n$行时不能超过第$n$行第$k$个元素，询问所经过路径的值的和的最小值$mod(p)$，一共有T组询问，$T \leq 100000$， $0 \leq k \leq n \leq 1e9$, 保证$p$是质数， 其中$p &amp;lt; 1e4$
Solution 名字虽然是DP，但是可以找出最优方案。 优先考虑$k \leq \frac{n}{2}$的情况，先向下走$n-k$步到达$(n-k-1,0)$ 再一路沿着右下方走，直到到达底部，即有$C_{n-k}^{0}+C_{n-k+1}^{1}+C_{n-k+2}^{2}+&amp;hellip;+C_{n}^{k}=C_{n+1}^{k}$ 通过变换$C_{n-k}^{0} = C_{n-k+1}{0}$ 再通过公式$C_{n}^{m}=C_{n-1}^{m}+C_{n-1}^{m-1}$可将上述公式合并 得到$C_{n+1}^{k}$ 所以答案为$C_{n+1}^{k}+n-k$ 当$k &amp;gt; \frac{n}{2}$时，根据对称性，令$k=n-k$即可转化成上一种情况 又发现题目涉及组合数取模，所以要用到**费马小定理**
 费马小定理: 假如$a$是一个整数，$p$是一个质数，且$gcd(a,p)=1$，即$a,p$互质，那么有$a^{p−1}≡1(modp)$
 已知$a^{p-1}≡1$，可以得到$a \cdot a^{p-2}≡1$，我们称$a$和$a^{p-2}$为在$mod(p)$意义下的乘法逆元 然而这只解决了除法取模的问题，注意到$n$的范围在$1e9$直接计算组合数又是铁套老鹅(TLE)，于是借助Lucas定理
对于质数$p$,有$C_n^m\ mod \ p = C_{\lfloor \frac{n}{p} \rfloor}^{\lfloor \frac{m}{p} \rfloor} \cdot C_{n\ mod\ p}^{m\ mod\ p} \ mod \ p$
可知$n\ mod\ p$和$m\ mod\ p$一定是小于$p$的数，可直接求解，其余部分继续用Lucas定理求解，当$m=0$的时候返回$1$
long long Lucas(long long n, long long m, long long p) { if (m == 0) return 1; return (C(n % p, m % p, p) * Lucas(n / p, m / p, p)) % p; } 有了这些工具之后就可以预处理阶乘和逆元了</description>
    </item>
    
    <item>
      <title>小兔的棋盘 组合数学</title>
      <link>https://ez4zzw.github.io/p/%E5%B0%8F%E5%85%94%E7%9A%84%E6%A3%8B%E7%9B%98-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/</link>
      <pubDate>Fri, 13 Dec 2019 18:56:57 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/%E5%B0%8F%E5%85%94%E7%9A%84%E6%A3%8B%E7%9B%98-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/</guid>
      <description>Description 小兔的叔叔从外面旅游回来给她带来了一个礼物，小兔高兴地跑回自己的房间，拆开一看是一个棋盘，小兔有所失望。不过没过几天发现了棋盘的好玩之处。从起点$(0，0)$走到终点$(n,n)$的最短路径数是$C_{2n}^{n}$,现在小兔又想如果不穿越对角线(但可接触对角线上的格点)，这样的路径数有多少?小兔想了很长时间都没想出来，现在想请你帮助小兔解决这个问题，对于你来说应该不难吧! $n \leq 35$
Solution 由于规定不能超过对角线，可用分治的思想，只考虑沿对角线分隔开的三角形的情况，对于一个三角形中，求从$(0，0)$走到终点$(n,n)$的最短路径，观察发现无论怎么走，设到达某一点时向上走了$i$步，向右走了$j$步，都有$i \leq j$这也能通过线性规划相关知识证明。不难发现只是一个类括号匹配问题，可用$Catalan$数求解，计算$C(n)$后即是在一个三角形中的解，答案是$2C(n)$
$C(n) = \sum_{i=0}^{n-1} C(i) \cdot C(n-i-1)$ 通项公式$C(n)=\frac{C_{2n}^{n}}{n+1}$
预处理$C(n)$即可
Code #include &amp;lt;iostream&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;queue&amp;gt;typedef long long LL; using namespace std; LL C[100]; int main() { C[0] = 1; C[1] = 1; for (int i = 2; i &amp;lt;= 80; i++) { LL t = 0; for (int j = 0; j &amp;lt; i; j++) t += C[j]*C[i - j - 1]; C[i] = t; } LL N; int cnt = 1; while (cin &amp;gt;&amp;gt; N) { if (N == -1) break; cout &amp;lt;&amp;lt; cnt++ &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; N &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; C[N]*2 &amp;lt;&amp;lt; endl; } return 0; } </description>
    </item>
    
    <item>
      <title>WHUT新生赛&#34;游记&#34;</title>
      <link>https://ez4zzw.github.io/p/whut%E6%96%B0%E7%94%9F%E8%B5%9B%E6%B8%B8%E8%AE%B0/</link>
      <pubDate>Sat, 16 Nov 2019 21:48:04 +0000</pubDate>
      
      <guid>https://ez4zzw.github.io/p/whut%E6%96%B0%E7%94%9F%E8%B5%9B%E6%B8%B8%E8%AE%B0/</guid>
      <description>&lt;h1 id=&#34;day--n&#34;&gt;Day -N&lt;/h1&gt;
&lt;p&gt;快新生赛了啊啊啊啊，半个多月没碰算法题了，一直在搞ToKen的前端任务，还在搞服务器的事，感觉要凉凉。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
