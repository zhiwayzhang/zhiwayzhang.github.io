[{"content":"TODO 论文在事务一致性/恢复的部分 Questions 核心思想部分需要再思考和梳理下，\n为什么采用 KV SSD 替代传统 block SSD 能够解决上述问题？ 其中，利用了 KV SSD 的什么特性？ 对文件系统哪些地方做了什么以优化？ 论文试图解决的问题：\n随着存储设备的不断发展，存储设备的性能越来越高，但当前操作系统内核的文件系统在一些操作上并不能够充分利用如今存储设备的性能。\n文件系统在执行数据写入时，需要执行大量操作维护元数据、进行硬盘的空间管理、维护文件系统的一致性，工作量大。\n核心思想：\n使用Key-Value存储接口取代传统的快设备接口。\n具体实现：\n提出Kevin，分为Kevin=KevinFS + KevinSSD\nKevinFS\n维护文件和目录到KV对象的映射关系 将POSIX系统调用转译成KV操作指令 保证KV-SSD的一致性 KevinSSD\n在存储设备中索引KV对象 对多个KV对象提供事务操作 0x00 Intro Kevin避免了大量元数据的维护带来的I/O放大\n不需要日志即可完成崩溃一致性的维护\n可以抵御文件分段后造成的性能下降\n存储的文件块通过LSM进行分部排序和索引\n0x01 BG \u0026amp;\u0026amp; Related Work 传统块设备 提供块粒度（512B or 4KB）的访问\nHDD通过维护一个间接表来处理坏块\n基于闪存的SSD通过FTL来维护逻辑块到物理地址的映射索引表，以便在异地更新的NAND上模拟可重写介质并且排除坏块。\n现有研究缓解了I/O调度、文件碎片化、日志相关问题，没能消除元数据的修改带来的I/O流量\nDevFS实现了在存储设备内部的文件系统，直接将接口暴露给应用，调用时不用发生Trap，对于元数据的维护都在存储设备端执行，移除了I/O 栈减少了通信接口的开销。缺点是需要大量的DRAM和多核心的CPU、能提供的功能有限，还限制了快照、重复数据删除等文件系统高级功能的实现。\nKV存储可以高效处理元数据和小文件的写入\nLSM-Tree LSM Tree有多级，包括$L_1,L_2,\u0026hellip;,L_{h-1},L_{h}$，h是树的高度，对于各级的大小有如下关系，$Size(L_{i+1})\u0026gt;=T*Size(L_i)$\n每层都有按Key排序的唯一KV对象。各层之间的Key范围可能会出现重叠。\nKV对象首先写入DRAM中的Memtable，当Memtable不为空时，缓存的KV对象将刷新到L1中进行持久化，当L1不为空时，KV对象刷新到L2中，依此类推。在刷新过程中会执行压缩操作来对两层之间的KV对象进行合并和排序，在排序后写回磁盘中。\n为了改善压缩操作的I/O开销，可以将所有的value存储在value log中，在LSM tree中只保存value指针，存储\u0026lt;key, value pointer\u0026gt;形式。对于失效的value要考虑垃圾回收问题。\n在对KV对象进行检索时，可能需要在多级进行查找，当在Li不匹配时，查找Li+1。为了减少多级查找的读取，可以使用布隆过滤器进行优化，当检索到目标KV对象时，LSM tree将会返回相应的value，KV分离存储的情况下，将会额外去读一次value log。\n0x02 Architecture KEVIN分为两个部分\nKEVINFS：维护文件、目录到KV对象映射的文件系统\nKEVINSSD：索引KV对象到闪存的LSM-tree\nKV Command 支持多种KV指令，同时支持事务\n作者将Key限制为256B，value大小没有限制\n文件和目录的映射 KevinFS只使用三个类型的KV对象：\n$superblock$：保存文件系统的信息，大小128B $meta$：保存文件、目录的元数据，大小256B $data$：保存文件数据，unlimited，不超过文件大小 对于目录的遍历通过ITERATE\nKey的命名遵循如下规则：\nmeta对象的key组成： 前缀m: 父目录的inode number 分隔符: 文件/目录名 data对象的key组成： 前缀d: 文件的inode number Key命名规范参考了其他论文（Kai Ren and Garth Gibson. TABLEFS: Enhancing Metadata Efficiency in the Local File System. In Proceedings of the USENIX Annual Technical Conference, pages 145–156, 2013.），本篇文章将其扩展到了存储设备层面\nKevinFS没有实现dentry，如果需要访问一个目录内的所有项目，可以通过ITERATE(m:50:, 2)，来获取两个父目录inode为50（前缀匹配给定的pattern）的子目录/文件的元数据。\n一个优化：为了防止ITERATE消耗太长时间，建议指定cnt\n一个优化：为了高效处理小文件，KevinFS将总体小于4KB的小文件的元数据和数据内容打包，I/O直接操作meta对象GET/SET来进行读写\n@TODO 一个优化：使用全路径索引来取代基于inode的索引，这提高了基于排序算法的KV存储的扫描性能，主要对seek time开销大的HDD优化比较明显\nKV对象索引 KevinSSD基本实现了传统SSD 中FTL的所有功能，将KV对象映射到闪存、分配和释放闪存的空间。\nFTL只做坏块管理和磨损均衡等简单工作。\n每个Level维护一个内存表，来记录Flash中的KV对象。表的每个记录都有\u0026lt;start key, end key, pointer\u0026gt;，其中指针指向保存KV对象的闪存页面的位置，start key和end key是页面中key的范围。key的范围可以在多个Level上重叠。为了快速查找，所有记录都按开始键排序。\nmeta和data对象的Key和Value会被分离存储。通过\u0026lt;key, value pointer\u0026gt;的方式进行存储，会有专门的flash page来分别存储这些信息（meta和data对象使用不同的flash page），key-index pages\nMeta object 在对KV对象进行检索时，可能需要在多级进行查找，当在Li不匹配时，查找Li+1。为了减少多级查找的读取，可以使用布隆过滤器进行优化，当检索到目标KV对象时，LSM tree将会返回相应的value，KV分离存储的情况下，将会额外去读一次value log。\n对目录项的更新只需要修改其元数据即可完成，而不需要修改4KB的块\nData object 为了避免对大数据的小范围更新带来的I/O高负载，KevinSSD将data object分割为4KB大小的子对象，使用单独的后缀来对他们进行表示，后缀从0开始，拼接在原始的data object Key后，因此data object的key最终构成为 $$ d:{inode\\ \\ \\ number}:{subobject \\ \\ number,start\\ with \\ 0} $$ 不需要中间表进行索引，只需要通过偏移量即可定位要修改的对象\nData object同样使用保存指针的方式将映射存储在key-index pages中，key-index pages会对键进行排序，因此属于同一个文件的subobject一般会在同一个flash page中。\n==优化==：在查找指针时，会将一整个闪存页内的数据全部取出，存储在控制器的DRAM中，减轻后续查找可能带来的负载\n缓解索引负载 使用LSM-tree由于多级查找带来额外的I/O，传统FTL的映射都保存在DRAM，因此没有额外开销。作者介绍了三种主要原因和解决方案。\n压缩操作的开销 同上文介绍的方案，通过分离Value可以显著缓解I/O的数据传输负载，对data进行分片我个人感觉反而会加大压缩操作的合并过程，即使分片后键值都是有序的。\n层级查找的开销 由于LSM-tree的特性，需要逐层进行查找，为了防止大量的顺序查找，作者使用布隆过滤器进行了优化。\n同时还缓存了热点K2V索引数据（与目标索引处在同一个flash page中的）\n为了利用大容量SSD中提供的超大DRAM，作者采用压缩存储K2V索引，并在其中插入没有压缩的K2V索引来作为二分查找的参照物。（快速在缓存中查找？不如继续用布隆过滤器）\n分散的对象带来的开销 LSM-tree允许各层之间的key范围重叠，因此有同一个前缀的目录或者文件可能被分配到不同的Level中，对于获取一个目录中所有目录、文件的操作，需要对多个闪存页进行访问。这个问题作者没有给出一个明确的方案（在压缩合并时隐式解决），但是提供了一个用户工具来主动触发合并，效率较高。\n作者对比了各种方法在随机读、局部读（？）、顺序读情况下对闪存页的读取次数，使用布隆过滤器的时候稳定会有一次读取\n使用了KevinSSD后对于SSD而言，I/O延迟有轻微的增加，整体而言效率提高了\n0x03 Implement VFS write 所有的写相关系统调用可以通过SET和DELETE来实现。\n例如unlink，只需要两次DELETE指令，移除meta和data object。\nSET时现在Memtable中保存一个KV对象，然后持久化到flash中，若Key已存在则丢弃旧的对象\nDELETE时在树上写入一个4B大小的墓碑\n失效的对象（被SET覆盖）和删除的对象在压缩期间被永久删除\nread 通过GET和ITERATE实现\n如下图所示\n执行open系统调用时，查询meta object获取文件的inode，通过GET命令实现\n执行lookup系统调用时，给定一个完整的路径/home/alice/，从根目录开始获取多个meta object，最终获取目标文件的inode\n执行read系统调用时，将GET一个data object\n执行readdir系统调用时，使用ITERATE，批量获取一组meta objects来获取inode\n相较于Ext4，KevinFS可以更好的防止文件碎片化带来的影响。\n0x04 Crash Consistency 一致性维护 通过事务即可实现原子化的操作\n事务的隔离？对==fsync==指令单独创建一个小型事务来提高效率。\nKevinFS基于KV事务的特性来维护一致性，不使用日志系统。\nKV事务的实现 使用了三个数据结构：\n事务表$TxTable$：记录事务基本信息 事务日志$TxLogs$：维护事务对象的K2V索引，存储在DRAM或者闪存中 恢复日志$TxRecovery$：用于恢复和终止事务 但是收到BeginTx指令时，KevinSSD在TxTable中创建一个对象，包含TID，当前事务的状态，与事务相关K2V索引的位置，初始状态为RUNNING。当后续指令到达后，KevinSSD将KV索引记录在TxLogs，并缓存在Memtable中。\n当收到EndTx指令后，完成事务的提交，标记事务状态为COMMITTED。将提交的KV索引同步到LSM-tree中\n","date":"2022-10-29T16:48:32+08:00","permalink":"https://blog.ipandai.club/p/osdi21-modernizing-file-system-through-in-storage-indexing/","title":"[OSDI'21] Modernizing File System through In-Storage Indexing"},{"content":"0x00 基本概念 文件的基本概念， 包含信息的比特流/块，计算机往往需要处理远高于主存容量的数据，需要使用文件来保存；文件的生命周期更长，不能存储在堆栈中；对文件的数据/信息对外进行分享的媒介。可以用于进程间的信息共享，自由性和容量上都优于共享内存的方式。\n文件系统的功能 Namespace 命名空间\n文件目录的建立、维护和检索（目录树） 存储管理\n空间管理：存储空间的分配和管理（管理空闲的块） 文件块管理：逻辑地址与存储物理地址的映射（logical offset—Physical Block number） 数据保护\n文件出现坏块 灾备 可靠性/一致性\n0x01 用户视角 文件目录操作 文件操作：\nCreate/Delete Open/Close 返回File Handle Read/Write Append 追加写入 Seek 移动文件指针 offset Getattr/Setattr 读取/修改inode中保存的文件信息 Rename 目录操作：\nCreatedir/rmdir Link 软链接、硬链接 讲目录项目指向文件的inode Unlink Readdir 读取子目录以及目录项 Rename 文件目录的构成 文件的组成：\n文件内容，字节序列 文件的元数据metadata，文件控制块，Unix系统中称为inode(index node) 目录的组成：\n本质是一种特殊的文件，内容是子目录、文件等目录项目 目录也有inode File Handle 创建原文件的一个实例对象，对其进行读写，Offset可以共享给两个File Handle，也可以每个File Handle独有各自的Offset。\nLinux VFS中为文件描述符fd，对应一个File Object，包含文件的信息，文件系统管理dentry、inode的缓存，用于查找文件在磁盘上的位置。关于Linux VFS的内容，计划再单独开个博客记录一下。\nFile Control Block (Inode) 每个文件唯一的id，包含以下结构\nBlock的信息，文件在磁盘上的位置 数据大小 Ctime创建时间，utime更新时间，access time最后一次访问时间 所有者信息，ACL(access control lists)访问控制 链接情况统计 Dirent - Directory Entry 目录项纪录子文件和子目录的名称\n每个目录项的结构\n类型 大小 字段 描述 __le32 4bytes Inode inode编号 __le16 2bytes Rec_len 目录项的长度 __u8 2bytes Name_len 文件名长度 __u8 2bytes File_type 文件类型 char[EXT2_NAME_LEN] 最大255个字符 Name 文件名 所有目录都包含的目录项包括当前目录和上级目录:.,..\n要对文件名进行4字节对齐，后面补\\0\n所有目录项顺序拼接组成目录信息，在进行查询时可以使用rec_len来计算偏移量，便于查找目录中的文件（顺序遍历）\n目录树 目录树的结构如下图所示，每个目录都有自己的inode，同时还有direntry，对其中的子目录可以构建子树，文件可以建立文件子节点\n根据Pathname查找文件的过程\n从根目录/开始查询，解析出要查询的项目 获取当前目录的目录项（可能在内存中，也可能要向磁盘请求） 比对相应的纪录是否存在于目录项中，比对成功则获取其inode 查找过程中需要考虑的问题：\n检查权限：在每级目录查找时，需要检查是否有对当前目录进行访问的权限，然后才能继续进行操作 检测是否为软链接/符号链接(Symbolic link)：目录项可能指向同一个inode，防止出现循环链接 检测是否挂载了其他文件系统，文件名可以是挂在文件系统的挂载点，若出现此类情况需要进入新的文件系统进行查找 Access Control Lists 访问控制 基本ACL纪录内容：\n记录类型 格式 Owner user::rwx Owning Group group::rwx Others other::rwx rwx为掩码形式，使用三位八进制，777为可读可写可执行，系统调用为chmod\n在文件系统中有扩展ACL，记录内容为：\n记录类型 格式 Owner user::rwx Named User user:name:rwx Owning Group group::rwx Named Group group:name:rwx Mask mask::rwx Others other::rwx 对于文件的访问权限通过Named User，Owning Group和Named Group进行授权，同时可以使用Mask设置掩码对权限进行控制，例如有权限r-x，对于Mask:mask::rw-，最终的操作权限为r--，将掩码和权限进行与操作\n不同文件系统有对ACL不同的扩展和实现\nExample int fd = open(\u0026quot;/foo/bar.txt\u0026quot;, RO)\n查找文件的inode 在根目录查找foo目录 读取foo目录的内容 在foo目录中查找bar 每次查询先在缓存中进行查找 为inode创建vnode结构 判断inode是否在inode cache中，若不在则需要从磁盘中请求 请求后创建vnode缓存 初始化File Object 生成fd，填充数据信息 返回fd给进程 0x02 实现角度 ","date":"2022-10-11T13:44:49+08:00","permalink":"https://blog.ipandai.club/p/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","title":"【存储系统】文件系统"},{"content":"本文将从操作系统内核层面去介绍Linux I/O 栈\n==涉及Linux内核的部分主要为Linux 2.6==\nLinux I/O 栈概述 Linux I/O 栈的简图如下\n下面分别简述各个层次的功能\n应用程序层 应用程序层通过系统调用向VFS发起I/O请求\nVFS层 VFS主要向用户空间提供文件系统层面的接口，同时向不同的文件系统实现提供抽象，使他们可以共存。VFS将文件系统在用户层面进行抽象，便于用户对文件进行操作。\n来自应用程序的请求到达VFS后，VFS会创建包含I/O请求信息的结构体提交给块I/O层。\nLinux在文件系统层提供三种IO访问的形式：Buffered IO、MMap 、Direct I/O。\nBuffered I/O：这种访问情况下文件数据需要经过设备、Page Cache、用户态缓存，需要进行两次的拷贝动作。\nMMap：内存映射技术，将内存中的一部分空间与设备进行映射，使得应用程序能够向访问普通内存一样对文件进行访问。使文件数据仅经过设备、Page Cache即可直接传递到应用程序。\nDirect I/O：采用Direct IO的方式可以让用户态直接与块设备进行对接，跳过了Page Cache，从磁盘和用户态中拷贝数据，提高文件第一次读写的效率，若之后需要重复访问同一数据，需要消耗比利用Page Cache更多的时间，一般用于数据库系统。\n块I/O层 系统能够随机访问固定大小的数据片的设备被称为块设备，最常见的块设备为硬盘，对块设备的访问通常是在其内部安装文件系统。操作系统为了对其访问和保证性能，需要一个子系统来对块设备和对块设备的请求进行管理。\nSCSI底层 \u0026amp;\u0026amp; 设备驱动层 块I/O层将请求发往SCSI层，SCSI就开始真实处理这些IO请求，但是SCSI层又对其内部按照功能划分了不同层次：\nSCSI高层：高层驱动负责管理disk，接收块I/O层发出的IO请求，打包成SCSI层可识别的命令格式，继续往下发\nSCSI中层：中层负责通用功能，如错误处理，超时重试等\nSCSI低层：底层负责识别物理设备，将其抽象提供给高层，同时接收高层派发的SCSI命令，交给物理设备处理\n更正：对于传统的块设备而言，服务器通过SCSI协议、SAS接口连接，个人电脑通过AHCI协议/SATA接口连接，目前主流的发展方向为NVMe协议/M.2接口。\n物理外设层 在I/O中一般为磁盘、固态硬盘等存储设备\nVFS简介 Intro VFS主要向用户空间提供文件系统层面的接口，同时向不同的文件系统实现提供抽象，使他们可以共存。\nVFS将文件系统在用户层面进行抽象，便于用户对文件进行操作。\nVFS中有四个最重要的数据结构，分别是dentry、file、inode、superblock，下文对他们分别进行介绍。\nDirectory Entry Cache (dcache) VFS提供了open，stat，chmod等系统调用，需要向他们提供文件的路径名，VFS会在dcache中去查询。\ndcache提供了非常快的查找机制将路径名转换到一个具体的dentry目录项，缓存的目录项存储在RAM中并且不会持久化到磁盘。\n在没有命中缓存时，VFS会通过查找和加载inode来创建dentry缓存，最终实现可以通过path name查找到对应的dentry目录项。\nThe Inode Object 每个独立的dentry都有一个指向一个inode的指针，inode一般保存在disc（块设备文件系统）中或者内存中（虚拟文件系统）。disc中的inode在被请求或修改时会复制到内存中，并在修改后回写到disc。多个dentry可以指向同一个inode（硬链接）\n对于查找inode的请求，VFS在父目录的inode调用lookup函数。\nThe File Object 在打开一个文件时，需要分配一个文件结构体（内核层面对file descriptor的实现），结构体内容的创建通过dentry指针来获取，文件结构体存储在进程的文件描述符表中。\n对文件的读写、关闭通过用户空间的fd来操作正确的文件结构。\n只要文件打开，它就会保持对dentry的使用状态，这同时意味着inode仍在使用。\nThe Dentry Object 目录项纪录子文件和子目录的名称\n每个目录项的结构\n类型 大小 字段 描述 __le32 4bytes Inode inode编号 __le16 2bytes Rec_len 目录项的长度 __u8 2bytes Name_len 文件名长度 __u8 2bytes File_type 文件类型 char[EXT2_NAME_LEN] 最大255个字符 Name 文件名 所有目录都包含的目录项包括当前目录和上级目录:.,..\n要对文件名进行4字节对齐，后面补\\0\n所有目录项顺序拼接组成目录信息，在进行查询时可以使用rec_len来计算偏移量，便于查找目录中的文件（顺序遍历）\nThe SuperBlock Object superblock对象表示一个挂载的文件系统，存储有关文件系统的相关信息\n注册和挂载一个文件系统 使用如下的API\n1 2 3 4 #include \u0026lt;linux/fs.h\u0026gt; extern int register_filesystem(struct file_system_type *); extern int unregister_filesystem(struct file_system_type *); 文件系统的挂载可以通过-\u0026gt;mount()方法将新的文件系统挂载到挂载点，当pathname解析解析到挂载点时，会跳转到被挂在文件系统的root。\n内核所注册的文件系统在/proc/filesystems文件中\nfile_system_type结构的定义如下\n1 2 3 4 5 6 7 8 9 10 11 12 struct file_system_type { const char *name; int fs_flags; struct dentry *(*mount) (struct file_system_type *, int, const char *, void *); void (*kill_sb) (struct super_block *); struct module *owner; struct file_system_type * next; struct list_head fs_supers; struct lock_class_key s_lock_key; struct lock_class_key s_umount_key; }; mount()方法有以下几个参数\n1 2 3 4 struct file_system_type *fs_type; int flags; const char *dev_name; void *data; Page Cache ​\t页高速缓存(Page Cache)是Linux内核所使用的主要磁盘高速缓存。在绝大多数情况下，内核在读写磁盘时都引用页高速缓存。新页被追加到页高速缓存以满足用户态进程的读请求。如果页不在高速缓存中，新页就被加到高速缓存中，然后用从磁盘读出的数据填充它 。 如 果内存有足够的空闲空间 ，就让该页在高速缓存中长期保留 ，使其他进程再使用该页时不再访问磁盘。\n​\t同时， 在把一页数据写到块设备之前，内核首先检查对应的页是否已经在高速缓存中， 如果不在，就要先在其中增加 一个新项，并用要写到磁盘中的数据填充该项。I/O数据的传送并不是马 上开始，而是要延迟几秒之后才对磁盘进行更新，从而使进程有机会对要写人磁盘的数据做进 一步的修改 (内核执行延迟的写操作)。\n​\t几乎所有的读写都依赖Page Cache，除非指定了O_DIRECT标志位，此时I/O将使用进程用户态地址空间的缓冲区，一般数据库应用会使用此方式。\n​\t对Page Cache中页的识别通过索引节点和在相应文件中的偏移量来实现。\n主要数据结构 ​\tPage Cache中的核心数据结构是address_space，该对象在页面所属的inode中，由于多个页面可能属于同一个所有者，因此多个页面可能被连接到同一个address space，该对象同时还将所有者的页面和对页面的操作建立连接。\n有关页面的操作主要有以下几个：\n==writepage== 写操作，将页写入到磁盘映像 ==readpage== 读操作，将数据从磁盘映像加载到页 sync_page 在所有者的页面已经准备就绪后，启动I/O数据的传输 wirtepages 把指定数量的所有者脏页写回磁盘 ==prepare_write== 为写操作做准备（磁盘文件系统使用） ==commit_write== 完成写操作（磁盘文件系统使用） \u0026hellip; 基数树 Radix Tree 基数树类似于字典树，通过要查找的ID的二进制序列，来一级一级的进行查找，为了减少树的高度和叶子非结点个树，可以使用2 bit或者4 bit作为树的结点。\n在内核中，Radix Tree的叶子结点保存了指向所有者页描述符的指针。\nPage Cache 中的每个文件都是一棵基数树（radix tree，本质上是多叉搜索树），树的每个节点都是一个页。\n内核通过把页索引转换为Radix Tree中的路径，使用Radix Tree来快速搜索页描述符所在的位置。内核通过页描述符可以确定页面是否为等待刷新到磁盘的脏页或其中数据的I/O传输是否正在进行。\nRadix Tree中的每一个叶子节点指向文件内相应偏移所对应的Cache项\nPage Cache处理函数 find_get_page() 传入 address space对象指针和便宜了，获取自旋锁，在Radix Tree中搜索具有指定偏移量的叶子结点，若成功找到，会增加页面使用计数器，释放自旋锁，并返回页描述符的指针，否则将释放自旋锁并返回NULL。\nadd_to_page_cache() 传入页描述符地址，address space对象的address mapping字段，页索引在地址空间的偏移量，为Radix Tree分配新节点所使用的内存分配标志gfp_mask，插入成功则返回0\nremove_from_page_cache() 获取自旋锁、关闭中断后在Radix Tree中删除节点，返回删除页的描述符指针，page-\u0026gt;mapping字段设置为NULL，将所缓存页的page-\u0026gt;mapping-\u0026gt;nrpages计数器值减1，最后释放自旋锁，打开中断。\nread_cache_page() 确保Page Cache中包括指定页的最新版本，首先检查页面是否存在，若不存在则新申请分配空间，调用add_to_page_cache插入相应的页描述符，调用lru cache add插入到该地址空间的非活跃LRU链表中。\n在保证页面存在于Page Cache后，使用mark page accessed记录页面已经被访问过，若PG_uptodate标志位0，则页面不是最新的，需要从磁盘重新读取该页\nBuffer Cache 在Linux内核2.4版本之前，Buffer Cache和Page Cache是独立的，因为操作系统对硬盘等块设备的读写是基于块的，而非页，文件的数据在Page Cache中缓存，磁盘的块数据在Buffer Cache中缓存。但是这种表示方式效率非常低，自2.4版本的内核开始，二者开始统一表示。\n因为VFS和文件系统都是通过块Block来组织磁盘上的数据，因此Buffer Cache必须存在，目前它作为Buffer Page存储在特定的页中。\n对于文件这种通过Page Cache来表示的数据，通过Page Cache来表示Buffer Cache，而对于文件的metadata，直接使用Buffer Cache来表示。\n脏页的处理 在进程修改了页面数据后，该页面就成为了脏页，并将脏页刷新到块设备上的操作延迟，这样可以显著提高系统的性能。\n为了防止硬件错误、掉电等情况导致RAM内容的丢失，以及RAM容量过大的需求，在以下情况主动刷新脏页到磁盘中：\nPage Cache太满，或脏页数量太多 脏页已经存在了较长的时间 进程请求对块设备或文件的变化进行刷新（sync、fsync和fdatasync系统调用） 文件的访问 文件的访问一般有五种模式：\n==规范模式==：由系统调用read和write来读写，read将阻塞调用进程，直到数据被拷贝到用户地址空间，write则在数据拷贝到Page Cache后立即结束 ==同步模式==：O_SYNC标志为1，影响写操作（读操作总是阻塞的），将阻塞写操作，直到数据被有效的写入磁盘。 ==内存映射模式==：文件打开后，通过系统调用mmap将文件映射到内存中，此后文件成为完全保存在RAM中的字节数组。 ==直接I/O模式==：O_DIRECT标志为1，任何读写操作都在用户地址空间和磁盘间进行传输，直接跳过Page Cache。 ==异步模式==：该模式下，文件可以通过一组POSIX API或者Linux系统调用来进行访问，异步模式下数据传输请求不阻塞调用的进程，而是在后台执行。 读文件 内核实现了read()系统调用为进程提供文件的读取功能，入口为sys_read()需要提供三个参数\n文件描述符 保存数据的缓冲区 读取字符数目的长度 对于VFS而言，首先根据文件描述符编号，内核(使用fs/file_table.c中的fget_light()函数)从进程的 task_struct中找到与之相关的文件实例，file_pos_read()函数确定读取当前文件的位置，并返回一个参数file-\u0026gt;file_pos，实际的读取操作通过vfs_read()函数来执行，该函数会判断文件是否有file-\u0026gt;f_op-\u0026gt;read方法，从而确定后续使用的函数，若不存在则会调用do_sync_read函数。最后通过file_pos_write函数来记录文件新的读写位置，通过修改file_ops的值来实现。\n为了提高在文件读取时的性能，Linux kernel提供了缓冲区和缓冲系统。\nLinux对文件的读是基于页的，内核总是一次传送几个完整的数据页。若发起read调用时数据不在RAM中，内核则分配一个新的page frame，并调取文件的相应部分填入其中，将其加入到Page Cache中，最后把请求的数据拷贝到进程的地址空间。\n大多数磁盘文件系统，使用通用函数generic_file_read来实现read系统调用。\ngeneric_file_read() 该函数有如下几个参数：\nfilp 文件对象的地址 buf 用户态内存区域的线性地址，用于存放读取出的文件数据 count 读取字符的个数 ppos 存放读操作开始处的文件偏移量，一般为filp-\u0026gt;f_pos 首先，函数初始化两个描述符：\n局部变量iovec类型的local_iov，包含buf和count字段 局部变量kiocb类型的kiocb，跟踪正在进行的同步和异步I/O操作的完成状态 然后调用__generic_file_aio_read()获取上面两个描述符的地址，返回值时文件有效读入的字节数，在该函数返回后，generic_file_read()也将终止。\n__generic_file_aio_read() 接收四个参数：\nkiocb描述符地址：iocb iovec描述符数组的地址：iov（描述等待接收数据的用户态缓冲区） iovec描述符数组的长度 存放文件当前指针的变量地址：ppos 该函数在对Page Cach触发read时的执行过程：\n调用access_ok()来检查iovec描述的用户态缓冲区是否合法 建立读操作描述符，存放与用户缓冲区有关的、正在进行的文件操作的状态 调用do_generic_file_read()，给定参数文件对象指针filp，文件偏移量指针ppos，读操作描述符地址、函数file_read_actor()的地址 返回拷贝到用户态缓冲区的字节数，对应读操作描述符的written字段 do_generic_file_read()\n写流程 ​\t很多磁盘文件系统通过通用函数generic_file_write实现write方法。write系统调用负责将用户地址空间中的数据移动到内核数据结构中，然后将数据拷贝到Page Cache中，将这些页标记为脏，然后持久化到磁盘中。\n​\twrite系统调用的结构与read同样简单。除了用f_op-\u0026gt;write和do_sync_write替换了read中对应的例程之外，二者的代码流程图几乎完全相同。\n​\t从形式上看来，sys_write与sys_read的参数相同:一个文件描述符、一个指针变量、一个长度指示(表示为整数)。显然，其语义稍有不同。指针并非指向存储读取数据的缓冲区，而是指向需要 写入文件的数据。长度参数指定了数据的字节长度。\n预取机制 ​\t很多磁盘的访问都是顺序的。普通文件以相邻扇区成组存放在磁盘上，因此很少移动磁头就可以快速检索到文件。当程序读或拷贝一个文件时，它通常从第一个字节到最后一个字节顺序地访问文件。因此，在处理进程对同一文件的一系列读请求时，可以从磁盘上很多相邻的扇区读取。\n​\t预读(Read-ahead)是一种技术，这种技术在于在实际请求前读普通文件或块设备文件的几个相邻的数据页。在大多数情况下，预读能极大地提高磁盘的性能，因为预读使磁盘控制器处理较少的命令，其中的每条命令都涉及一大组相邻的扇区。此外，预读还能提高系统的晌应能力。顺序读取文件的进程通常不需要等待请求的数据，因为请求的数据已经在RAM中了。\n缓存回写机制 缓存回写机制也就是Page Cache对脏页进行回写，将对文件的I/O修改永久持久化到磁盘上的过程，此处不再赘述。后续计划深入了解Linux内核对回写的控制。\n文件系统 文件系统作为操作系统中一个不可或缺的部分，负责在存储设备上管理、存储、获取数据、维护信息。\n在Linux中，内核通过VFS虚拟文件系统向用户提供通用的接口，向下对接各种不同的文件系统，可以有效避免不同文件系统的实现差异对上层带来影响。\next4 本部分大量内容来自kernel.org的文档\next4 Data Structures and Algorithms — The Linux Kernel documentation\next 文件系统发展历史 ext1 Extended file system，扩展文件系统。\nLinux最早使用的文件系统为Minix的文件系统，但是该系统存在文件大小限制的问题，同时性能不佳。在1992年4月，Rémy Card开发了扩展文件系统，首个版本作为Linux中的文件系统一起发行，最大支持2GB空间，同时它还是Linux中第一个使用VFS实现出的文件系统。\next2 在首个ext文件系统中，文件访问、存在inode修改以及文件内容修改没有使用独立时间戳的问题，同时最大仅支持255个字符的文件名以及2GB的空间，ext2系统除了修复了这个问题外，还在磁盘存储数据结构中预留了很多空间供未来开发使用，具有良好的可拓展性。\n由于块驱动的限制，ext2文件系统最大支持2TB的单个文件。\next3 ext3在当时性能不是很出众，但是支持从当时最流行的ext2文件系统升级，无需备份和数据恢复，同时有较少的资源占用（CPU开销）。\next3相较于ext2增加了\n日志支持 文件系统在线增长 对大目录提供HTree哈希树索引 ext3提供了三个日志级别：\n日志（最低风险）：metadata和文件内容一起写入日志中，由于还要写入文件系统，因此带来额外的性能开销。 有序（中等风险）：只将metadata写入日志，但是保证metadata提交前，文件内容会被写入。大部份发行版默认的方式。写入过程中崩溃时，文件系统会清除还没有被提交的文件修改/创建，但是对于文件的覆盖写入，可能会导致文件处于新旧文件的中间态。 回写（最高风险）：只记录metadata到日志，文件内容在日志提交前或者提交后写入。如果在日志提交前写入失败，会导致磁盘出现垃圾。 ext3存在的一些缺陷：\n没有在线的碎片整理工具 官方缺少压缩工具 不支持恢复已经删除的文件 缺少快照支持 日志中不支持校验和 使用四个字节存储Unix时间，因此在2038年1月18日之后将无法继续处理文件 ext4 ext4在Linux 2.6.28中作为功能完整稳定的文件系统发布，ext4文件系统首先兼容了原有的ext3系统，提供安全可靠的快速迁移。同时还有如下特点：\n支持更大的文件系统和文件大小\n以4KB块，目前支持最大1EiB(1024*1024*1024GB)的文件系统大小和16TiB的文件大小，使用48bit来编址，未来会支持64bit\n子目录可扩展性\next4文件系统支持最多64000个子目录，是ext3文件系统的两倍\n扩展数据块\n鼓励对大文件划分多个连续数据块，在磁盘上进行连续布局，从而减少维护大量的间接映射，有助于提高性能，减少磁盘碎片\n多块同时分配，\n在ext3文件系统中，文件系统在分配空闲块时，只能一次处理一个块申请，ext4支持多块分配机制，可以一次申请多个块\n块的延时分配\n借鉴了XFS、ZFS、btrfs等现代文件系统，在执行写入过程时，在以往的文件系统中，都是对写入到cache的数据立即分配相应的block，消耗了大量的时间，延时分配后，只有当数据需要被刷新到磁盘时，才会执行块的分配，可以和上面两个feat进行配合，提高了文件系统的性能\n快速fsck\nfsck是极其耗时的过程，主要是需要检查文件系统所有的inode。ext4中，在每个group\u0026rsquo;s inode table中都保存了一个空闲inode链表（同时保存了checksum），因此fsck就不必再检查这些inode\n日志校验和\n日志在磁盘中是很容易出错的部分，添加校验和可以避免文件系统恢复错误的日志带来更大的损失。使用校验和还使得在ext3中日志的两步提交简化为一步\n无日志模式\next4中可以关闭日志\n在线碎片整理\n使用e4defrag工具手动进行碎片整理\ninode相关feat\n更大的inode\n从128bytes提高到256bytes\ninode预留\n创建目录时预留一些inode提高性能\n纳秒级时间戳\n提高系统的time resolution\n硬盘空间预分配\n应用可以让文件系统预先分配一部分硬盘上的空间，文件系统会提前创建好相关的数据结构并分配相应的块，后续可以直接写入数据，类似P2P下载时预分配，1.可以防止类似功能的低效率应用级实现；2.减少磁盘碎片；3.对于实时应用来说（延迟敏感，航空工业等），这个特点改善了延迟。此feat通过libc posix_fallocate()实现\n默认启用写屏障\n通过消耗一些性能来改善文件系统的完整性，它确保文件系统元数据在磁盘上被正确地写入和排序，即使在掉电时也是如此，对于一些创建大量小文件或者操作元数据的程序，会带来很大的性能影响。如果硬盘是电池供电，通过barrier=0可以关闭写屏障（会保证安全性）。写屏障保护保证在数据写入缓存（磁盘缓存）后，先写入日志中的元数据刷新到磁盘，防止出现因为调度策略导致的数据先于日志写入磁盘\ndiscard/TRIM\n为SSD提供的TRIM支持。\n对于SSD而言，由于文件系统在删除时只对块标记为空闲，而SSD却并不知道哪些数据块可用，再次写入时会先清除闪存中的数据，再进行写入，要擦除无效页，要先移走有效页，然后再对一整行进行擦除，最后才能执行写入过程，这个现象也被称为写入放大(Write Amplification)。\nTRIM主要使得文件系统告知SSD哪些页不再包含有效的数据，有助于提高SSD的寿命和磨损均衡\n随着使用的block数量接近SSD的容量上限，会导致SSD的性能下降，文件系统通过discard指令告知SSD哪些范围内的block已经不再使用，SSD可以将其回收或者用来实现磨损均衡\n数据组织 ext4文件系统将部分block组织为一个group，默认block大小采用4KB，因此一个group中的block数量为8*block_size_in_bytes=32768 blocks，空间为128MB。\next4部分在磁盘中按小端写入，jdb2日志部分在磁盘中按大端写入。\next4在分配磁盘空间时只能分配若干个block，一个block包含磁盘上的若干个扇区，扇区的数量必须是2的幂次。\n不使用扩展布局的文件（通过block映射维护）必须存放在文件系统前$2^{32}$个block中，通过扩展布局来保存的文件，必须存放在前$2^{48}$个block中。\n对于32位和64位的文件系统，各个数据结构的大小限制如下图所示：\n在一个Block Group中，数据的组织如表格所示：\nGroup 0 Padding ext4 Super Block Group Descriptors Reserved GDT Blocks Data Block Bitmap inode Bitmap inode Table Data Blocks 1024 bytes 1 block many blocks many blocks 1 block 1 block many blocks many more blocks 磁盘中会预留1024 bytes，用于操作系统的引导模块安装，该padding分区只有group 0含有，为了避免supper block损坏导致整个文件系统不可用，在其他block group中还会有备份，如果一个block group不含有冗余备份，那么它将以data block bitmap开头。\n在执行mkfs时，还会在group descriptor描述符分区和data block bitmap分区之间分配一个保留的GDT blocks分区，用于文件系统日后的扩展。\next4文件系统中还引入了Flexible Block Groups的概念(flex_bg)，主要思想是将若干个block group组合成一个大的Group，将所有block group中的元数据（inode，bitmap）都集中到第一个block group中，提高对元数据加载和查询的效率，并且使得文件数据在磁盘上连续，更紧凑。一般通过2^sb.s_log_groups_per_flex个block group来组成一个大的Group。\n自ext3起，ext文件系统就开始使用Meta block groups(META_BG)，是一组只用一个group descriptor来描述的block groups，首个block group不再存储每个block group的描述符，转由meta block group来存储，并且会在其中存储几个冗余副本。\n对于ext4文件系统的读写流程计划在此后单独写一篇文章进行总结。\nF2FS F2FS文件系统提出于USENIX FAST'21，F2FS: A New File System for Flash Storage | USENIX\n全称为Flash-Friendly File System，基于日志结构文件系统(Log-structured File System, LFS)，针对LFS中wandering tree和gc开销大的问题进行了优化。\n主要特点 针对闪存进行了优化：\n扩大随机写入区域来提高性能，但带来了空间局部性 尽可能使得文件系统的处理单元与FTL中保持一致 针对wandering tree问题，该问题是因为LFS的脏数据通过追加更新，如果一个数据块变成脏数据，那么其索引块，以及间接索引块都会变成脏块：\n使用node来代替inode和指针块 通过包含所有node块地址的Node Address Table(NAT)来切断更新递归的传播 垃圾回收问题：\n支持后台清理 支持贪心和cost-benefit算法 为动态/静态冷热数据分离提供multi-head logs 引入自适应日志来实现高效的块分配 Btrfs Btrfs是一个写时复制的文件系统，基于B-tree实现，专注于容错，修复和易于管理，发布于2014年，发展目标是为了取代ext3文件系统，解决ext3的限制。在2021年，Fedora 33宣布将使用Btrfs作为安装时默认的文件系统。而Fedora受到redhat的直接赞助，说明Btrfs在不断发展的过程中，得到了社区中部分用户以及企业的认可，目前还处在测试和不断完善的阶段。\n主要特点\n基于B-Tree维护元数据，插入查询操作高效 基于COW，提高磁盘寿命 支持只读/可读快照 块I/O层 与 I/O调度器 块设备 对于Unix系统来说，有着一切皆文件的设计哲学，因此外部设备在操作系统看来是一个设备文件。设备文件共分为两种：\n块设备：数据可以被随机访问 字符设备：数据不可以被随机访问，或者包含受限制的随机访问（设备内部构成） 块设备的一个主要特点就是CPU和总线读写数据的时间开销与磁盘硬件速度不匹配。\n内核再对块设备发出I/O请求时，内核利用通用块层发起I/O，每次I/O请求都是通过一个bio结构体来描述。通用块层下的I/O调度程序会根据策略将待处理的I/O请求进行归类，将相邻的请求聚集在一起，减少磁盘磁头的移动。\n块是操作系统和硬件设备在传输数据时的基本单位，\nmq-deadline bfq kyber NVMe接口协议 简介 NVMe协议的产生是为了取代固态硬盘原有的AHCI协议+SATA接口，随着固态硬盘技术的发展，使得性能瓶颈从存储设备上的转移到了协议和接口中，于是固态硬盘的几大生产商一起制定了该协议。\nNVMe实际上是非易失性存储器标准，不限于闪存SSD，使用PCIe接口。\n相比于AHCI协议，NVMe的主要特点为：\n低时延：存储介质方面，存储介质得到了巨大提升；控制器方面，PCIe主控直接与CPU相连，SATA接口需要南桥控制器中转再连接CPU；软件接口方面，简化了指令路径，提高了并发能力 高性能：相较于AHCI做出了大量优化 低功耗：自动功耗状态切换，动态能耗管理 NVMe工作原理 NVMe作为高层次的协议，原则上可以用于任何接口，一般使用PCIe\nNVMe制定了主机和SSD之间的通信命令，NVMe共有两种命令：\nAdmin命令：用于主机管理、SSD控制 I/O 命令：用于主机和SSD之间的数据传输 Admin命令集有：\nNVM I/O指令集有：\n从主机I/O请求到SSD NVMe有三个重要的机制，Submission Queue、Completion Queue、Doorbell Register。\nSQ和CQ位于主机的内存中，DB位于SSD控制器内部，下图直观的展示了他们之间的位置关系。\n在主机发起I/O指令时，现将指令放在SQ中，主机会通过修改DB寄存器来通知SSD从SQ中取出需要执行的指令。CQ记录了指令执行的状态（成功/失败），SSD负责向CQ中写入命令的状态。\nNVMe对指令的处理流程可以用下图来概括：\n主机写请求到SQ 主机写SQ尾DB寄存器，通知SSD需要执行I/O请求 SSD控制器取出SQ中的请求 SSD控制器执行命令 SSD控制器将请求的状态写入CQ SSD控制器发出MSI-X中断，通知主机指令完成 主机收到中断后，处理CQ，看查请求的完成状态 主机写入CQ头DB寄存器，告知SSD该指令的结果已经收到并处理 Submission Queue和Completion Queue简介 由于NVMe的SQ、CQ机制，这两个数据结构必然是成对存在的，也存在多对一的关系。\n对于I/O指令和Admin指令，分别由专有的SQ和CQ进行管理，即Admin SQ/CQ和I/O SQ/CQ。\nI/O SQ和SQ是通过Admin的相关指令来进行创建的。\n主机方面每个CPU核心可以有一个或者多个SQ，但是只能有一个CQ。一个核心创建多个SQ主要是为了提高多线程的并发能力，同时可以对不同SQ设置优先级来提高服务质量。\n对于Admin SQ/CQ队列，深度在$2-4096(4K)$\n对于I/O SQ/CQ队列，深度在$2-65536(64K)$，一个SQ命令条目大小为$64Byte$，一个CQ条目大小为$16Byte$，队列深度可以自行配置。\n一个PCIe接口也支持多个lane。\n整个NVMe的工作流程像是如下图所示的两个生产者消费者模型\nDB: Doorbell Register 在SQ和CQ队列中都有Head和Tail，并且分别有对应的Doorbell，即Head DB和Tail DB，DB在SSD一端，记录SQ和CQ队列头、尾的位置。\n对于SSD而言，要频繁从SQ头取出数据，可以轻松的获取SQ队头的位置，所以SQ Head DB由SSD来维护，而对于SQ的队尾对于主机而言更容易维护，因为要频繁的向队尾插入数据，因此SQ Tail DB由主机维护，SSD根据SQ的头尾可以获取当前队列中有多少请求在等待执行。同理，CQ Head DB由主机来维护，CQ Tail DB由SSD来维护，SSD根据CQ队列的头尾来判断CQ队列是否还能接受新的请求完成信息。\n从Doorbell的名字来看，还有通知的作用，当Doorbell Register的值改变时，SSD就知道有新的请求需要处理；主机就知道有新的请求已经完成了。\n注意：对于主机来说，DB是可以写不可读的。\n其他有关NVMe的内容 寻址问题（PRP、SGL）\nNamespace\n数据保护问题\n后续有时间再对这些内容进行学习\n基于闪存的固态盘 此前一篇博客整理了有关闪存和固态盘的内容，下文为转载过来的内容\nFlash Memory \u0026amp;\u0026amp; 固态硬盘\n主要由Flash Memory 和FTL组成\nNon-Volatile Memory 提供低延迟持久性的内存/存储，也可以用来做内存\n根据延迟数量级，一般用PCM做内存，Flash Memory做外存\nFlash Memory 闪存原理 类型 NOR闪存\n存储密度低 可字节改写 NAND闪存（主流）\n存储密度高 不可覆盖写 用于外存需要较高的存储量级，一般用NAND\n闪存单元 读：电压代表不同数值\n写：电子注入\n相比晶体管添加了浮栅门，保存电子\n原理其实比较简单，非电子系就不做太详细的研究了\n闪存页(4KB,8KB,16KB，读写单元)，阵列中的每一行\n闪存块(擦除单元)，由多个页组成的单元\n选中行和列，然后将数据加载到Sense Amplifiers\n存储单元有两个阈值的电压，可以根据两个电压的中点作为读电压，2.5V读电压时左边通电，数据为1，右边则不通电，数据为0\nPass Through\n选取一个较大的电压，使得所有的单元都接通，数据为1，不影响其他行的状态\n如图所示的存储结构，在第二行施加2.5V电压，其他行施加5V，最终读取数据为0011\n上述为SLC，Single Level Cell，单存储单元\n多比特闪存 多比特闪存单元MLC，包含2Bits 4个Level的数据\nTLC 3 Bits 8个Level\nQLC 4 Bits 16个Level\n多比特使用格雷码来编码\n使用格雷码使得相邻单元只有一位差异，方便纠错\n多比特提高了存储密度，但是提高了错误率，因为施加的电压差距很小。可靠性会降低。\n对于多比特的写，MLC分为高比特和低比特，对于低比特的状态加偏移电压确定高比特，在低比特时需要加的电压较大，操作难度低，运行速度快，在高比特时需要加的电压小，波形的间距小，操作难度高，运行的速度较慢。\n对于多比特的读，先看lower bit，加一次电压，即可筛选出低位的0，1，再加两次电压确定upper bit。因为upper bit为0的在中间部分，为1的在两侧，因此需要在两个分界线分别加一次电压来确定upper bit为多少。\n闪存 Block的大小的一种配置：\n一行有两个Page，Upper Page和Lower Page，每个单元中，低位构成Lower Page，高位构成Upper Page，有128个单元，128K/8=16KB\n有64列bitlines，一个block的大小即为16KB*64*2=2MB，一般按照此比例配置Block\n写入时按照固定顺序，写入高低页面相互独立，不能同时写，在写入加压时容易使相邻单元发生数据偏移，要降低错误率\n写入是需要先擦除再写入，擦除整个块\n闪存特性 读写粒度 闪存页读写粒度：\n4KB，8KB，16KB必须全部读取或者写入 us延迟 闪存块擦除力度\n2MB擦除 ms延迟，可以通过FTL来优化 不可覆盖写 写前需要擦除，读写粒度与擦除粒度不同\n存在64bytes的OOB（out of bound area），保存ECC，用于纠错，容忍写入时部分比特出错\n有限次擦除 随着擦除次数的增加，存储单元不能可靠的保持状态（存储数据）。\n氧化层老化变薄，束缚电子能力变弱\n耐久性 变薄地次数 保持力 不通电可以放置的时间 SLC：10w次\nMLC：1w次\nTLC：1k次\n根据特性来设计FTL固件\nFTL 固态硬盘整体构成\nSSD中的通道可以并行，通道中也可以并行读取，每个Plane中有寄存器，暂时存储准备好的数据。不同单元并行，因此内部带宽大\n垃圾回收 page对于OS而言，是写入时的block\nPage三种状态\n空闲 free page 有效页 live/valid page 无效页 dead/invalid page 需要擦除无效页，先移走有效页，然后再对一整行进行擦除，转为空闲\n时间开销：\n复制有效数据到$(R_{Latency}+W_{Latency})*N$，N是移动page的数量 擦除产生的开销 ms级延迟 GC策略 要解决的问题：\n何时启动GC 选中那些/多少Block进行GC 有效的页如何被转写 新数据写到哪里 GC的时间开销：\n块擦除的时间 ms 有效页的复制时间 贪心策略：\n找到脏页最多的block来进行擦除 优化：\nAge Hot/Cold 数据隔离，分组问题 磨损均衡 优化寿命，有静态和动态策略\n静态：周期性的调整冷热数据存储的位置\n冷热数据的分区：将冷数据放在一起，热数据放在一起\nFTL简介 维护映射，虚拟地址到物理地址\n使用SRAM存储映射\n向上层隐藏擦除操作：\n避免原地更新-\u0026gt;异地更新\n更新一个新页面\n高性能的垃圾回收和擦除\nOOB有物理地址到虚拟地址的映射，用于掉电恢复，这里引用一段wisc的OSTEP中的一段解释（44 Flash- based SSD）。\nOOB保存的在每个页中映射信息，当掉电或者重启时用它在内存中重建映射\n为了防止在重建时扫码整个SSD，可以使用日志或者检查点的方式来加速这个过程\n大致看了一下OSTEP，是有关操作系统的一本非常好的书，希望以后有时间读一下\nPage-Level FTL 原理类似OS中的页表，由Logical Page Number查询页表得到Physical Page Number\n缺点是页表占用很大的空间\nBlock-Level FTL 保持Block 到Block的映射\n先查找到对应的Block，在根据offset得到page，块内的页码偏移offset是固定的\n优点是占用空间很小，缺点是GC负载增加\n原因：offset在不同Block中保持不变，在异地更新时，要选择其他block中相同的offset进行写入，如果选中的block已经存在数据，需要把数据迁移。【TODO 这里讲得不是非常的清楚】\nHybrid FTL 对写入分为新/旧数据，新写入的数据用Page-Level Mapping效率高，写入Log Blocks作为缓冲，之后再更新到Data Blocks\n旧数据因为写入后更新相对不频繁，使用Block-Level Mapping，写入Data Blocks\nReference NNSS实验室暑期实习文档 《Linux内核设计与实现》 《深入理解Linux内核》 《Linux设备驱动程序》 《深入浅出SSD：固态存储核心技术、原理与实战》 NAND, DRAM, SAS/SCSI and SATA/AHCI: Not Dead, Yet | Enterprise Storage Forum 【Quora】Robert Love对缓冲区缓存和页面缓存的主要区别是什么的回答？为什么它们在较旧的内核中是独立的实体？为什么后来他们被合并了？ 【OSTEP】Operating Systems: Three Easy Pieces (wisc.edu) 【bilibili 清华大学】存储技术基础 【kernel.org Ext4文件系统介绍】Ext4 Howto - Ext4 【kernel.org Btrfs文件系统现状】Status - btrfs Wiki 【kernel.org Ext4文件系统设计】ext4 Data Structures and Algorithms 【USENIX FAST'21】F2FS: A New File System for Flash Storage 【archlinux.org ArchWiki】Ext4 【Red Hat Customer Portal | SSD discard】Chapter 21. Solid-State Disk Deployment Guidelines Red Hat Enterprise Linux 7 ","date":"2022-10-09T13:44:18+08:00","permalink":"https://blog.ipandai.club/p/linux-block-i/o-stack%E7%AE%80%E4%BB%8B/","title":"Linux Block I/O Stack简介"},{"content":"0x00 多硬盘系统 对多硬盘系统可靠性的度量，上图从故障产生，故障产生程序错误，错误检测，修复故障四个时间节点为一个周期。\n三个可靠性的指标：\n可靠性：通过错误产生到发现错误的时间间隔MTTF来衡量\n可维护性：通过发现错误到错误修复的时间间隔来衡量，定义系统修复的能力\n可用性：通过系统中非修复时间所占的比例，可以对外提供服务的时间占比，$EA=\\frac{MTTF}{MTTF+MTTR}$\nMTBF=MTTR+MTTF，两故障之间的时间间隔\n恢复一块硬盘的代价很高，为了提高系统可用性，需要构建多盘系统，在某块磁盘故障时仍然能正常工作。\n每秒的I/O请求峰值为1200，R/W比例为2:1，分别使用RAID 1/5，计算峰值的硬盘负载\n总的R/W分别为800/400\nRAID 1：写操作需要翻倍，总负载为800+400*2=1600\nRAID 5：写操作翻四倍，总负载为800+400*4=2400\n使用多盘系统的目的：\n提高存储容量 提高性能 负载均衡 Disk Striping 带宽 吞吐量 提高可靠性 容错 基于奇偶校验的保护 创建副本 JBOD（Just a Bunch Of Disks）单纯对硬盘进行组合，只提高存储容量\n负载均衡 静态：某一地址固定映射到某块硬盘\n动态：热点数据分配到不同的硬盘中\n按照数据块：将一个数据划分后存储到所有硬盘中（Disk Striping 条带化）\nDisk Striping 按一定大小对数据分块（stripe unit/block），然后依次存储到各个硬盘中\n分配规则使用轮询枚举，通过取模判断存储的磁盘编号，根据余数确定偏移量\nStripe Unit大小设置一般为2M、4M、16M，太大丧失负载均衡能力，太小会在寻址上花费太多时间\n磁盘失效 对于JBOD、Striping某块盘失效，整个文件系统都将失效\n可以通过备份来解决，要花费较长的时间\n多盘系统的MTTF为第一块磁盘失效的时间，比单盘系统时间短很多\n解决方案：Redundancy冗余存储\nRedundancy 存储副本 存储两份或更多的副本，采用三副本的服务有HDFS/GFS/Cloud Storage\nDisk Mirroring 磁盘镜像，分主从磁盘，从盘基于主盘进行同步，可以从任意盘进行读取\n有较高的可用性\n花费较高\n写性能降低，磁盘之间需要同步，受限于最慢同步的磁盘\n读性能提高，请求被分散到各个磁盘\n磁盘镜像可以与结合条带化\n先做Mirroring再做Striping (RAID 10)\n若有磁盘故障，会损失1/2的数据\n先做Striping再做Mirroring (RAID 01)\n若有磁盘故障，不会影响整体的读写，可以保证可靠性\nShadowing 不对外服务，只充当备份\nDuplexing 可进行交换\nECC(Error-Correcting Codes) 纠错码常用方案有RAID，纠删码，奇偶校验\nParity Disk 增加一块检验盘，保存其他盘上数据的异或值\n奇偶校验：统计数据中1的个数，奇数为1，偶数为0\n43:25\n0x01 RAID 通过廉价磁盘构建可靠大型高端存储，类似MapReduce通过廉价服务器来构建高性能计算集群\nRAID 0 条带化，无冗余存储\nRAID 1 Mirroring\nRAID 2 条带化+海明码冗余存储\nRAID 3 条带化+奇偶校验 细粒度\nRAID 4 块条带化+奇偶校验 粒度大\nRAID 5 块条带化+条带化的奇偶校验\nRAID 6 块条带化+两个条带化的奇偶校验\nRAID 0无容错，RAID 1-5支持一个单位的容错，RAID 6支持两个单位容错\n","date":"2022-10-05T16:54:42+08:00","permalink":"https://blog.ipandai.club/p/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E5%A4%9A%E7%A1%AC%E7%9B%98%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/","title":"【存储系统】多硬盘存储系统"},{"content":"0x00 主存 当前面临的问题：\n容量问题、带宽问题、QoS保证\n多核处理器、数据密集应用、云计算、GPU\nHDFS（GFS）基于外存储器\nSpark 内存中数据处理\n能耗功率问题\n40%功耗在DRAM，Refresh操作耗能\nDRAM发展遇到瓶颈\n制成方式限制\n改进：\n3D-Stack DRAM 提供更高的带宽 低延迟DRAM 低功耗DRAM NVM（e.g. PCM）容量更大，延迟较高 0x01 DRAM的组成 Channel DIMM 内存条 Rank 二维阵列最小单元 Chip 芯片 Bank Row/Column 行为字线 word line\n列为位线，交点是cell 内存单元\nDRAM row是一个DRAM page\nSense Amplifiers 也被叫做Row buffer\n每个地址通过\u0026lt;row,colum\u0026gt;编址\n访问一个closed row的过程：\nActivate：将row放到row buffer中 Read/Write：读写row buffer中的column Precharge：从row buffer中的数据写回到选中的row中 Bank Operation 给定Row Address通过Row decoder选中一行\n将行加载到Row Buffer\n若读取的Row在Row Buffer中，则为命中Hit状态，通过Column Mutex直接获取数据\n若读取的Row不在Row Buffer中，则为冲突Conflict状态，将Row Buffer回写，然后再选中新的Row，读取数据\nChip 由多个(2-16个)Bank组成，Bank共享总线（指令/地址/数据总线）\n每次只能读4或16 Bit\nRank and Module Module为DIMM内存条，连接在主板上，由一个或多个rank组成\nRank由多个Chip构成，提高接口带宽，多个Chip共享地址和指令总线，有单独的数据总线\n多个Chip可以并行操作\n对于64 bit的读取，分配到多个Chip中同时读取\n对于多DIMM情况，可以先确定在哪根DIMM条中，再进行读取操作\nChanel Bank之间为分时共享\nChannel为独立总线，数据可同时读写，每个Channel有一个Memory Controller\n在同一个Channel中的DIMM数据分时共享\n一张比较清晰的结构关系图\n同一个Channel可以连接多个DIMM条\n从CPU访问角度观察 Memory Channel中，在DIMM中Chip Selection选择访问的Rank，通过地址确定访问的数据\nRank中的8个Chip每个都提供8 bit，共提供8 Byte访问\n由每个Chip中的bank选择器从8个bank中选择一个获取8 bit\nBank中通过Row-Buffer来获取数据\n延迟的产生：\nCPU到controller的传输时间 Controller延迟，请求队列和调度 Controller到DRAM的传输时间（总线） DRAM 中Bank的延迟 选择某一行 Activate 读取的时间 Precharge DRAM到CPU的传输时间 主要关注Bank中的延迟\nMultiple Banks 使DRAM访问并行\n由于不同Bank分时共享，可以使得Bank提前将row加载到Row Buffer中，提高利用率\nMultiple Channels 更容易实现\n提高总线带宽\n提高并发能力需要减少Bank和Channel的冲突问题，需要对编址策略进行优化\n比较直观的观察Multiple Banks优化的效果，达到Overlap的效果\nAddress Mapping 地址映射对DRAM并发能力的影响\n将访问DRAM中数据的地址进行排列，包含Channel、Row、Bank、Column\n核心思想：调整容易产生冲突的地址，使其相对靠后，还要兼顾其他问题\n将Column的高8位和低3位分离\n提高Row Buffer的利用率，倒数第二种比较常用\n对OS而言，由逻辑地址Virtual Address映射到物理地址\nVirtual Page Number -\u0026gt; \u0026lt;Row,Bank\u0026gt;，可以通过调整映射算法来优化存储效率\n0x02 DRAM Refresh 由于电容中的电子持续泄漏，每隔一段时间重新写入数据，读取到row buffer再写回，刷新间隔一般为64ms\n负面影响：\n能耗增加 性能减少，Refresh中内存不可用 QoS影响，不能保证平稳 刷新率使得DRAM容量的扩展受限 性能影响 刷新时Bank变得不可用，Row Buffer的占用\n在刷新结束前有长时间的暂定，有两种优化策略：\nBurst Refresh 所有的行依次全部刷新 Distributed Refresh 每行以固定的时间间隔在不同的时间进行刷新 两种方式（集中式/分布式）的示意图：\nDistributed Refresh减少了等待时间\n随着设备容量的增加，消耗在Refresh上的时间/能耗占比越来越大\n目前应用的策略：Auto Refresh，每次只Refresh其中几行\n一些探索：刷新间隔的调整，64ms保证在最坏情况下的可靠性，在容忍存储单元出故障的前提下，可以适当提高刷新间隔，对于出错的单元采用更低的刷新间隔（不同存储单元采用不同刷新频率）\n0x03 Memory Controller 位于CPU中\n基本功能：\n保证DRAM的正确性，刷新和时序timing 遵循一定的时序约束（bank，总线，channel的冲突）来完成DRAM请求，转换请求为DRAM Command 对请求进行调度提高性能 管理电源能耗，开关Chip，管理电源模式 由L2 Cache发送请求到Memory Controller，由一个Buffer来对请求进行缓存\n请求调度策略 FCFS\nFR-FCFS,First Ready\nRow-Hit First，优先调度命中Row Buffer的请求，提高命中率 FCFS 防止饥饿 Row Buffer管理策略 Open Row 不预先执行Precharge回写\nClosed Row 预先回写\n自适应结合两种方案\nDRAM Controller的设计难点 时序约束\n防止冲突的发生\nRefresh操作\n能耗管理 在不访问chip时切断供电\n厂商提供多种不同功耗的工作状态\n状态过渡时Chip无法被访问，因此会产生延迟\n0x04 NVM 读 写 特点 e.g. Charge Memory电荷存储器 通过检测电压V读取数据 通过捕获电荷Q写入数据 通过写放大器来读写，体积不能太小 DRAM, Flash Resistive Memory电阻式存储器 通过检测电阻R 通过脉冲电流$\\frac{dQ}{dt}$写入数据 写数据调整阻抗 PCM, STT-MRAM，memristors PCM 通电加热会改变状态结晶态/非晶态，阻抗发生变化，表示0/1\n写 两个状态：\nSET：保持低电压，将介质变为结晶态 RESET：提高温度变为非晶态 读 检测结晶态($10^3-10^4\\Omega$)/非晶态($10^6-10^7\\Omega$)的阻抗，两者数量级差距较大\n优势 比DRAM，Flash有更高的扩展能力，存储密度\n每个单元的存储密度提高\nNon-Volatile，不通电情况下可以保存10年以上（85摄氏度）\n不需要Refresh操作，低功耗\nMLC-PCM 根据电阻划分多个bit，控制距离间隔\n延迟相较于DRAM高\n动态能耗高于DRAM\n写寿命较低\nSTT-MRAM 自旋距磁存储器\n电流改变磁介质方向，改变阻抗\nReference Layer和Free Layer方向相同表示0，相反时表示1\n优势 容量大，造价低\n非易失\n功耗低\n缺点类似于PCM\nMemristors/RRAM/ReRAM 改变原子结构\nReference 存储技术基础—Main Memory I\n存储技术基础—Main Memory II\n","date":"2022-09-24T18:26:22+08:00","permalink":"https://blog.ipandai.club/p/%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E4%B8%BB%E5%AD%98/","title":"【存储技术基础】主存"},{"content":"主要由Flash Memory 和FTL组成\nNon-Volatile Memory 提供低延迟持久性的内存/存储，也可以用来做内存\n根据延迟数量级，一般用PCM做内存，Flash Memory做外存\n0x00 Flash Memory 闪存原理 类型 NOR闪存\n存储密度低 可字节改写 NAND闪存（主流）\n存储密度高 不可覆盖写 用于外存需要较高的存储量级，一般用NAND\n闪存单元 读：电压代表不同数值\n写：电子注入\n相比晶体管添加了浮栅门，保存电子\n原理其实比较简单，非电子系就不做太详细的研究了\n闪存页(4KB,8KB,16KB，读写单元)，阵列中的每一行\n闪存块(擦除单元)，由多个页组成的单元\n选中行和列，然后将数据加载到Sense Amplifiers\n存储单元有两个阈值的电压，可以根据两个电压的中点作为读电压，2.5V读电压时左边通电，数据为1，右边则不通电，数据为0\nPass Through\n选取一个较大的电压，使得所有的单元都接通，数据为1，不影响其他行的状态\n如图所示的存储结构，在第二行施加2.5V电压，其他行施加5V，最终读取数据为0011\n上述为SLC，Single Level Cell，单存储单元\n多比特闪存 多比特闪存单元MLC，包含2Bits 4个Level的数据\nTLC 3 Bits 8个Level\nQLC 4 Bits 16个Level\n多比特使用格雷码来编码\n使用格雷码使得相邻单元只有一位差异，方便纠错\n多比特提高了存储密度，但是提高了错误率，因为施加的电压差距很小。可靠性会降低。\n对于多比特的写，MLC分为高比特和低比特，对于低比特的状态加偏移电压确定高比特，在低比特时需要加的电压较大，操作难度低，运行速度快，在高比特时需要加的电压小，波形的间距小，操作难度高，运行的速度较慢。\n对于多比特的读，先看lower bit，加一次电压，即可筛选出低位的0，1，再加两次电压确定upper bit。因为upper bit为0的在中间部分，为1的在两侧，因此需要在两个分界线分别加一次电压来确定upper bit为多少。\n闪存 Block的大小的一种配置：\n一行有两个Page，Upper Page和Lower Page，每个单元中，低位构成Lower Page，高位构成Upper Page，有128个单元，128K/8=16KB\n有64列bitlines，一个block的大小即为16KB*64*2=2MB，一般按照此比例配置Block\n写入时按照固定顺序，写入高低页面相互独立，不能同时写，在写入加压时容易使相邻单元发生数据偏移，要降低错误率\n写入是需要先擦除再写入，擦除整个块\n特性 读写粒度 闪存页读写粒度：\n4KB，8KB，16KB必须全部读取或者写入 us延迟 闪存块擦除力度\n2MB擦除 ms延迟，可以通过FTL来优化 不可覆盖写 写前需要擦除，读写粒度与擦除粒度不同\n存在64bytes的OOB（out of bound area），保存ECC，用于纠错，容忍写入时部分比特出错\n有限次擦除 随着擦除次数的增加，存储单元不能可靠的保持状态（存储数据）。\n氧化层老化变薄，束缚电子能力变弱\n耐久性 变薄地次数 保持力 不通电可以放置的时间 SLC：10w次\nMLC：1w次\nTLC：1k次\n根据特性设计FTL固件来\n0x01 FTL 固态硬盘整体构成\nSSD中的通道可以并行，通道中也可以并行读取，每个Plane中有寄存器，暂时存储准备好的数据。不同单元并行，因此内部带宽大\n垃圾回收 page对于OS而言，是写入时的block\nPage三种状态\n空闲 free page 有效页 live/valid page 无效页 dead/invalid page 需要擦除无效页，先移走有效页，然后再对一整行进行擦除，转为空闲\n时间开销：\n复制有效数据到$(R_{Latency}+W_{Latency})*N$，N是移动page的数量 擦除产生的开销 ms级延迟 GC策略 要解决的问题：\n何时启动GC 选中那些/多少Block进行GC 有效的页如何被转写 新数据写到哪里 GC的时间开销：\n块擦除的时间 ms 有效页的复制时间 贪心策略：\n找到脏页最多的block来进行擦除 优化：\nAge Hot/Cold 数据隔离，分组问题 磨损均衡 优化寿命，有静态和动态策略\n静态：周期性的调整冷热数据存储的位置\n冷热数据的分区：将冷数据放在一起，热数据放在一起\nFTL简介 维护映射，虚拟地址到物理地址\n使用SRAM存储映射\n向上层隐藏擦除操作：\n避免原地更新-\u0026gt;异地更新\n更新一个新页面\n高性能的垃圾回收和擦除\nOOB有物理地址到虚拟地址的映射，用于掉电恢复，这里引用一段wisc的OSTEP中的一段解释（44 Flash- based SSD）。\nOOB保存的在每个页中映射信息，当掉电或者重启时用它在内存中重建映射\n为了防止在重建时扫码整个SSD，可以使用日志或者检查点的方式来加速这个过程\n大致看了一下OSTEP，记得是jyy老师推荐的教材，希望以后有时间读一下\nPage-Level FTL 原理类似OS中的页表，由Logical Page Number查询页表得到Physical Page Number\n缺点是页表占用很大的空间\nBlock-Level FTL 保持Block 到Block的映射\n先查找到对应的Block，在根据offset得到page，块内的页码偏移offset是固定的\n优点是占用空间很小，缺点是GC负载增加\n原因：offset在不同Block中保持不变，在异地更新时，要选择其他block中相同的offset进行写入，如果选中的block已经存在数据，需要把数据迁移。【TODO 这里讲得不是非常的清楚】\nHybrid FTL 对写入分为新/旧数据，新写入的数据用Page-Level Mapping效率高，写入Log Blocks作为缓冲，之后再更新到Data Blocks\n旧数据因为写入后更新相对不频繁，使用Block-Level Mapping，写入Data Blocks\n","date":"2022-09-22T09:36:42+08:00","permalink":"https://blog.ipandai.club/p/%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98/","title":"【存储技术基础】固态硬盘"},{"content":"中奖\n我人生中几乎很少有过中奖，印象中甚至是没有，抛开小时候5毛钱买的那种，今天在去图书馆的路上看到了这个画面，让我想起了三年前大一刚入学发生的事。\n当时还是在余家头，正值跨年，学校举办了一个跨年晚会，其中有一个抽奖的活动，也是在图书馆前搭了舞台。我当时刚从食堂吃完饭，回寝室的路上看到了类似的扫码抽奖，毫不犹豫地拿起手机扫了码参与抽奖，只见大屏幕上的头像开始滚动，3！2！1！屏幕上的头像停止了滚动，只剩下一个获奖的熊猫头，下面写着Coding_Panda字样，是什么小爱学习机，我反应过来是我中奖了，于是飞快的跑到舞台上想找工作人员领奖，但是这是工作人员却对我说：“恭喜你啊同学，但是我们现在在彩排，希望你晚上也有同样的好运气！”。刚才的兴奋瞬间转变为了失望，当然不是什么大事，也是因为自己没搞清楚状况。\n之后可能还搞过什么转发抽奖，当然也从来没中过，再之后我也从来没参加过什么抽奖了。抽奖可能也并不是为了去中奖才去参与的，但是中奖的那一刻确实会有一种喜悦的感觉，我自认是一个有点倒霉的人，有时候又会很走运，远远比中奖开心的事情也有很多，不如把精力放在无限的学习之中。\n","date":"2022-09-21T15:27:25+08:00","permalink":"https://blog.ipandai.club/p/%E4%B8%AD%E5%A5%96/","title":"中奖"},{"content":"本讲内容HDD好弟弟：\n磁盘的构成和各个部分的功能 磁盘的性能和评估方式 磁盘固件的功能，固件算法 推荐阅读：Memory System: Cache,DRAM,Disk.Author: Bruce Jacob, Spencer W. Ng, David T.Wang\n0x00 组成 转轴，盘片，磁头\ntrack 磁道，每个盘片的正面和背面的同心圆\n对于盘片每个面是surface，每个track磁道分为多个sector（扇区）\n所有盘片上同一个位置的track是一个cylinder（柱面）\n寻址 物理编址：CHS，Cylinder-Head-Sector 定位一个块的位置\n根据柱面-磁头-扇区来访问\n右边图示表示逻辑块地址，每个柱面可以从上到下顺序编址，组成线性结构\n0x01 性能评估 电子设备 电路驱动 机械设备 seek time 磁头运动速度 rotational latency 转轴旋转速度 data transfer rate 数据传输速率 $磁盘访问时间=磁头运动速度+转轴旋转速度+数据传输速度$\nSeek time inner和outter track中进行移动，到达对应的track所消耗的时间\n评价方法：\nFull stroke 里圈到外圈 Average 移动到中间所花费的时间 Track-to-track 两个磁道间的移动时间 Rotational Latency 平均旋转速度：转半圈的时间\n厂商使用转速来标称\nrpm: round per min $$ {\\rm Rotational\\ Latency}=\\frac{1}{2}*\\frac{1}{\\frac{x\\ rpm}{60}} $$\nData Transfer Time 分为内部传输和外部传输\n内部传输是磁介质到Buffer\n外部传输是从接口到主机，例如SATA接口 $$ {\\rm Transfer\\ time=\\frac{Block\\ size}{Transfer\\ rate(带宽)}} $$ 还有电子控制部件延迟，一般而言可以忽略，以上都是毫秒量级\n大部分时间开销在Seek Time，接近60%\nI/O Controller利用率越高，会导致平均的延迟升高\nData Rate: Inner vs. Outer Tracks 磁盘在里圈和外圈的传输速率不同，外圈数据密度小，磁盘转速恒定（角速度相同），外圈的线速度大，外部磁道有更大的数据速率\n在操作系统视角来说，内外圈速率相同，实际外圈要快，是里圈的1.7倍\n0x02 磁盘固件和调度 ASIC：\n信号处理 容错 驱动处理 马达控制 缓存控制 firmware：\n请求处理 请求排队和调度 LBN-to-PBN 逻辑地址到物理地址的映射 映射逻辑地址到sector 一般块大小为512bytes或4KB，块的数量为容量/块大小\n磁盘上的数据编址如图所示，以sector为基础，在track内连续，减少rotational latency\n不同盘面上的编址分为正面和背面，都会进行编址，还有以柱面为基准的编址，减少seek time。\n一般情况下：\n盘片为1-5个，2-10个盘面 每个面磁道数为10s - 100s，1000s 每个磁道上的扇区有500-4000个，每个磁道大小为250KB-2MB LBN寻址：\n柱面号=LBN/每个柱面的磁道数 盘面号=(LBN对每个柱面的磁道数取模)/每个磁道的扇区数 扇区号=LBN对每个磁道的扇区数取模 讲解了几种调度算法：\nFCFS 先来先服务 SSTF 最近先服务，有饥饿问题 SCAN 先往一个方向走，再往另一个方向扫描 C-SCAN 单向走 LOOK 相较于SCAN不走0和边界 C-LOOK 相较于C-SCAN不走边界 评估指标：平均访问延迟，一般SSTF，C-LOOK\n缺陷 第三讲开头部分 机械式部件限制了性能，继续提升会产生一些物理问题\n带宽提升有限\n存在能耗问题，需要通电、散热冷却等开销\n随机访问的性能差\n","date":"2022-09-20T16:13:29+08:00","permalink":"https://blog.ipandai.club/p/%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E7%A3%81%E7%9B%98%E6%8A%80%E6%9C%AF/","title":"【存储技术基础】磁盘技术"},{"content":"0x00 Intro 对于场景制定存储方案：\n存储结构 存储大小 可靠性和容错 文件访问类型，读/写频率 要学习硬件的选择和文件系统设计\n0x01 现状 存储的挑战 数据量激增\n存储是什么 分层的存储架构\nL0-L1-L2-DRAM-Disk\n存储的特性 可靠性：\n多副本 纠删码 一致性：\n原子+持久化 数据保护 容灾和备份：\n解决单点故障 0x02 存储历史与发展 硬件上的发展 1956\u0026ndash;HDD\n1984\u0026ndash;Flash Memory 早期用于嵌入式\n2010s\u0026ndash;Persistent Memory 3D-Point Intel\nSSD NAND Flash：\nSLC，MLC，TLC，QLC存储单元中电平的等级\n对比HDD和SSD：\n对于NAND，需要先擦出，再写\nNAND Flash有擦除，HDD只能覆盖写\nSSD多个颗粒可以并行I/O，总体上速度快\n软件上的发展 网络存储 远程挂载目录NAS\n分布式文件系统GFS，Hadoop HDFS\n键值存储Key-Value\n云存储 数据存在远端，商业化，软件协作Office\nAssignment 有一个服务器集群（4台），针对I/O 500测试，需要考虑哪些问题？\n","date":"2022-09-20T14:41:57+08:00","permalink":"https://blog.ipandai.club/p/%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0/","title":"【存储技术基础】概述"},{"content":"此篇搁置了好几天了，网挑复赛耽误了一段时间\n0x00 Standardize 1. Notation and definition ${\\rm ParamGen}(\\lambda,PT,K,B)\\to {\\rm Params}$\n​\t将参数实例化\n$\\lambda$代表需要的安全等级，128-bit安全性或256-bit安全性\n$PT$表示明文空间，目前指定了两种参数明文空间\n(MI) Modular Integer，确定了明文空间的大小，例如$Z_p, p=1024$表示每个信息空间的元素都在$(0,1023)$范围中并且对所有元素的操作都要对p取模。 (EX) Extension Ring/Fields 由模数$p$和$Z_p$上的多项式$f(x)$确定，指定了明文空间$\\frac{Z[x]}{(p,f(x))}$，每个信息空间的元素都是一个度数小于$f(x)$整数多项式，系数在范围$(0,p-1)$之间，并且所有对单个元素的操作都是$mod \\ f(x)$和$mod \\ p$ $K$表示被加密向量的维数。例如$K=100$，$PT=(M1,1024)$表示将要被加密的信息是向量$(V_1,\u0026hellip;,V_K)$，每个$V_i\\in(0,1023)$并且执行Component-wise操作（对向量的每一个分量进行操作并得到一个新的向量）。根据定义，$(V_1,\u0026hellip;,V_K)+(V_1^\\prime,\u0026hellip;,V_K^\\prime)=(V_1+V_1^\\prime,\u0026hellip;,V_K+V_K^\\prime)$，乘法操作类似，所有向量的空间称为消息空间messa;\u0026lsquo;ge space MS\n$B$表示需要程序和电路的复杂性，越小则说明程序越简单，可以处理的范围也就越小；越大则加密支持更多复杂的操作，同时需要更复杂的处理程序\n${\\rm PubKeygen(Params)\\to SK,PK,EK}$\n生成一组私钥和公钥，这两个概念比较熟悉。要注意EK，Evaluation Key，用于在密文上执行同态操作时使用。\n${\\rm SecKeygen(Params)\\to SK,EK}$\n生成一组私钥和EK，SK会同时用于对数据进行加密和解密，EK同上。\n${\\rm PubEncrypt(PK,M)\\to C}$\n通过公钥加密信息，生成密文。通常使用随机性保证安全性。\n${\\rm SecEncrypt(SK, M)\\to C}$\n通过私钥加密信息，生成密文。通常使用随机性保证安全性。\n${\\rm Decrypt(SK, C)\\to M}$\n通过私钥对密文进行解密，如果解密不能恢复消息可能会遇到FAIL失败输出。\n${\\rm EvalAdd(Params,EK, C1,C2)\\to C3}$\n有随机性，结合输入的EK，将密文C1、C2相加，输出密文C3\n保证有$(C1+C2){decryption}=C3{decryption}=M1+M2$\n${\\rm EvalAddConst(Params, EK, C1, M2)\\to C3}$\n同理\n${\\rm EvalMult(Params, EK, C1,C2)\\to C3}$\n${\\rm EvalMultConst(Params, EK, C1,M2)\\to C3}$\n${\\rm Refresh(Params,flag,EK,C1)\\to C2}$\nflag is one of (Relinearize, ModSwitch, Bootstrap)，C1和C2都是同一个Message的密文，将同一消息的复杂密文转变为简单密文；Bootstrapping是将高噪声的密文转换为低噪声的密文；KeySwitch就是将A密钥的密文转换到B密钥\n${\\rm ValidityCheck(Params, EK, [C], COMP) \\to flag}$\n密文数组[C]，同态计算的程序被编码为完全串行执行的程序COMP，并输出一个布尔标志。当执行COMP所对应的同态计算输出的密文结果符合正确结果时，flag为1。\n2. Defines the security properties 安全性 得益于算法的随机性，同一消息的密文并不相同，即使攻击者拥有参数，EK，PK，可以计算加密出来的密文，在对密文进行对比的过程中有显著大于$\\frac{1}{2}$的概率猜测失败，由同态加密的安全性来保证。因为密文中没有显示有关消息的信息。\nCompactness 保证密文上的同态操作不会扩大密文的长度\nEfficient Decryption 同态加密方案的解密运行时间不依赖于密文对应的计算函数\n3. Describes the BGV \u0026amp;\u0026amp; BFV scheme (a) BGV ${\\rm ParamGen}(\\lambda,PT,K,B)\\to {\\rm Params}$\nlambda是安全参数\nK是整数数组的长度\nPT是明文空间类型MI/EX\n参数B表示同态计算可以执行的最大乘法深度\n在基础的BGV中，Params包括密文模数q和环$R=\\frac{Z[x]}{f(x)}$，相应的明文环$\\frac{R}{pR}$，参数还确定了R上的key分布$D_1$和误差分布$D_2$。\n${\\rm PubKeygen(Params)\\to SK,PK,EK}$\n首先运行SecKeygen，从环$\\frac{R}{qR}$中选取一个元素$a$并输出一组环元素组成的公钥PK，$(pk_0,pk_1)=(-a,as+pe)$，e是从误差分布$D_2$中选取的。\n${\\rm SecKeygen(Params)\\to SK,EK}$\nBGV中，SK是从分布$D_1$选取的环R中的一个元素\n${\\rm PubEncrypt(PK,M)\\to C}$\n先将从明文空间的M映射到环$R/pR$上的元素$\\hat{M}$，公钥PK是一组元素$(pk_0,pk_1)$。从分布D1中采样三个元素u并从误差分布D2中采样两个元素e1和e2，输出一组环元素$(c_0,c_1)=(pk_0u+pe_1,pk_1u+pe_2+\\hat{M})$\n${\\rm SecEncrypt(SK, M)\\to C}$\n首先将明文信息M映射到环$R/pR$上的元素$\\hat{M}$，随后在环$R/qR$上采样一个随机均匀的元素$a$，并输出一组环元素$(c_0,c_1)=(-a,as+pe+\\hat{M})$，e从误差分布D2种选取。\n${\\rm Decrypt(SK, C)\\to M}$\n通过同态评估，密文可能有更多的环元素，此时需要调整解密算法去处理相应的密文\n解密时先计算$R/qR$上的环元素$c_0s+c_1$，并将其称为环R中的元素$c^\\prime$，然后再mod p的到结果\n${\\rm EvalAdd(Params,EK, C1,C2)\\to C3}$\n在环$R/qR$中完成add\n${\\rm EvalMult(Params, EK, C1,C2)\\to C3}$\n在环$R/qR$中完成mult\n有密文$C1=(c_{1,0},c_{1,1})$，$C2=(c_{2,0},c_{2,1})$\noutput： $$ C3=(c_{1,0}c_{2,0},c_{1,0}c_{2,1}+c_{1,1}c_{2,0},c_{1,1}c_{2,1}) $$\nComment\n还有一种加密的编码格式，二者之间可以进行无损转换，要求明文模数p和密文模数q互质\nFull BGV\n在基本的BGV中，密文会在执行Mult之后增加一个环元素，度数为d的多项式，Mult之后度数为d+1。\n在Full BGV中，增加了两个过程来缓解，Key Switching或Relinearization。通过flag=KeySwitch调用Refresh 子程序；另一个过程是模数切换，Modulus Switching or Modulus Reduction，通过flag=ModSwitch调用Refresh。支持这两个操作还需要加强密钥生成算法。\n(b) B/FV ${\\rm ParamGen(\\lambda, PT, K, B) \\to Params}$\n与BGV类似的参数包括\nKey和误差分布D1，D2 环R和相应的整数模数q 明文整数模数p BFV独有的参数包括\n整数T，和$L=\\log_Tq$，T是位分解模数 整数$W=\\lfloor q/p\\rfloor$ ${\\rm SecKeygen(Params) \\to SK, EK}$\nSK是在分布D1种随机选取的，EK由L LWE样本组成，以特定的形式编码密钥\n对于$for \\ i \\in {1, \u0026hellip;, L},a_i \\ from \\ R/qR, e_i \\ from \\ D_2$，可以计算得到 $$ EK_i=(-(a_is+e_i)+T^is^2,a_i) $$ 并使得 $$ EK=(EK_1,\u0026hellip;,EK_L) $$\n${\\rm PubKeygen(Params) \\to SK,PK,EK}$\n私钥SK是分布D1中的一个随机元素，公钥是随机LWE样本with secret s。\n","date":"2022-09-04T14:11:46+08:00","permalink":"https://blog.ipandai.club/p/homomorphic-encryption-security-standard/","title":"Homomorphic Encryption Security Standard"},{"content":"Background 自很久以前就开始使用静态博客，并且在GitHub Pages上部署后同时在服务器上进行同步，每次push新的修改后都需要在服务器上手动pull，因此决定探究使用Github Workflow自动化部署静态博客的解决方案。\nIntro Github Workflows 在仓库的目录下，创建.github/workflows目录，目录内存放需要使用的工作流配置文件。\n例如：\n1 2 3 .github └── workflows └── rsync-action.yml Rsync Action Github提供了很全面的Actions操作，包括Hooks功能，支持在对仓库进行push、merge等操作后触发对应的脚本。对于本需求，我们需要使用GitHub的Rsync Action插件。\n插件主页 Rsync Deployments Action\n包含如下参数：\nswitches* - The first is for any initial/required rsync flags, eg: -avzr --delete rsh - Remote shell commands path - The source path. Defaults to GITHUB_WORKSPACE and is relative to it remote_path* - The deployment target path remote_host* - The remote host remote_port - The remote port. Defaults to 22 remote_user* - The remote user remote_key* - The remote ssh key remote_key_pass - The remote ssh key passphrase (if any) *标记为Required 也就是说我们要配置远程服务器的主机地址host，ssh端口，用户名，ssh公钥，以及同步的目的地址\n对于GitHub WorkSpace，也就是仓库内的文件，需要指定要同步的目录，可以用.来同步整个目录。\n最终需要实现的效果即为：\n本地通过hugo/hexo生成静态文件后，push到远程仓库后即可自动触发服务器静态资源目录和GitHub仓库的同步，保证自动实时更新。\nGithub Secret KV GitHub为每个仓库提供了Secret配置，相当于系统环境变量，防止在yml中泄露敏感信息，可以利用该功能配置服务器的host，ssh公钥，用户名等信息。\n如上图所示，可以进行GitHub Secrets的配置，通过new repository secret添加新的环境变量。\n对于这些变量的访问，通过在yml中${{ secrets.DEPLOY_HOST }}类似的方式进行访问。\nRsync-Action.yml 编写yml工作流\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 name: Deploy # 工作流名称 on: push: branches: - hexo # 触发工作流的分支 jobs: deploy: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Rsync to Remote Server uses: Burnett01/rsync-deployments@5.2.1 with: switches: -avzr --delete # 同步参数 flags path: ${{ secrets.WORKSPACE_PATH }} # 同步的仓库目录 remote_path: ${{ secrets.DEPLOY_PATH }} # 服务器同步目录 remote_host: ${{ secrets.DEPLOY_HOST }} # 服务器主机IP remote_port: ${{ secrets.DEPLOY_PORT }} # 服务器ssh端口 remote_user: ${{ secrets.DEPLOY_USER }} # 服务器用户名 remote_key: ${{ secrets.SSH_PRIVATE_KEY}} # 服务器ssh公钥 这里我同步的仓库目录即为整个目录，通过.来配置\n服务器同步目录即为/var/www/blog目录\n服务器公钥尽量重新生成，GitHub会拒绝已经添加过的公钥\n1 ssh-keygen -t rsa -b 4096 -C \u0026#34;email address 邮箱地址\u0026#34; 新公钥不防起名叫github-action.pub\n将github-action（生成的新私钥）丢进GitHub Secrets中的SSH_PRIVATE_KEY变量中\n再把该公钥加入到authorized_keys中\n1 cat github-action.pub \u0026gt;\u0026gt; ~/.ssh/authorized_keys 此时，将该yml push到远程仓库中，即可触发同步action。\n如图所示，工作流全部完成。\n顺便还配置了七牛云图床，Typora和PicGo配合的自动图片上传，就不用每次手动上传了图片了，写作体验有效提升。\nReference Deploying to a server via SSH and Rsync in a Github Action\nUnderstanding how to use Github Actions\nRsync-Action Documentation\nPicGo Documentation\n","date":"2022-08-30T09:27:53+08:00","permalink":"https://blog.ipandai.club/p/%E4%BD%BF%E7%94%A8github-workflow%E5%B7%A5%E4%BD%9C%E6%B5%81%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/","title":"使用GitHub Workflow工作流自动部署静态博客"},{"content":"0x00 Intro Protecting Privacy through Homomorphic Encryption Part I读书笔记\n1. 对称加密大战公钥同态加密 双方使用相同的key对数据进行加密解密，属于对称加密\n公钥同态加密（非对称加密）使用两个不同的key，使用公钥来对数据进行加密，使用私钥来对数据进行解密。\n二者的工作流程对比如上图所示\n2. 参数与安全性的关系 对于同态加密，参数的选取影响着安全性以及明文的类型和可以进行的计算。\n同态加密目前最重要的两个参数为：\n密文空间$n$，大致对应每个密文中整数的数量 密文模数$q$，确定密文中每个整数的大小边界 一般来说，安全性随着$n$的增大而升高，随着$q$的增大而降低。\n$q$越大，在加密之后的密文上则可以执行更复杂的计算。\n加密方法最终都会对数据加噪声，只有当噪声$\u0026lt;q$时，才可以被解密。因此更大的q可以让我们执行更多的操作。\n基于格密码的同态加密，理论基础是$Learning \\ with \\ Errors (LWE)$问题难解性或者是他的变种问题$Ring \\ Learning-with-Errors (RLWE)$。在适当的参数下，该问题对于经典计算机和量子计算机都很难解。\n对于参数的选取可以根据所需要的安全性去查阅安全文档。\n本文主要介绍了几种同态加密的方案以及特点。\n0x01 BGV，BFV Encryption Scheme 基于RLWE问题的难解性，两种模式都支持明文为整数组成的向量。\n加密包括的参数：\n明文模数$p$ 密文模数$q$ 密文维数$n$ 明文模数$p$决定了明文向量整数的上限，约束加密后的密文计算中的结果。\n密文模数$q$是决定方案的加密计算能力。BGV或者BFV加密模式的密文包含一个长度为$2n$的整数数组，值为$[0,q-1]$，前文提到过，模数越大，密文可以执行的操作就越多。\n对于给定的$q$，密文的维数$n$决定了加密等级，越高则安全性越高。同时，还影响明文向量的大小。一般而言明文向量的长度等于$n$。\n1. 同态操作 密文在操作时保留模数p，输出结果同样为密文。\nCiphertext-Plaintext\n二元操作：\nCiphertext-Ciphertext Addition Ciphertext-Plaintext Addition Ciphertext-Ciphertext Multiplication Ciphertext-Plaintext Multiplication Ciphertext-Ciphertext Subtraction Ciphertext-Plaintext Subtraction 一元操作：\n向量旋转 否定 2. 参数选取 明文模数$p$：决定明文数据的宽度，要保证在应用范围内足够大，不发生溢出，有些场景下需要溢出。\n密文模数$q$：主要由乘法深度决定，更高的深度需要更大的模数，并且运算时间也会增大。\n举个例子：\n对于密文$A,B,C,D$，乘法运算$(A*B)*(C*D)$优于$A*(B*(C*D))$， 前者的乘法深度较小，需要的密文模数小。\n密文维数$n$：查阅安全性文档中的参数表来选取，选取表格时许啊要了解密钥分发等实现细节。\n3. BGV/BFV Hello World 一个简单的例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # set parameters p = 31 q = 65537 n = 16 # generate key myPublicKey, mySecretKey = generateBFVkey(n, p, q) # encrypt data # each plaintext is a vector of 8 elements encrypted_a = encrypt(myPublicKey, [5, 11, 2, 0, 20, 3, 8, 11]) encrypted_b = encrypt(myPublicKey, [12, 7, 14, 11, 1, 2, 3, 24]) excrypted_c = encrypt(myPublicKey, [2, 10, 15, 13, 6, 3, 2, 1]) encrypted_d = addCiphertexts(myPublicKey, encrypted_a, encrypted_b) # Encryption of vector [17, 18, 16, 11, 21, 5, 11, 4] # Maybe we want to multiply the result by the 3rd ciphertext. encrypted_e = multiplyCiphertexts(myPublicKey, encrypted_c, encrypted_d) # Encryption of vector [3, 25, 23, 19, 2, 15, 22, 4] # encrypted_c * encrypted_d % p # Then rotate by 2 to the right encrypted_f = rotateBy2(myPublicKey, encrypted_e) # To actually see the final result we have to use the key. decrypted = decrypt(mySecretKey, encrypted_f) print(decrypted) # This should print [22, 4, 3, 25, 23, 19, 2, 15] 4. Further Information 4.1 维护操作 BGV和BFV期望在执行操作时对隐含的明文没有影响，但是由于实现原因有些时候还是需要的。\nCiphertext-Ciphertext 乘和循环向量旋转有副作用，需要用一个与操作前不同的密钥去解密结果。被称为key切换操作，存储新密钥到之前的密钥中。又被称为relinearization Boot strapping，刷新一个密文，并降低其中的噪声来支持更多的操作，这个操作需要巨大的开销，一般不执行。 Modules Switching，模数切换，在乘法操作之后。BGV应用较多，来控制密文的噪声级别。很少在BFV中。 4.2 估价key key切换操作需要评估器可以访问特殊的公共评估密钥，这些评估密钥有密钥拥有者生成。在Ciphertext-Ciphertext Multiplication中，这些key被称为relinearization keys，在rotation中，被称为rotation/Galois keys伽罗瓦。\n4.3 数据编码 在BGV和BFV操作之前，需要独立进行编码操作将原数据转换为加密方案可以识别的明文格式。因此在解密之后，还需要相应的解码器。\n4.4 数据移动操作 对于一些设定的参数p和n，自身的数据移动操作可能与循环旋转不同。\n理解：运算中可能需要去改变矩阵中数据的排列，因此而产生时间开销。行旋、列旋。\nreference Algorithms in HElib\n4.5 References for the BFV Encryption Scheme 实践中常用BFV表示RNS残数系统中的大整数。\n与传统的多精度位置数相比，RNS有许多优势：\nRNS使用机器字大小的整数，比PNS快5-10倍 RNS的运行时间随着整数大小线性变化 RNS显著改善了内存局部性 计算可以并行化，RNS支持高效的GPU/FPGA硬件实现 两种RNS变体为基于整数运算，基于整数和浮点数运算\n一些实现了BFV的开源库\nPALISADE Lattigo Microsoft SEAL 4.6 References for the BGV Encryption Scheme 也可以在RNS中表示大整数。\n在 HElib 和 PALISADE 库中实现\nBGV Bootstrapping参见其它论文\n0x02 CKKS Encryption Scheme 安全性由RLWE问题的难解性保证\n明文是以浮点数表示的实数向量\n该方案原生支持定点数运算，使用SIMD方法\nSIMD：Single Instruction Multiple Data 单指令流多数据流，采用一个控制器来控制多个处理器，同时对一组数据中的每一个分别执行相同的操作，实现空间上的并行技术。link\n控制安全性和精度的参数：\n小数位数$f$，决定了计算的准确程度 密文模数 $q$ 密文维数$n$ 假设每个明文值都表示为二进制定点数，有$f$小数位。密文的$f$可以在执行rescaling处理之后重新进行调整，是一个feature。密文模数$q$，决定加密计算能力的主要参数。\nCKKS的密文由长度为$2n$的整数数组对$q$取模。对于给定的$q$，密文的维数$n$决定了加密等级，越高则安全性越高。\nCKKS允许在单个密文中加密多个定点数。密文维度$n$还决定了明文向量的大小，即$n/2$。\n1. Homomorphic Operations 密文参与的运算结果都是输出密文\n二元操作：\nCiphertext-Ciphertext Addition Ciphertext-Plaintext Addition Ciphertext-Ciphertext Multiplication Ciphertext-Plaintext Multiplication Ciphertext-Ciphertext Subtraction Ciphertext-Plaintext Subtraction 一元操作：\n向量旋转 否定 Rescaling Rescaling总是遵循乘法运算，是一种将输入密文的缩放因子除以特定因子的一元运算。它控制同态计算过程中缩放因子的大小。重新缩放操作后，密码文本模数会减小，如果密文模量太小，则不允许进一步乘法。\n2. 参数选取 分数位数和支持深度是需要考虑的主要参数。如果电路深度不超过参数确定的边界，则可以对电路进行加密评估。\n定点数运算的两个主要问题是精度损失和溢出。密文在加密或者计算后存在固有误差，受到参数$f$的控制。$f$越大表示结果越准确，但是计算开销会增大，同时加密值的大小必须严格控制小于模数$q$，保证计算过程中不会溢出。\n最大密文模数$q$主要由待评估电路的乘法深度和精度参数$f$。\n更高的深度和高精度需要更大的密文模数，运算变慢。\n一种参见的优化技术是将计算任务表示为深度最小的电路。\n参照之前的ABCD例子。\n一旦$q$确定，通过查表获得较高安全性的$n$下界。\n3. CKKS Hello World 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # set paramters f = 2 q = 65537 n = 8 # 2位小数 # Generate the keys for these parameters myPublicKey, mySecretKey = generateCKKSkey(n, q) # Encrypt data, each plaintext is a vector of 4 elements encrypted_a = encrypt(myPublicKey, [1.53, -11.53, 0.02, -3.32]) encrypted_b = encrypt(myPublicKey, [12.29, 7.52, -14.47, 11.01]) excrypted_c = encrypt(myPublicKey, [2.64, 10.78, -15.30, 13.34]) # We have three ciphertexts now. # We want the sum of the first two. # Luckily we used homomorphic encryption, so we can actually. do this. encrypted_d = addCiphertexts(myPublicKey, encrypted_a, encrypted_b) # encrypting the vector [13.82, -4.01, -14.45, 7.69] # Maybe we want to multiply the result by the 3rd ciphertext. encrypted_e = multiplyCiphertexts(myPublicKey, encrypted_c, encrypted_d) # encrypting the vector [36.48, -43.23, 221.09, 102.58] # Then rotate by 2 to the right encrypted_f = rotateBy2(myPublicKey, encrypted_e) # To actually see the final result, we have to use the key. decrypted = decrypt(mySecretKey, encrypted_f) print(decrypted) # This should print [221.09, 102.58, 36.48, -43.23] 4. Further Information 4.1 数据编码 CKKS的编码会导致一些精度损失，因为明文向量必须首先乘缩放因子（参数由加密方案决定）来保证编码的精度足够。缩放后的向量 被转换为CKKS支持的明文格式。密文隐式存储可能在同态计算时改变的伸缩因子。\n解密后，需要相应的解码器。\n密文模数决定了底层编码明文部分的上限，以保证其正确解密。防止溢出。\n4.2 维护操作 类似上文\nCiphertext-Ciphertext 乘和循环向量旋转有副作用，需要用一个与操作前不同的密钥去解密结果。被称为key切换操作，存储新密钥到之前的密钥中。又被称为relinearization Boot strapping，刷新一个密文，并提高其密文模数，来支持更多的操作，这个操作需要巨大的开销，一般不执行。 4.3 估价Key 密钥切换需要要求评估者可以访问特殊的公共评估密钥。评估密钥生成必须由密钥所有者完成。在Ciphertext-Ciphertext乘法的过程中，这些键通常被称为重新线性化键；在旋转的过程中，它们有时被称为旋转或伽罗瓦键。Bootstrapping操作同样需要这样的评估密钥。\n4.4 CKKS相关实现 HEAAN/RNS-HEAAN HElib Lattigo MS SEAL PALISADE 0x03 DM(FHEW) And CGGI(TFHE) Schemes 1. Basic 基于RLEW问题。\n有两种模式，simple和advanced。simple模式在每个门操作后自动执行bootstrapping操作，提供评估电路的能力。simple模式很容易配置，只需要一个参数，尤其当电路已知时。advanced模式下，用户决定何时执行bootstrapping或者其他维护操作，可以永不执行bootstrapping。\nsimple模式易于使用，只需生成或编译与应用程序相对应的小型布尔电路即可，并且在加密输入上对每个门进行评估。advanced模式可以提高性能。\n参数：\n安全位数$\\lambda$ (all modes) 特定于密码文本的计算预算测量（advanced mode） 安全参数的位数$\\lambda$与其他加密方案中的密文模数和密文维数相关。simple模式下，所有参数只能从$\\lambda$得出。\n在advanced模式下，计算预算与可以执行的同态操作数量相关，即在执行下一次bootstrapping之前可以执行的次数。\n2. Homomorphic Operations Simple模式支持布尔电路，Advanced模式支持布尔电路，整数，定点数。\nSimple 模式明文空间和操作 明文都是布尔变量，主要操作为\n常量 ZERO/ONE 一元门 NOT 二元门 AND/NAND OR/NOR XOR/XNOR ORNOT/ANDNOT 三元门 MUX 数据选择器 Majority/Minority 以上逻辑门中，输入和输出都只能是密文。\nDM/CGGI Hello World Simple Mode lambda\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 lambda = 128 # Generate the keys for these parameters myPublicKey, mySecretKey = generateKeys(lambda) # Encrypt data, each plaintext is a boolean value encrypted_a = encrypt(myPublicKey, 1) encrypted_b = encrypt(myPublicKey, 1) excrypted_c = encrypt(myPublicKey, 0) # We have three ciphertexts now. # Compute the AND of the first two. encrypted_AND = EvalGate(“AND”, myPublicKey, encrypted_a, encrypted_b) # Encryption of 1 AND 1 = 1 # Maybe we want to compute OR of this with the 3rd ciphertext. encrypted_ANDOR = EvalGate(“OR”, myPublicKey, encrypted_AND, encrypted_c) # Encryption of (1 AND 1) OR 0 = 1 # To actually be able to see the final result we have to use the key. decrypted = decrypt(mySecretKey, encrypted_ANDOR) print(decrypted) # This should print 1 Advanced Mode 明文空间和操作 明文由定点数向量组成，有精度参数$\\pm\\alpha$\n只支持向量加和一些其他向量运算，不支持向量乘\n误差可以通过还原明文后四舍五入消除。\n主要三种运算：\naddition scaling rotation 注意scaling运算中，缩放倍数会影响误差的数量级\nrotation运算时，任何消失在向量右侧的系数都以相反的符号显示在左侧\n支持非线性操作，使用RGSW scheme（RLWE密文向量）\n外积\n给定加密线性变换$f$的RGSW密文和加密向量$x$的RLWE密文，获得$f(x)$的加密。\nBlind Rotation\n给定RGSW加密$rot_k$和RLWE加密$x$的密文，得到$rot_k(x)$的RLWE加密，$k$依然是密文\nPrivate Selection（CMUX）\n给定加密了$c=0/1$的RGSW密文，两个加密了$x$和$y$的RLWE密文，获得RLWE加密的$c?x:y$，三目运算符。\nAdvanced Mode CGGI Hello World 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # set bits of security and noise rate lambda = 128 alpha = 2ˆ-15 # Generate the keys for these parameters myPublicKey,mySecretKey = generateKeys(lambda, alpha) # encrypt each letter with RGSW encrypted_x = [ encryptRGSW(myPublicKey, 0), encryptRGSW(myPublicKey, 1), encryptRGSW(myPublicKey, 0) ] # the initial state values are trivial RLWE ciphertexts a = RLWE(0) b = RLWE(0) c = RLWE(0.5) For i = 3 to 1 # evaluate each transition newA = CMux(encrypted_x[i],b,a) newB = CMux(encrypted_x[i],a,c) newC = CMux(encrypted_x[i],c,b) (a,b,c) = (newA,newB,newC) EndFor # To actually see the final result, we have to use the key. decrypted = decrypt(mySecretKey, a) Return decrypted 3. Further Infomation scheme switching 在一些框架的实现中，CGGI支持不同加密方案的切换\ndifference between DM and CGGI CGGI支持simple和advanced模式，DM只支持simple模式\nsimple模式中的主要区别是在bootstrapping中\nimplementation 基于CPU\nTFHE FHEW PALISADE 基于GPU\ncuFHE nuFHE Summary Part I主要介绍了几种全同态加密算法的特点和适用范围\n特征\\加密模式 BGV/BFV CKKS DM/CGGI 明文类型 整数 浮点数近似计算 支持的运算 1. 密文明文间加减乘 2. 一元向量旋转，否定 1. 密文明文间加减乘 2. 一元向量旋转，否定，缩放 参数 明文模数$p$,密文模数$q$,密文维数$n$ 小数位数$f$,密文模数$q$,密文维数$n$ ","date":"2022-08-28T23:41:33+08:00","permalink":"https://blog.ipandai.club/p/homomorphic-encryption-learning-notes/","title":"Homomorphic Encryption Learning Notes"},{"content":"Intro 优化I/O的方法\n用户层面直接调用外部存储设备，需要应用包含文件系统的调用，臃肿，同时不同应用和用户间的冲突问题。 优化操作系统内核的I/O 栈 使用轮询来减少上下文切换的开销 在底层减少一半的中断处理 分散I/O指令 I/O block调度机制 Related Work 减少内核的开销\n减少中断处理的后半部分 是用轮询技术而非中断，减少上下文切换 混合轮询 基于SSD的闪存随机读写简化调度策略 在NVMe固件中进行调度 对高优先级的任务，提供不同的IO path支持，最小化IO path的开销 修改存储接口\n分散/分散 IO合并多个IO到一个指令，减少往返次数 移除doorbell机制和完成信号 改善fsync\n冲fsync请求发出到收到response，延长数据持久化的时间 在日志提交记录中使用校验和，有效的重叠日志写入和块写入 提出写守序系统调用，重叠的fsync效果相同，当应用需要使用fsync时，关于IO的操作将同步进行 用户层直接访问外设，存在隔离、保护等安全问题\nMotivation 背景 现状：\nI/O 请求过程中太多的步骤 页面缓存分配和索引 DMA，一系列数据结构的创建 目前的 ULL SDD实现了低于10微妙的IO延迟，然而操作系统内核产生的延迟没有明显变化\n本文专注于：\nLinux内核中的read()和write()+fsync() 基于NVMe SSD的Ext4文件系统 For Read Path 研究发现许多剩余的操作不必在设备I/O之前或之后执行\n此类操作可以在设备I/O操作进行时执行\n因为此类操作大多独立于设备I/O操作，因此考虑让这些操作与IO重叠\nFor Write Path 缓冲写write()，并不发起IO请求，不能异步处理\n由于fsync的回写机制和文件系统崩溃一致性（日志系统），包含部分IO请求\n由于文件系统带来的三次IO操作\n数据块写 jbd2发起写入日志Block I/O 提交Block I/O 这些IO的创建，涉及众多过程（block分配，请求缓冲页，创建和提交bio，设置DMA地址），因此可以让CPU将这些前置操作在IO请求发起前预执行。\nFor Lightweight Block Layer 传统Block Layer涉及过多过程，推迟了IO指令提交给设备的时间\n因为ULL SSD的高速随机IO性能和低速的顺序IO，请求重排的效果很低\n简化block layer，针对异步IO stack进行优化\nDesign 轻量化的Block I/O Layer LBIO，为LL NVMe SSD而设计，只支持IO submission/completion和IO指令tagging\n只使用lbio来表示一个block I/O请求，减少了bio-to-request的时间\n每个lbio包括\nLBA I/O 长度 复制的页面 页面的DMA地址 使用全局的lbio二位数组来记录\n行的个数为CPU核心数，行成组被分配到一个NVMe队列\n例如8核心，4NVMe队列，每个队列分配2个核心的lbio 当核心数等于队列数时，可以实现无锁的命令提交\nlbio在全局数组中的索引用作NVMe指令的tag，减少了之前赋tag的过程\nlbio提交后，调用nvme_queue_lbio来提交I/O指令\nLBIO不会合并和调度IO请求\nRead Path Ext4文件系统中，由extent status tree保存缓存到物理文件block的映射\n预加载映射到内存中，当树太大时，可以只对某个文件预加载\n异步页面申请和DMA分配 提前分配空闲页池\n为了减少页面DMA的分配，为每个核维护一个DMA映射空闲页（4KB DMA映射页的链表）\n当空闲页池不够用时，将退化为同步进行（origin）\n缓存页索引 自旋锁防止并发问题，影响效率\n在请求发出，但是页面还没有更新时，可能重复请求更新页面\n解决方案是不限制request，在request completion阶段解决问题\n尽管多个block请求，但是只能有一个页面被索引\n对于其他页面，标记为abandoned，中断发生之后，如果标记为abandoned，则清除已经完成的页面\nDMA解除映射 原本使用中断来处理，改为当系统空闲或等待一个IO请求时处理\n该方式可能会产生漏洞窗口，若不受到恶意访问，不会产生影响，否则用户可以自行选择关闭惰性DMA映射接触\nWrite \u0026amp;\u0026amp; fsync Path 当fsync涉及文件系统中事务时，可以将jbd2日志处理重叠处理\nExperiment 基于Linux内核5.0.5版本\n使用文件描述符O_AIOS\nEvaluation Conclusion 提出了AIOS\nLBIO层\nAIOS将I/O路径中的同步操作替换为异步操作，以将与读取和fsync相关的计算与设备I/O访问重叠。\nAIOS在Optane SSD上实现了一位数微秒的I/O延迟。\n此外，AIOS通过Z-SSD和Optane SSD上的模拟实验和实际测试显著降低延迟和性能改进。\n一些启发 优化I/O可以从CPU的空闲时间分析，需要考虑内核和文件系统的工作流程，最大程度的利用CPU资源，减少空闲。 硬件设备在发展的同时，软件应该提供必要适配 减少内核中与I/O相关的结构类型转化，可以有效节省时间开销 惰性修改会存在安全问题，在保证安全的情况下，可以提高效率 ","date":"2022-08-17T10:30:41+08:00","permalink":"https://blog.ipandai.club/p/atc19-asynchronous-i/o-stack-a-low-latency-kernel-i/o-stack-for-ultra-low-latency-ssds/","title":"[ATC'19] Asynchronous I/O Stack: A Low-latency Kernel I/O Stack for Ultra-Low Latency SSDs"},{"content":"超低延迟固态硬盘从内核到固件的服务器存储堆栈\n个别名词解释 the 99^th percentile 超过统计数据99%的数是多少\nblk-mq Linux Multiqueue block layer 内核对ssd随机I/O的优化\nmessage signaled interrupt (MSI)\n1.摘要 flash share\n在内核中，扩展了系统堆栈的数据结构，传递应用程序的属性（？），包括内核层到SSD固件。\n对于给定的属性，FlashShare的块层管理IO调度并处理NVMe中断。\n评估结果表明，FLASHSHARE可以将共同运行应用程序的平均周转响应时间分别缩短22%和31%。\n1.0 Intro 1.1 现状 网络服务提供商，满足服务级别协议SLA，延迟敏感\n某个段时间短可能有大量请求涌入，供应商会超额配置机器以满足SLA\n现状：该场景并不常见，因此大部分情况下服务器的资源占用率非常低，能耗比低。\n为了解决利用率低，服务器会运行离线的数据分析应用，延迟不敏感，以吞吐量为导向。\n因此，在运行了多个进程的服务器上，I/O延迟增高，满足SLA非常困难。\n现有的ULL SSD相较于NVMe SSD可以减少10倍的延迟\n但是这些ULL SSD在同时运行多个进程下高强度压榨服务器的时候，不能充分利用ULL SSD的优势/表现一般。\nthe 99th percentile 是0.8ms（apache）\n但是当服务器同时运行pagerank的时候，延迟会增加228.5%。\n原因：略\n从固件到内核优化堆栈的存储。\n内核级别的增强：\n两个挑战\nLinux的blk-mq导致I/O请求队列化，引入延迟 NVMe的队列机制没有对I/O优先级的策略，因此，来自离线应用的IO请求容易阻塞在线应用的紧急请求，造成延迟。 对于latency critical的请求，绕过NVMe的请求队列。同时令NVMe的驱动通过知晓每个应用的延迟临界匹配NVMe的提交和请求队列。\n固件层设计：\n​\t即使内核级的优化保证了延迟敏感的请求可以获得高优先级，但如果基础固件不了解延迟临界值，ULL特性（类似内存的性能）无法完全暴露给用户。本文中重新设计了I/O调度和缓存的固件，以直接向用户暴露ULL特性。将ULL SSD的集成缓存进行分区，并根据工作负载的属性对每个I/O服务独立的分配缓存。固件动态的更新分区大小并以精细粒度调整预取I/O粒度。\nULL SSD的新中断处理服务： ​\t当前的NVMe中断机制没有对ULL I/O服务优化。轮询方法（Linux 4.9.30）消耗了大量的CPU资源去检查I/O服务的完成情况。当轮询在线交互服务的IO请求完成状态时，flashShare使用一个仅对离线应用程序使用消息信号中断的选择性中断服务程序Select-ISR。\n​\t通过将NVMe队列和ISR卸载到硬件加速器中来进一步优化NVMe completion routine。\n​\t各种仿真实验后效果不错，效率提高了22%和31%。\n2.0 Background 2.1 存储内核栈 Linux文件系统IO\nbio request nvme_rw_command 存储堆栈中，NVMe驱动发起的请求通过nvme_rw_command的形式传递到PCI/PCIe设备驱动中。\n当I/O请求完成后，发送信号中断，中断直接被写入到中断处理器的中断向量中。被中断的核心选择ISR处理该中断请求，随后NVMe驱动再SQ/CQ中清空相应的记录并将结果返回至上一层（比如blk-mq和文件系统）。\n2.2 设备固件栈 收到request SQ tail++入队 写入SQ门铃寄存器 通过DMA读取数据的物理位置 SQ head++出队 将请求转发至嵌入式缓存层或者FTL 当出现缺页或者页面替换时，FTL将目标LBA转换成Z-NAND中相应的物理地址，必要时自行GC 在完成I/O请求之后，NVMe控制器增加这个CQ的tail，入队 通过DMA传输数据，并修改phase tag 主机ISR通过搜索队列中检查phase tag，对于有效的phase tag，ISR清除tag位，并且处理剩余的I/O完成请求程序。 CQ head++出队，在SQ中移除相应的记录，并且写入CQ的head doorbell 3.0 跨层设计 3.1 快速存储的挑战 原因是存储栈无法区分来自Apache的I/O请求，及时两个应用需要不同级别I/O的响应。\n3.2 预知灵敏响应 为了让内核可以区分I/O 请求的优先级和紧迫程度，修改Linux的进程控制快task_struct.\n为了保证有效性，在address_space,bio,request,nvme_rw_command\n中都保存工作负载属性，在存储堆栈上打孔。\nFlashShare同时提供了一个可以在服务器上配置这些属性的工具。叫做chworkload_attr。\n可以方便的修改每个应用的属性并绑定到task_struct中\n修改了syscall表arch/x86/entry/syscalls/syscall 64.tbl添加了两个系统调用，可以从task_struct中set/get工作属性。\n在/linux/syscall.h中进行注册，并带有asmlinkage标签。\n用户通过shell给定特定进程，实现于/sched/cores.c\n3.3 内核优化 优化文件系统中的blk-mq和NVMe驱动\nblk-mq合并重排请求提高了带宽使用，但是引入了延迟\n跳过所有在线应用的I/O 请求\n如果离线应用程序的 I/O 请求被 blk-mq 调度到后续在线应用程序发出的同一 LBA，则可能发生危险。\n如果两个请求的操作类型不同，blk-mq会将两个请求串联。否则blk-mq会将两个请求合并为一个request并交给NVMe驱动。\n为了防止延迟敏感的I/O 被NVMe控制器杀死：\n为每个核心创建两个SQ队列和一个CQ队列 其中一个SQ保存来自在线应用的I/O请求。NVMe驱动程序通过管理员队列发送消息，通知NVMe控制器选择一种新的队列调度方法，该方法始终优先安排该SQ中的请求。\n未来避免因优先级带来的饥饿，当该队列中的请求数量大于阈值时，或者没有在规定时间内被满足，NVMe驱动会满足所有离线应用I/O 。\n实验表明，队列大小为8或者200us的阈值最好。\n4.0 I/O Completion和缓存 采用轮询机制时查询I/O Completion时，内核态占用97%。\n带来两个问题：\n没有为处理I/O 响应单独分配核心，对于多进程下低效 我们要减轻处理I/O轮询的核心开销，进一步降低延迟 4.1 中断处理程序 flash share仅对来自在线应用的I/O 请求使用轮询\n使用信号处理离线应用\n修改blk-mq中的submit_bio()，将由文件系统或缓存的bio插入到mq 如果bio是来自离线应用的，则插入队列，as normal 如果bio是来自在线应用的，blk-mq则调用queue_rq()将请求发送至NVMe驱动。 NVMe驱动转换I/O 请求为NVMe指令并非插入到响应SQ队列中 使用Select-ISR，当请求为离线应用时，CPU核心可以通过上下文切换从NVMe驱动中释放。否则，blk-mq调用轮询机制blk-poll()。blk-poll()持续调用nvme_poll()，检查有效的完成记录是否存在于目标NVMe CQ中。如果存在，blk-mq禁用此CQ的IRQ，以至于MSI信号无法再次捕获blk-mq程序。nvme_poll()通过检查CQ中的phase tags查找CQ中的新记录。\n具体来说，nvme poll()搜索一个CQ记录，其请求信息与blk poll()等待完成的标签匹配。一旦检测到这样的新记录，blk-mq就会退出在blk poll()中实现的无限迭代，并将上下文切换到其用户进程。\n提出I/O-stack accelerator\n主要目的是将blk-mq的任务迁移到附属于PCIe的加速器中\n可以使得通过上层文件系统生成的bio直接转换成nvm_rw_command。\n通过特殊的tag索引搜索队列中的元素，并且代表CPU合并bio\n该方法可以减少36%的I/O completion时间。\n4.2 固件层 创建两个内存分区，一个服务于在线应用，一个服务于离线应用。\n三种模式\n固定拆分缓存 根据I/O动态划分 数据可保留 4.3 I/O-Stack Acceleration 添加了一个barrier logic，简单的MUX，作为硬件仲裁\n引入status bitmap来过滤SQ队列中的记录\n合并逻辑插入一个行的nvme 指令，status bitmap设置为1 如果监测到ULL SSD从I/O SQ中读取NVMe指令，status bitmap设置为0 如果状态位图表明CAM中的请求条目（与目标SQ相关联）无效，CAM将跳过对这些条目的搜索。\n5.0 实验 5.1 实验步骤 使用gem5系统结构模拟\n64位arm指令集\nLinux 4.9.30\n8核心2GHz\nL1 Cache 64KB\n2GB Memory\nRelated Work 将SSD固件转移到主机上，消除冗余的地址转换\n根据应用程序特征对缓存进行分区处理，然而不能发挥ULL SSD的作用\n从文件系统和block IO设备方面优化移动端操作系统，使其提高SQLite的性能，有局限性，应用程序、ULL SSD\n在内核的多个层对写请求进行调度，容易阻塞读请求和ULL操作\n根据前台任务和后台任务中的依赖关系，分配优先级，允许后台任务高优先级，IO通常情况下没有依赖关系，效果差，服务器大部分都是多进程\n考虑对在线应用设置高优先级，但是没有考虑对IO stack中其他部分的影响\n","date":"2022-08-17T10:30:30+08:00","permalink":"https://blog.ipandai.club/p/osdi19-flashshare-punching-through-server-storage-stack-from-kernel-to-firmware-for-ultra-low-latency-ssds/","title":"[OSDI'19] Flashshare: Punching Through Server Storage Stack from Kernel to Firmware for Ultra-Low Latency SSDs"},{"content":"DNS 使用UDP 53端口\n多路复用和多路分解 无连接运输UDP UDP无需建立连接，速度快\n无连接状态，不需要维护序列号，可以支持更多用户活跃（游戏服务器）\n首部只有8个字节，源端口号和目的端口号，长度和check sum\n为什么需要checksum校验和：\n在路由器内存中可能有bit差错 链路传输不可靠 checksum最终为1111111\u0026hellip;则可能无差错\n端到端原则：某种功能应该在较高级别提供，在较低级别上设置该功能可能会冗余\nUDP只能检查错误，不能纠错\nDNS服务采用UDP\n何时UDP，何时TCP？\n不希望延迟报文的发送，TCP有拥塞控制机制，并容忍数据的丢失 可靠数据传输 差错检测\n接收方反馈：\nACK肯定确认 NAK否定确认 ACK 0接收成功，ACK 1接收失败\n重传，收方发现差错，发送方重传\n序号，检测哪个数据包出错进行重传\n数据包可靠传输：\n在没有ack的情况下，等待一定的时间后进行重传 序号可以保证传输不冗余（接收方检测是否冗余） 发送方需要实现：\n没发送或者重传一个分组，启动定时器countdown timer 定时器过期后响应 终止定时器 流水线可靠传输协议：\n采用极小的数据包，接收方收到最后一bit立即ack GBN协议（回退N步），滑动窗口协议 限制数据包的序号，直到相应序号ack之后再发送后续的序号，用长度为N的窗口控制。\nGBN发送方：\n发送数据包时，检查发送窗口，未满则返回未发送的分组 收到ack后，对分组中的序号累积确认，表明接收方，正确接收到序号为n的分组以及以前的所有分组，[0, N] 超时，发送方重传所有未被确认的分组 接收方收到的分组都是有序的，如果出现无序，会丢弃后面的数据包，等待重传\n选择重传 避免不必要的重传\n发送方接收方都维护一个窗口\n发送方：\n收到send base后窗口右移到第一个没确认的分组处 接收ack将窗口内分组标记为ack 定时器防止分组丢失 接收方：\n接收的分组落在窗口内，返回ack 如果序号不连续，直接缓存 如果分组序号等于rcv_base将从rcv base开始的已缓存分组交付给上层，窗口移动 序号落在窗口之外，[rcv_base-N, rcv_base-1]上一个窗口中，返回ack 窗口长度不能太大\nTCP 运行与端系统中，路由器等视角下看到的是数据报\n全双工\nsocket是对tcp协议的封装\n流量控制 每一方都设置接收缓存，数据先放在缓存中，应用程序从缓存中读取数据。\n目的是消除发送方使接收方缓存溢出的可能。匹配发送方和接收方的读写速率。\n收发各自维护接收窗口。保存接收方还有多少缓存空间rwnd。\n发送方维持为确认的数据量在rwnd之内。\n如果剩余空间为0，发送方发送只有一个字节的报文。\nUDP没有流量控制，因此可能会出现缓冲区溢出。\n三次握手 客户端发送SYN=1，随机选择一个序列号seq=x 服务器读取该报文，为tcp连接分配资源，对客户端发送SYN=1，ack=x+1，seq=y（随机选取） 客户端为该连接分配资源（缓存和变量），发送SYN=0，ack=y+1，seq=x+1 为什么三次？ 确保双方的收发能力都是正常的最小次数。\n握手能不能携带数据？ 第一二次握手不能携带数据，第三次握手可以携带数据\n四次挥手 客户端发送FIN=1 服务器响应ACK 服务器发送FIN=1 客户端发挥ACK 拥塞控制 丢包的原因？\n网络堵塞后，路由器缓存溢出 方法：\n慢启动 快速重传 拥塞避免 快速恢复 ","date":"2022-03-05T10:32:46Z","permalink":"https://blog.ipandai.club/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/","title":"计算机网络自顶向下"},{"content":"Go语言源码阅读与原理分析\nGo的编译 数据结构 数组 声明\n1 2 [3]{1, 2, 3} [...]{1, 2, 3}语法糖 第二种编译器会进行转换成第一种\n上限推导\n语句转换\n由字面量（具体整数，浮点数，字符串）组成的数组，根据长度进行优化\n元素数量\u0026lt;=4，元素放在栈上 \u0026gt;4时，元素保存在静态区，运行时取出 元素数量\u0026lt;=4时，简化为赋值表达式\n1 2 3 4 var arr [3]int arr[0] = 1 arr[1] = 2 arr[2] = 3 review 编译之后的二进制文件包含：栈，堆，数据段，代码段\n堆栈为动态区域，数据段和代码段为静态区域\n栈：编译器自动分配释放，存放参数值，局部变量等\n堆：程序动态申请的内存，malloc，用链表实现\n代码区：函数体的二进制代码\n数据段：包含\n只读数据段 const 已初始化的读写数据段 初始化的全局变量，初始化的静态局部变量static 未初始化段 未初始化的全局变量和静态变量 当数组元素个数大于四个时\n获取一个唯一的staticname，在静态存储区进行初始化，之后再拷贝到栈上\n访问和赋值\n编译器的静态类型检查时检测数组越界，索引是否为非负整数，索引越界\n使用变量作为索引时，无法编译检查，需要运行时阻止，出发panic\n发现数组切片字符串越界时通过运行时的runtime.panicIndex和runtime.goPanicIndex触发panic\n下标没有越界时，编译器获取数组的内存地址和访问下标，计算出目标地址，使用Load将元素加载到内存中\n编译时插入运行时越界检查函数\n赋值时先确定目标元素地址，使用Store指令将数据存入地址，在编译阶段而不是运行时\n切片 编译时确定类型，存储在Extra字段\n数据结构\n1 2 3 Data Len Cap 切片只在运行时确定内容\n初始化 切片slice[l:r] 调用SliceMake函数，参数为 元素类型，数组指针，切片大小和容量\n这样初始化的切片创建了指向原切片的结构体\n字面量 编译时：\n对字面量数组做大小推断，初始化为数组\n创建一个数组指针，指向静态数组\n使用[:]通过指针创建切片\nmake make([]int, len, cap) 会做参数校验，cap \u0026gt;= len\n判断切片大小和容量是否足够 切片是否发生了逃逸，最终在堆上初始化 切片太大时也会在堆上初始化，使用运行时makeslice\nmakeslice会在堆上申请连续的内存\n可能的运行时错误：\n内存空间大小发生了溢出 申请内存大于最大可分配内存 传入的len\u0026lt;0 or len \u0026gt; cap 访问 对len和cap的访问会在编译时替换为常量\n使用index获取元素会直接转换为对地址的访问\nappend和扩容 如果append之后不需要赋值给原有变量：\n判断append之后的大小和容量触发扩容\n如果append之后需要赋值给原有变量：\nappend后的切片覆盖原切片，编译器优化为不发生拷贝，直接操作原切片\ngrowslice 先确定新切片容量，扩容策略：\n如果期望容量大于当前的两倍，就会使用期望容量 当前切片长度小于1024会将容量翻倍 如果当前的切片长度大于1024每次增加25%的容量，直到新容量大于期望容量 扩容之后进行内存对齐，提高内存分配效率，减少碎片\n使用预制的内存大小数组向上取整，然后通过该内存大小重新计算cap\n对于非指针切片，将原数组内容拷贝至新内存\ngrowslice返回的是一个新的切片，都是新的 slice(p, len, newcap)\ncopy copy(a,b)\n编译时会直接使用memmove拷贝到内存\n运行时会直接进行合法性检查\n大切片性能开销比较大\n哈希 解决冲突 开放寻址 从index处向后寻找空闲位置，读取会从index处向后匹配相等元素\n装载因子=元素数量/数组大小\n装载因子增大，线性探测法的平均用时增加，最坏到On\n拉链法 使用链表数组，每个数组是一个桶，通过index访问\n装载因子=元素数量/桶数量\n一般情况下不超过1，装载因子太大会触发扩容\nstruct runtime hmap\n保存对数，桶的数量都是2的倍数\n包含runtime bmap，能存储8个键值对，超过8个时会使用extra.nextOverflow中的溢出桶存\nbmap中存储key哈希的高八位tophash uint8\n初始化 字面量 当哈希表的元素\u0026lt;=25个时，将初始化转化为\n1 2 3 4 5 6 7 8 hash := map[string]int { \u0026#34;1\u0026#34;: 1, \u0026#34;2\u0026#34;: 2, } to hash := make(map[string]int, 3) hash[\u0026#34;1\u0026#34;] = 1 hash[\u0026#34;2\u0026#34;] = 2 超过时会转换为两个切片循环加入hash\n运行时 当桶的数量小于$2^4$，不创建溢出桶\n否则创建$2^{B-4}$个溢出桶\n读写 遍历使用for range\n删除delete(hash, key)\nbmap的实际存储是tophash为一个连续的空间，keys，values 。。。\n访问时限获取哈希值，再获取哈希的高8位\n通过哈希的最低几位获取桶序号\n这里因为哈希计算出来并不在桶范围内，在二进制中体现出来是取高几位和低几位，低几位就是取模之后的值，因此可以有效避免桶中有大量重复tophash\n在bmap中先比较哈希高8位，加速访问\n匹配成功会根据指针和偏移量获取key进行比较，匹配成功再获取value\n尽量使用双值接收结果，防止实际的value是nil\n写入时会遍历正常桶和溢出桶，溢出桶也包含tophash\n如果桶满，创建新的桶护着在溢出桶中保存\n获取存储地址后，将值拷贝到内存\n扩容 在写入时，触发扩容\n装载因子超过6.5 哈希使用了太多溢出桶，容易产生内存泄露 扩容非原子过程，扩容前判断是否正在扩容\n溢出桶太多触发等量扩容，新桶保存数据，回收旧桶（大量的写入删除操作）\n翻倍扩容，随着写操作增量进行，不会产生性能的巨大抖动，创建一组新桶和溢出桶，将原来的桶组设置到oldbuckets，溢出桶也设置到oldoverflow上\n数据迁移发生在运行时 evacuate，对传入桶的元素再分配，每个旧桶元素分流到两个新桶\n分流逻辑：原来通过取模得到的桶掩码为0b11，扩容翻倍之后将变为0b111，因此该数据被分流到3号和7号桶\n当旧桶完全被分流后清除oldbuckets和oldoverflow，通过计数器控制\n扩容期间访问时，若oldbuckets存在，并且旧桶没有被分流时会先去旧桶寻找\n扩容期间写入赋值时，会触发增量拷贝，向新桶分流\n删除 扩容期间删除，会分流桶中的元素，然后找到桶中的目标键值对删除\n与写入类似\n访问，写入删除都是运行时处理\n字符串 只读的字节数组，使用连续空间\ndata和len\n分配在只读的内存空间，修改需要和[]byte相互转换\n拷贝内存到栈或者堆 将变量修改为[]byte然后修改字节数据 修改字节数组转回string 1 2 3 4 5 6 7 str := \u0026#34;hello\\\u0026#34;\u0026#34; str := ` { \u0026#34;name\u0026#34; : \u0026#34;panda\u0026#34;, \u0026#34;tags\u0026#34; : [\u0026#34;panda\u0026#34;] } ` 赋值时使用scanner解析字符串成token流\nstrconv.Unquote去除引号\n使用+拼接，拼接字符串的数量小于等于五个时，使用concatstring{2,3,4,5}，否则使用runtime.concatstrings，传入数组切片，最终通过运行时过滤空字符串计算拼接后长度，如果非空字符串数量为1，并且不在栈上，则直接返回\n拷贝到目标地址空间\n类型转换有性能损失，需要拷贝数据\n函数调用 c语言使用寄存器传参数，小于等于六个时使用寄存器，大于6个的参数使用栈传递，使用寄存器传递返回值，并且只使用一个寄存器，因此只能有一个返回值。\ngo语言使用栈传递参数和返回值，因此存在性能损失，但是可以支持多返回值，便于维护编译器，不需要考虑寄存器数量和命名。\n参数传递方式 传值，基本类型，结构体，指针，对参数进行拷贝\n","date":"2022-01-25T20:14:16Z","permalink":"https://blog.ipandai.club/p/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"Go语言学习笔记"},{"content":"基础知识 单进程多线程，线程之间共享内存\nOLTP Online Transaction Processing 在线事务处理\nInnoDB overview 特点：\n行级锁 支持外键 支持事务 MVCC并发控制，插入缓冲，二次写，自适应哈希索引，预读\n四种隔离级别：\nREPEATABLE 默认 聚集方式保存数据，按主键顺序存放，没有主键则生成6字节的ROWID\n后台线程 Master Thread 缓冲区数据异步更新到磁盘 IO Thread innodb使用异步IO，提高数据库性能，负责接受回调 Purge Thread 事务提交后回收undolog页 Page Cleaner Thread 脏页刷新 主要都是为了减轻Master的负担，提高性能，减少对用户查询线程的阻塞\n内存 用页管理记录\n缓冲池：通过内存来弥补低速硬盘的影响，数据库读取页，从磁盘获取页放入缓冲池fix，读取时先判断缓冲区，命中后直接读取；修改时先修改缓冲池的页，然后通过checkpoint机制刷新到磁盘上。基本上和虚拟内存一样。\n配置参数innodb_buffer_pool_size\n数据页分类：索引页，数据页，undo页，插入缓冲，自适应哈希索引，innodb锁信息，数据字典信息等\n允许有多个缓冲池\n内存管理 LRU List 频繁使用的在列表前，不频繁的在列表后，先释放尾部的页\n页默认大小16KB\ninnodb会把新读取的页放入midpoint位置，为列表长度的$$\\frac{5}{8}$$，midpoint之后为old，之前为new，如果放在首部会导致某些sql导致缓冲池页被刷新，如全表扫描遍历全表。防止一条指令拖慢其他指令效率。\nFree列表保存空闲页\nMyISAM 表锁 全文索引 不支持事务 缓冲区只缓存索引文件，不缓冲数据\nMYD保存数据，MYI保存索引文件\nmyisampack使用Huffman编码压缩MYD，压缩后只读\n","date":"2022-01-17T23:16:08Z","permalink":"https://blog.ipandai.club/p/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"Mysql学习笔记"},{"content":"图解HTTP读书笔记\nWeb及网络基础 HTTP/0.9 不是http的正式标准，临时版本\nHTTP/1.0 RFC1945\nHTTP/1.1 目前应用较广 RFC2616\nHTTP/2.0 大幅提高了web性能\nTCP/IP 互联网运行与TCP IP协议族之上，HTTP包含于其中\nip，dns，udp，ftp，http，tcp。。。\nTCP/IP的分层管理\n应用层：决定了向用户提供服务时通信的活动，ftp，dns，http\n传输层：对应用层提供连接的两台计算机的数据传输，TCP Transmission Control Protocol传输控制协议和UDP User Data Protocol用户数据报协议\n网络层：处理网络上的数据包，数据包是网络传输的最小数据单位，规定如何传输路线，传输数据包\n数据链路层：处理连接网络的硬件，网络适配器NIC网卡\n物理层\n层次化好处：1.设计好接口，每个层次内部的设计可以自由改动 2.使设计变得更简单，应用层上的应用不需要考虑接收方的地理位置等\nIP、TCP、DNS IP IP协议位于网络层\nmac地址为网卡的固定地址，使用ARP协议（address resolution Protocol地址解析协议）凭借mac地址进行通信，解析ip到mac地址\n选择传输路线叫做路由选择\nTCP协议的可靠性 位于传输层\n将大数据块分割为报文段segment确保传输准确可靠\n将请求报文按照序号分为多个报文段，将每个报文段可靠的传输，收到后再根据序列号重组报文\n确保数据可到达：\n三次握手three way handshaking\nTCP标志 SYN synchronize和ACK acknowledgement\n具体过程：\n发送端发送一个带有SYN标志的数据包 接收端收到后回传带有SYN/ACK标志的数据包 发送端传回带有ACK标志的数据包，握手结束 如果握手中的某个阶段中断，TCP协议会再次发送相同的数据包\nDNS 域名解析\nURI和URL URL是URI的子集\nHTTP协议 http是无状态协议\n使用cookie管理状态\n使用URI定位资源\n持久连接：任意一端未提出断开，则保持tcp连接状态，减少tcp连接重复建立和断开的开销\nHTTP 1.1中，所有连接默认为持久连接\npipeline技术：连续发送请求，不必等待上一个请求返回\nCookie 服务器响应报文中Set-Cookie header字段，告知客户端保存\n客户端再次请求时自动在header中加入cookie\nHTTP报文 换行符CR+LF，CR回车符0x0d，LF换行符0x0a\nheader + CR+LF + Body\n报文message是通信基本单位，8位组字节流\n实体entity 请求或响应的在和，包含实体header和实体body\n传输过程中可以对实体进行压缩\n实体可以分割传输\n获取部分内容的请求 传输中断的恢复机制\n在header中加Range\nRange: bytes= 1-5000\n断点续传\nHTTP状态码 1XX，正在处理 信息性状态 2XX，处理完毕 成功 3XX，重定向状态码 4XX，客户端错误状态码 5XX，服务器错误状态码\n200 OK\nHEAD方法不会返回body\n204 No Content 处理成功，但是response中不包含实体\n206 Partial Content 客户端进行了范围请求\n301 Moved Permanently 永久重定向，资源分配了新的URI\n302 Found 临时重定向\n303 See Other 客户端用GET，临时重定向（比如POST访问时返回303，需要改GET方法重定向到另一个URI）\n304 Not modified 我有你要的资源但是不让你访问\n307 Temporary Redirect 临时重定向\n400 Bad request\n401 Unauthorized\n403 Forbidden 不允许访问\n404 Not Found 找不到资源\n500 Internal Server Error 内部错误\n503 Service Unavailable 服务器超负荷\nWeb服务器 虚拟主机 一台服务器可以绑定多个域名\n通过dns解析\n代理 网关 隧道 代理 转发中间人\n每次转发会追加写入via首部\n代理服务功能：缓存技术，访问控制，获取日志\n缓存代理：将资源缓存在代理服务器上，不从原服务器获取（有点像redis\n透明代理：转发请求和响应，不添加其他内容\n网关 转发客户端请求到实际程序\n网关与服务器使用非http通信\n隧道 在客户端和服务器直接中转，保持双方的通信连接\n本身不解析http请求，只传输\n缓存 客户端缓存和服务器缓存\n客户端缓存存储在浏览器\n各种header的作用\nCookie相关header Set-Cookie: 后跟name=value的序列\nCookie: 发送cookie\nHTTPS http缺点：\n明文被窃听 不验证双方身份，可伪装 无法验证完整性，可以篡改 使用SSL secure socket layer或TLS transport layer security安全层传输协议\nSSL使用证书确定身份\n防止篡改：使用md5或sha-1等校验方法校验报文完整性\nHTTP+通信加密+证书+完整性保护\n通信接口部分用ssl和tls协议代替\nhttp先和ssl通信，ssl再和tcp通信\n非对称加密 公钥进行加密，私钥进行解密\n通信步骤 客户端发送client hello开始ssl通信 服务器响应server hello 服务器发送certificate报文，包含公钥证书 服务器发送server hello done 客户端发送client key exchange报文响应，ssl握手部分结束 客户端发送change cipher spec 客户端发送finished 服务器发送change cipher spec ssl连接建立成功，开始进行http请求 ","date":"2022-01-16T22:25:00Z","permalink":"https://blog.ipandai.club/p/%E5%9B%BE%E8%A7%A3http%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","title":"图解HTTP读书笔记"},{"content":"异常控制流\nCSAPP CH-8\n指令地址间的过度为控制转移，控制转移序列叫做控制流\nECF Exceptional Control Flow 异常控制流是系统实现IO，进程和虚拟内存的基本机制\nECF用于应用程序和操作系统的交互\ntry catch等语句基于ECF\n异常 硬件实现，操作系统实现\n异常是控制流中的突变\n比如虚拟内存缺页， 算术溢出， 除以0\n事件：处理器状态变化\n处理器检测到事件发生，通过异常表的跳转表，进行间接过程调用，由异常处理程序处理异常，根据异常事件类型，进行：\n将控制返回给当前指令I-curr 控制返回给I-next，则没有发生异常，执行下一条指令 终止被中断的程序 异常处理 每种异常分配一个异常号，是异常表中的索引\n系统启动时操作系统预处理一张异常表，第k个元素包含异常k的处理程序的地址\n异常表基地址寄存器存放异常表的起始地址\n过程调用和异常的区别：\n过程调用，跳转回处理程序前，处理器将返回地址入栈；异常为根据异常以及处理结果进行跳转 处理器会将额外处理器状态入栈 控制从用户程序转移到内核，都被压入内核栈 异常处理运行在内核模式 硬件触发异常，异常处理程序在软件中完成\n异常类型 中断 interrupt 来自IO设备 异步 返回到下一条指令\n陷阱 trap 有意异常 同步 返回到下一条指令\n故障 fault 潜在的可恢复错误 同步 可能返回当前指令\n终止 abort 不可恢复错误 同步 不会返回\n中断 异步发生，来自处理器外部的IO设备\n异步的含义：中断不是由一个专门指令造成的\n异常由中断处理程序处理\ntrap和系统调用 trap是指向指令的结果，用于在用户程序和内核之间提供一个接口，叫做系统调用\n读文件，创建进程fork，加载程序\n故障 由错误情况引起，被故障处理程序修正，控制返回到引起故障的指令，从而重新执行，否则返回到内核的abort，将引起故障的程序终止。\n终止 硬件错误，dram或者sram损坏 会返回abort然后终止应用程序\nLinux x86-64系统中的异常 故障号和cpu架构有关\nLinux中的故障和终止 除法错误：除以0，Unix会直接终止程序 floating exception\n一般故障保护：神秘的错误，如程序引用了未定义的虚拟内存地址，或者访问只读的文本，也就是段错误segmentation fault\n缺页：会从新执行产生故障的指令，将磁盘上的虚拟内存的一个页面映射到物理内存的一个页面，然后重新执行这条指令\n机器检查：是在导致故障的指令执行中检测到致命的硬件错误时发生的\n系统调用 请求内核的服务\n每个系统调用有一个编号，对应内核中跳转表的偏移量\nc语言中syscall函数，c一般封装了系统调用库函数，带着参数陷入内核，将系统调用的执行状态返回\nLinux系统调用的参数通过寄存器传递\n进程 执行中程序的实例，每个程序运行在某个进程的上下文context中\n上下文包括内存中程序的代码和数据，栈，通用目的寄存器，程序计数器，环境变量，文件描述符集合\n提供抽象：独立的逻辑控制流，假象程序独占处理器；私有地址空间，假象程序独占内存\n逻辑控制流是交错的，进程轮流使用处理器，每个进程执行流的一部分\n并发流 逻辑流可以是进程、线程等\n并发：多个流并发的执行\n运行在同一个处理器上\n并行：运行在不同处理器核上\n每个控制流中的一部分是时间片\n私有地址空间 进程为每个程序提供假象，n位地址机器，地址空间2^n，\n底部用于用户程序：包括代码，数据，堆，栈\n顶部给内核\n用户模式和内核模式 通过模式位寄存器控制\n/proc文件系统，包含系统属性，如内核数，cpu类型，某进程使用的内存段地址\n上下文切换 实现多任务\n内核为每个进程维护一个上下文，包含重新启动一个进程所需的状态\n包含通用目的寄存器，浮点寄存器，程序计数器，用户栈，状态寄存器，内核栈，内核数据结构（描述地址空间的页表、当前进程信息的进程表、已打开文件的文件表）\n内核可以通过调度决定执行哪个进程\n保存当前进程上下文 恢复先前被抢占进程的上下文 控制传递给新恢复的进程 错误处理 全局变量 errno，strerror(errno)\n进程控制 获取进程id pid\n","date":"2022-01-14T10:12:15Z","permalink":"https://blog.ipandai.club/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/","title":"【操作系统】异常控制流"},{"content":"redis基础知识以及一些应用场景总结\n基础 内存数据库\n优于memcached，速度上功能上\n基础数据结构：\nString，List，Set，Hash，ZSet redis命令手册\nString key-value\n指令GET，SET，DEL\nLIST key-list\n指令\nLPUSH，RPUSH 推入列表的左端和右端 LPUSH listname item 返回值为列表长度 LPOP，RPOP，从左端和右端删除元素 LINDEX，获取列表指定位置的元素 LINDEX listname 1 LRANGE，获取给定范围内的所有元素 LRANGE listname 0 -1 0为开始索引，-1位结束索引 SET key-set\nSADD, SMEMBERS, SISMEMBER, SREM\nHASH key-hash table\n内部也是key-value\nHSET, HGET, HGETALL, HDEL\nZSET key-zset\nZADD, ZRANGE, ZRANGEBYSCORE, ZREM\n一个文章投票系统的设计 基础功能设计 根据文章的发布时间和投票数量计算一个评分，根据该评分来排序和展示文章\n要求：如果有一篇文章符合有趣文章的要求（支持票至少200张），放在排行榜前100位至少一天\n构造分数\n$ score = up\\ vote\\ *C + post\\ time $\n常量C可以选择432\n分析：一天的秒数为86400，文章达到有趣需要200票，可以利用86400/200=432来作为每个投票对得分的贡献\n保存评分以及存储文章信息\n使用hash结构存储文章的标题，文章的url，发布文章的用户，发布时间，得票数量等信息\n关于key的设置，可以使用任意字符作为分隔符，如article:ID\n使用两个zset，其中一个成员为文章id，分值为文章的发布时间，另一个成员为文章id，分值为文章的评分，使得网站可以按照发布时间和评分两种方式展示文章\n防止用户重复投票，建立已投票用户名单，使用set结构，key为voted:article_id\n需要用到的一些指令：\nZSCORE 获取文章发布时间的有序集合，判断发布时间是否在一周内 SADD 若可投票，将用户添加到已投票的set中，操作成功则说明用户未向该文章投过票 ZINCRBY 将文章的评分增加432 HINCRBY 对hash结构中的文章投票数量进行更新 发布获取文章 发布文章需要新增id，使用计数器，执行incr指令\n1 incr keyname 可以得到计数器++之后的值\n使用sadd将发布者id添加到文章投票的用户集合中（避免自己给自己投票）\n集合的过期时间为一周，一周后自动释放expire\nHMSET存储文章相关信息\n执行zadd添加文章初始评分到保存评分的zset\n执行zadd添加文章发布时间到保存时间的zset\n使用HGETALL获取存储在hash中的文章结构\n使用ZREVRANGE取出评分最高的文章和最新发布的文章：\n使用ZREVRANGE获取文章的id 使用HGETALL获取详细内容 文章分组 TODO\n","date":"2022-01-03T16:22:27Z","permalink":"https://blog.ipandai.club/p/redis%E5%AE%9E%E6%88%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","title":"redis实战读书笔记"},{"content":"承接Unix I/O这一章节，了解网络如何构建以及客户端和服务器如何通信，socket函数相关内容的学习\nCSAPP Ch-11 笔记\nCS编程模型 客户端服务器模型\n一个服务器进程，多个客户端进程\n基本操作是事务transaction\n有四步\n客户端向服务器发送请求，发起一个事务 服务器解释请求，用响应的方式操作资源 服务器返回响应，等待下一个请求 客户端接受响应并处理 网络 网络是一种IO设备，是数据源和数据接收方\n网络数据接收后经IO和内存总线复制到内存，双向传输\n以太网Ethernet是局域网技术\n电缆链接主机和集线器，集线器广播每个端口的信息到所有主机\n主机发送帧frame开头的信息，包括header，随后是有效载荷，payload，网内每个主机都可以见，只有目的主机读取\n桥接以太网，主机\u0026hellip;-集线器-桥-桥-集线器-\u0026hellip;主机，网桥会根据通信需要来选择是否转发帧到其他网桥\n连接多个局域网使用路由器\n协议解决网络传输中的差异，提供命名机制（网络地址）和传输机制（包头+有效载荷）\n数据发送过程：\n主机A通过系统调用从虚存加载数据到内核缓冲区 主机A上的协议软件添加互联网包头和接口帧头，互联网包头指向主机B，接口帧头指向主机LAN1。是封装关系。 帧头的包数据为互联网包头以及数据，帧头为其自己的互联网包头 LAN1适配器复制数据到网络 路由器读取数据猴传送到协议软件 协议软件读取目标互联网地址，作为路由表的索引转发到对应的LAN2适配器 LAN2适配器复制帧到网络 到达主机B，从适配器读取帧，传输到协议软件 协议软件去除包头和帧头，读取数据，主机B通过系统调用拷贝数据到虚拟地址空间 全球IP 客户端（用户）-【socket接口系统调用】-TCP/IP（内核）-【硬件接口，中断】-网络适配器（硬件）-全局IP因特网\n使用socket接口函数和Unix IO函数通信，socket函数为系统调用，调用内核的TCP/IP函数\nTCP/IP是一个协议族，IP协议提供命名方法和传递机制，数据报\nIP机制不可靠，数据报丢失不会自动恢复\nUDP UNreliable datagram protocol，不可靠数据报协议对其进行了扩展，包可以在进程之间传递，而不是主机之间\nTCP是基于IP的协议，进程间可靠的全双工连接\n因特网的特性：\n主机集合映射到32位ip地址 ip地址映射为一组域名 主机上的进程能够通过连接其他主机的进程通信 ipv4和ipv6：\nversion 4：32位地址 version 6：128位地址 ip地址 32位无符号整数，8*4\nTCP/IP统一了字节顺序，大端法\n使用点分十进制表示，Linux查看主机地址\n1 hostname -i 域名 一级域名mil，edu，gov，com，cn\n二级域名whut.edu\nhosts文件手工维护ip和域名的映射\nDNS，domain name system\nLinux使用nslookup查看域名ip\n1 nslookup baidu.com 通常域名和ip一一对应，多个域名也可以对应同一ip，泛域名cs.whut.edu, ee.whut.edu\n多个域名可以映射到同一组的多个ip，如www.twitter.com和twitter.com映射到199.16.156.*\n因特网连接 客户端和服务器在连接上发送和接收字节流来通信，点对点，全双工，可以同时双向流动\nsocket是连接的端点，每个socket都有socket地址，由地址:端口构成，十六位端口号0-65535\n客户端发起请求时，客户端socket地址端口由内核自动分配，临时端口；服务器的为默认端口\nweb使用80（http），电子邮件地址使用25（SMTP）\n可以通过/etc/services看查知名服务默认端口\n一个连接两端的socket地址是唯一确定的，socket pair，格式(cliaddr:cliport, servaddr:servport)，即(客户端IP:客户端端口,服务器IP:服务器端口)\nsocket接口 一组函数实现，和Unix IO配合创建网络应用\n流程：\n客户端getaddrinfo-\u0026gt;socket-\u0026gt;connect发送连接请求-\u0026gt;rio_writen-\u0026gt;rio_readlineb-\u0026gt;close发送EOF\n服务器getaddrinfo-\u0026gt;socket-\u0026gt;bind-\u0026gt;listen-\u0026gt;accept接受请求-\u0026gt;rio_readlineb读客户端的write-\u0026gt;rio_writen写入response-\u0026gt;rio_readlineb读取EOF-close\nsocket地址结构 对于Linux内核，socket就是一个有描述符的打开文件\nsocket地址存放与sockaddr_in，包含AF_INET，sin_port为16位端口号，sin_addr为32位ip地址，都是以大端法存放\nsocket函数 客户端和服务器使用socket函数创建socket描述符\n1 clientfd = Socket(AF_INET, SOCK_STREAM, 0); AF_INET表示使用32位IP地址，SOCK_STREAM表示该socket为连接端点\n该函数返回的描述符为部分打开的，不能读写，将有客户端完成打开socket的工作\nconnect函数 客户端调用connect函数建立和服务器连接\nconnect函数会阻塞一直到连接成功建立或者错误，成功后clientfd为可读写状态\n由getaddrinfo函数获取connect的参数\nbind函数 bind函数通知内核将addr中的服务器socket地址和socket描述符socketfd联系到一起\n由getaddrinfo函数获取bind的参数\nlisten函数 客户端是发起请求的主动实体，服务器是被动实体\n默认，内核认为socket函数创建的描述符为主动socket，服务器通过listen函数通知内核描述符是被服务器使用而不是客户端\n将socketfd从主动socket转化为监听socket，监听socket可以接受客户端的连接请求\n参数backlog为队列中未完成的请求数量，一般设置较大的数\naccept函数 服务器使用accept函数等待客户端的连接请求\n已经获得监听描述符connfd，listenfd，返回一个已连接描述符，该描述符可以被Unix IO读写，可以和客户端通信，将connfd返回给客户端\n与监听描述符不太，监听描述符是客户端连接请求的端点，只创建一次，存在于服务器的整个生命周期\n已连接描述符为客户端和服务器直接已经建立连接的端点，服务器每次接受请求都会创建\n可以理解为后端程序当前已经监听系统的某个端口，此时客户端请求后后端在该基础上创建一个线程去处理该请求\n主机和服务的转换 getaddrinfo 将主机名、主机地址、服务名端口号转为socket地址结构 返回result为一个addrinfo链表，每个结构对应一个host和service的socket地址结构 客户端调用之后，遍历链表，尝试每个地址，直到socket和connect成功，建立连接 服务器会遍历每个地址，直到socket和bind成功 避免内存泄露，最后调用freeaddrinfo释放链表 参数讲解跳了 getnameinfo 将socket地址转换为主机和服务名字符串 socket接口辅助函数 以上接口的整合封装\nopen_clientfd int open_clientfd(char *hostname, char *port) open_clientfd建立和服务器的连接，返回描述符，可以直接用于Unix IO函数读写\n流程：getaddrinfo，返回addrinfo链表，遍历链表尝试建立连接，失败则关闭描述符，成功后释放链表将描述符（connfd）返回给客户端\nopen_listenfd 服务器创建监听描述符 int open_listenfd(char *port)\n遍历链表直到调用socket和bind成功\necho实例 简单的单线程处理服务器\nEOF概念，并不是字符，而是内核检测的一个条件，read函数返回0时，程序检测到EOF条件。磁盘文件读写，文件位置超出长度，判断EOF。网络连接，进程关闭连接其中一端，触发EOF。尝试读取通信中字节流的最后一个字节之后的字节，触发EOF。\nWeb服务器 Web基础 HTTP协议，Hypertext Transfer Protocol超文本传输协议\nWeb内容 内容是MIME，多用途的网际邮件扩充协议，类型相关的字节序列\n读取一个磁盘文件，将内容返回给客户端，磁盘文件为静态内容 运行可执行文件，将输出返回 使用URL标识每个文件\n根据目录指定返回规则\n根目录为网页静态内容的根目录\n后缀为/时服务器自动补全默认文件名\nHTTP事务 使用Linux的Telnet和任何web服务器执行事务\n1 telnet url port HTTP请求\n请求行method URI version\n0个或多个请求报头\n一个空的文本行终止报头列表\nbody\n1 2 GET / HTTP/1.1 Host: www.baidu.com 请求方法GET、POST、OPTIONS、HEAD、PUT、DELETE、TRACE\nURI是相应URL的后缀，包括文件名和参数\nversion为http版本\nMozilla文档\nheader可以存放多种信息，比如cookie等\nhost请求头在HTTP 1.1位必须，1.0中不必须。代理缓存proxy cache会使用host报头，理解为反向代理？\n客户端和服务器直接可以由代理，代理链\nHTTP响应组成：\n1 2 3 4 响应行 0个或多个响应头 终止报头的空行 响应主体body 响应行格式\nversion status-code status-message\nversion对于HTTP版本，code为\n1 2 3 4 5 6 7 8 1** 200 301 400 403 404 501 505 更多状态码\n响应头中应有Content-Type，告知客户端主体内容的MIME类型，Content-Length，告知主体的字节大小\n传递参数 URI或者请求主体 2. 服务器传递参数给子进程\nfork一个子进程，调用execve在子进程上下文中执行对应的程序，通过环境变量，如QUERY_STRING, REQUEST_METHOD等信息，程序做出对应的处理\n子进程的输出到哪里？ CGI程序（通用网关接口Common Gateway Interface），将内容发送到标准输出，在子进程调用CGI程序之前，使用Linux dup2函数将标准输出重定向到和客户端相连的已连接描述符，CGI程序写入到标准输出的内容都会直接到达客户端 实现一个Web服务器 使用c配合CSAPP提供的封装搭建一个简易的web服务器\n总结 本章主要了解了Unix如何建立一个网络连接，以及数据传输的具体过程，socket的设计巧妙之处，以及Linux一切皆文件的进一步理解。\n","date":"2022-01-03T13:37:02Z","permalink":"https://blog.ipandai.club/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","title":"【操作系统】网络编程"},{"content":"高级别的IO程序，如c中的printf和scanf，c++中的\u0026gt;\u0026gt;和\u0026lt;\u0026lt;，都依赖Unix 系统级IO\nCSAPP Ch-10 笔记\nUnix IO Linux文件即是m个字节的序列$B_0, B_1, \u0026hellip;, B_k, \u0026hellip;, B_{m-1}$\n所有的IO设备（网络，磁盘，终端）被抽象为文件，输入和输出被作为相应文件的读和写进行，Linux内核只需要暴露一个简单低级的应用接口\n输入和输出的统一方式:\n打开文件：应用程序请求IO设备，内核返回描述符 Linux Shell创建的进程开始时有三个文件：标准输入0，标准输出1，标准错误2 改变当前的文件位置：内核存储文件位置k，初始为0，通过seek改变这个偏移量 读写文件：读为复制字节到内存，当k\u0026gt;=m时，会触发EOF条件；写为复制字节到一个文件中，从当前位置k开始，然后更新k 关闭文件：通知内核，内核释放文件打开时创建的数据结构，释放描述符，进程终止时内核会释放打开的文件以及内存 文件 普通文件：文本文件：ASCII或Unicode字符文件，其他的都是二进制文件，对内核而言无区别，换行符\\n对应ASCII LF 目录：包含一组链接的文件，链接将文件名映射到一个文件 套接字socket：与另一个进程进行跨网络通信的文件 命名通道named pipe，符号链接，字符和块设备 绝对路径：以斜杠开始/home/test\n相对路径：以文件名开始,../test\n打开和关闭文件 open函数打开或创建文件\n返回一个文件描述符，在进程中没有打开的最小描述符 几种控制参数flags\n1 2 3 4 5 6 O_RDONLY 只读 O_WRONLY 只写 O_RDWR 可读可写 O_CREAT 文件不存在则创建空文件 O_TRUNC 存在则截断，清空 O_APPEND 追加写入 mode参数控制读写权限\n每个进程都有umask\n访问权限为mode \u0026amp; ~umask\nclose(int fd)关闭文件，成功返回0，失败-1\n读写文件 read和write\n输入的size为unsigned long类型，ssize_t为long类型，因为read和write函数需要返回-1\nread和write读写遇到不足的情况：\n读取时遇到EOF 从终端读文本行 读写socket：网络延迟导致read和write返回值不足 RIO包 Robust IO 读取文件元数据 stat和fstat函数，读取文件信息\n读取目录内容 opendir函数\n共享文件 描述符表，每个进程之间独立 文件表，打开文件的集合，所有进程共享，包含文件位置，引用计数，指向vnode表的指针，当引用计数为0时，操作系统删除表项 v-node，进程间共享，包含stat中的信息，st mode，st size IO重定向 标准输出重定向到磁盘文件\n覆盖写入文件之前的内容\n使用dup2函数，将终端的输出关闭，改为磁盘文件，磁盘文件引用次数+1\n标准IO 标准IO将打开的文件模型化为一个流，减少系统级IO操作的调用\n第一次getc调用IO read函数读取到缓冲区，之后调用将缓冲区第一个字节返回给应用程序\n选取IO函数问题 socket中不要使用标准IO，可能会导致崩溃，使用RIO函数/Unix IO\n","date":"2022-01-03T10:31:33Z","permalink":"https://blog.ipandai.club/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B3%BB%E7%BB%9F%E7%BA%A7io/","title":"【操作系统】系统级IO"},{"content":"编译原理笔记，词法语法分析\n词法分析 有穷自动机 DFA $f: K \\times \\sum \\to K$是一个单值函数，任何输入符号都唯一的确定了下一个状态\n不确定的有穷自动机 NFA 至少一个初态节点，若干个终态节点 DFA是NFA的特例\n子集法 NFA转换为DFA 对于状态集合$I$，定义两个运算\n集合$I$的$\\epsilon-Closure(I)$，是一个状态集$I$中的任何状态经过任意条$\\epsilon$弧能到达的状态集合 因为当输入符号为空时，则自动机停留在原来的位置上，所以有关系$\\forall S \\in I \\ \\ , S \\in \\epsilon-Closure(I)$\n状态集合$I$的$a$弧转换，表示为$move(I,a)$，定义为状态集合J，其中$J$是所有那些可以从$I$中的某一状态经过一条$a$弧而到达的状态的全体 有关系$\\forall S_i \\in I \\ \\ , move(I,a)=f(S_1,a)\\bigcup f(S_2,a) \\bigcup f(S_3,a)\u0026hellip;$ 算法流程：\n1 2 3 4 5 6 7 8 9 10 11 12 let C as a set save Status-Set let K_0 = epsilon-Closure(0) C \u0026lt;- epsilon-Closure(K_0) while(if C have set not visit) { visit[T] = true for a in Char Set { U := epsilon-Closure(Move(T,a)) if (U not in C) { C \u0026lt;- U } } } 经过状态重新命名可以得到DFA\nDFA的化简 化简 的DFA：没有多余状态，没有两个状态是互相等价的。 DFA可以通过消除无用状态和合并等价状态二转换成一个与之等价的最小状态的DFA\n无用状态：从开始状态触发，任何输入串都无法到达 或者从这个状态没有通路到达终态 ![[Pasted image 20211230203930.png]] 如s4，s6，s8，可以直接消除\nDFA中的状态等价条件：\n一致性条件-状态s和t必须同时为可接受状态或不可接受状态 蔓延性条件-对于所有输入符号，状态s和t必须转换到等价的状态 分割法分解DFA状态： 步骤：\n先将终态和非终态分割，作为两个子集，作为一个划分 在划分中对每个子集加上可输入字符，将可区别的状态拆分，得到新的划分 重复直到划分不可以再分割 化简后的DFA便于在计算机上实现\n由DFA化简为正规式 很简单 缩缩缩\n由正规式生成NFA $L(G)$表示文法G产生的语言的集合 $L(G1) = L(G2)$ 则两个文法等价 反正就是构造一个等价的$\\mathbb{NFA}$\n语法制导 按照语法结构构造 将正规式分解为子表达式 闭包：终态输入epsilon到达初态 分解方式不唯一 可以从头开始，也可以分部进行\n处理步骤：\n如$r_1 r_2$，顺序拼接两个NFA 如$r1^*$处理闭包，终态输入epsilon链接到初态 如$r_1|r_2$，由初态输入epsilon到两个NFA，由两个NFA输入epsilon到达终态 语法分析 自顶向下 文法特点：\n每个产生式右部都由终结符号开始 若两个产生式都由相同的左部，右部都由不同的终结符开始 分析过程是唯一的 FIRST集 $FIRST(\\alpha)={以\\alpha为左部的，产生式右部的第一个非终结符集合}$ 为a的开始符号集\nFOLLOW集 对于上下文无关文法，S是开始符号 $FOLLOW(A)={状态A后跟符号}$ 若A可以引导终止epsilon ，则加入#到FOLLOW集\n构造算法 对文法中每一非终结符A，构造FOLLOW(A)的算法如下：反复使用如下规则，直至FOLLOW集不再增大为止。 ⑴若A是文法的开始符号,则把输入结束符＃加入FOLLOW(A)中； ⑵若B→αAaβ,a是终结符,则把a加入FOLLOW(A)中； ⑶若B→αAXβ,X是非终结符,则把FIRST(Xβ)加入FOLLOW(A)中； ⑷若B→αA或B→αAβ,且β可以推导至ε，则把FOLLOW(B)加入FOLLOW(A)中。\nSELECT集 $SELECT(A \\to a)=(FIRST(a)-{\\epsilon})\\bigcup FOLLOW(A)$\nLL(1)文法：第一个L表示自顶向下分析是从左到右扫描输入串，第二个L表明分析过程中将用最左推导，1表明只需要向右看一个符号便可以决定如何推导。 充要条件: 对于每个非终结符A，的两个不同产生式 $SELECT(A \\to \\alpha)\\bigcap SELECT(A \\to \\beta)=\\varnothing$\n非LL(1)文法到LL(1)文法的等价转换 LL(1)文法的性质： ① LL(1)文法是无二义性的； ② LL(1)文法不含左递归； ③ LL(1)文法没有公共左因子。\n消除左递归 消除回溯：提取左公因子 改造成LL1文法\n消除直接左递归： 例如： A→Aα|β 对A引入一个新的非终结符A′，把上式改写为： A →βA′ A′→αA′|ε 例2： E→E +T | T T→T * F | F F→i |（E） 改造为 E→TE′ E′→+T E′|ε T→FT ′ T′→* FT′|ε F→i |（E）\n消除间接左递归 把式子带入，然后按照消除直接左递归的方法去消除 S → Aα|β ⑴ A → Sγ ⑵ 得到 S → Sγα|β ⑶ 消除左递归 S → βS′ S ′→γαS′|ε\n","date":"2022-01-02T10:33:48Z","permalink":"https://blog.ipandai.club/p/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/","title":"编译原理笔记"},{"content":"讲解机器代码以及汇编\nTODO了，有个bomb lab\n","date":"2021-12-10T21:19:54Z","permalink":"https://blog.ipandai.club/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/","title":"【操作系统】程序的机器级表示"},{"content":"本章为CSAPP Ch-2的读书笔记，复习了数据的存储方式\n信息存储 最小可寻址内存单位 -字节byte 一般为8位的块\n内存被视为一个很大的字节数组，也就是虚拟内存，每个字节用地址标识\n地址的集合为虚拟地址空间\n虚拟内存中包含程序的数据，指令，控制信息\n十六进制表示 跳\n字数据大小 字长为数据标称大小\n字长决定了虚拟地址空间的最大大小，字长为w的机器虚拟地址范围是[0, $2^w-1$]\n最多访问$2^w$个字节\n32位和64位\ngcc -m32可以编译32位程序\ngcc -m64可以编译64位程序\n寻址和字节顺序 最低有效字节在前-小端法\n最高有效字节在前-大端法\n部分cpu支持双端法 ，但是操作系统只支持小端模式（iOS \u0026amp; Android）\n大小端的影响 网络收发统一顺序 汇编阅读字节顺序 按字节打印 字符串表示 以null结尾的字符数组\n每个字符使用ASCII码，在各个系统都相同，因此文本数据的表示有更高的平台独立性（than二进制数据）\n终止字符0x00\nUTF-8，每个字符使用一个字节来编码\n布尔代数 null\n位运算 掩码运算\n掩码：表示从一个字中选出来位的集合\n整数表示 跳\n","date":"2021-12-10T13:02:03Z","permalink":"https://blog.ipandai.club/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/","title":"【操作系统】信息的表示和处理"},{"content":"Description 给定一个数字N，给定一个数字的集合，使用集合里的数字构造出小于数字N的最大数。\n如N = 23131，集合为{2, 4, 9}\n则构造出22999\nSolution 分两种情况讨论，构造的数字长度和N一样，或者比N少一位，若长度一样，则是从头开始按照比数字N小的数构造，若长度少一位可以直接用集合中的最大数填满。\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;map\u0026gt; #include\u0026lt;set\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; const int MAXN = 1e5; const int MOD = 1e9+7; typedef long long ll; using namespace std; // 23131 // 2 4 9 // 22999 // 229 // 2 // 22 int N, x; vector\u0026lt;int\u0026gt; nums; vector\u0026lt;int\u0026gt; v; int maxv = -1; int main() { cin \u0026gt;\u0026gt; N; v.clear(); nums.clear(); while (cin \u0026gt;\u0026gt; x) { v.push_back(x); maxv = max(maxv, x); } int temp = N; int setNumber = v.size(); sort(v.begin(), v.end()); while (temp) { nums.push_back(temp % 10); temp /= 10; } reverse(nums.begin(), nums.end()); int number = 0; int ans = 0; bool done = true; for (int i = 0; i \u0026lt; nums.size(); i++) { number = number*10 + nums[i]; cout \u0026lt;\u0026lt; \u0026#34;number = \u0026#34; \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl; bool find = false; for (int j = setNumber - 1; j \u0026gt;= 0; j--) { if (v[j] \u0026lt;= number) { ans = ans*10 + v[j]; find = true; number -= v[j]; break; } } if (!find) { done = false; break; } } cout \u0026lt;\u0026lt; \u0026#34;size \u0026#34; \u0026lt;\u0026lt; nums.size() \u0026lt;\u0026lt; endl; if (!done) { for (int i = 0; i \u0026lt; nums.size() - 1; i++) { cout \u0026lt;\u0026lt; maxv; } } else { cout \u0026lt;\u0026lt; ans; } return 0; } ","date":"2021-12-10T12:46:33Z","permalink":"https://blog.ipandai.club/p/%E7%AE%97%E6%B3%95%E9%A2%98%E5%B9%B8%E8%BF%90%E6%95%B0%E5%AD%97/","title":"【算法题】幸运数字"},{"content":"https://leetcode-cn.com/problems/largest-number/\nDescription 给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。\n注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。\nSolution 将数字全部转为字符串，进行逐个比较，比较规则为：\n从最高位开始比较，如果第一个数字较大，则把较大的排在前面 比较后续数字，将出现更大数字的数排在前面 若数字a为数字b的前缀，或相反，则返回a+b\u0026gt;b+a，判断如何构造可以使得数字更大 注意数字全为0的情况\nsort里用lambda很香\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: string largestNumber(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;string\u0026gt; nums_str; bool zero_flag = false; nums_str.clear(); for (auto num : nums) { if (num != 0) zero_flag = true; nums_str.push_back(to_string(num)); } if (!zero_flag) return \u0026#34;0\u0026#34;; sort(nums_str.begin(), nums_str.end(), [](const string \u0026amp;a, const string \u0026amp;b) -\u0026gt; bool { if (a[0] != b[0]) { return a[0] \u0026gt; b[0]; } for (int i = 1; i \u0026lt; min(a.size(), b.size()); i++) { if (a[i] == b[i]) continue; return a[i] \u0026gt; b[i]; } return a + b \u0026gt; b + a; }); string ans = \u0026#34;\u0026#34;; for (auto str : nums_str) { ans += str; } return ans; } }; ","date":"2021-12-09T21:22:30Z","permalink":"https://blog.ipandai.club/p/leetcode-179%E6%9C%80%E5%A4%A7%E6%95%B0/","title":"【leetcode-179】最大数"},{"content":"CSAPP读书笔记 Ch-1 宏观看一看操作系统，很多知识之前确实没了解到，值得一读\nCh1 源程序 -\u0026gt; 预处理器 (cpp) \u0026mdash;hello.i\u0026mdash;\u0026gt; 编译器(ccl) \u0026mdash;\u0026ndash;hello.s\u0026mdash;\u0026ndash;\u0026gt; 汇编器(as) \u0026mdash;-hello.o(binary) with printf.o\u0026mdash;\u0026gt; 连接器 \u0026mdash;\u0026mdash;-\u0026gt; 可执行二进制文件\n主存：临时存储设备 DRAM组成\n进程：并发执行多个进程-上下文切换\n进程运行所需的所有状态信息 上下文\n例如：PC和寄存器文件的当前值，主存的内容\n并发执行 ：一个进程的指令和另一个进程的指令交错执行\n线程：进程是由多个线程的执行单元组成 ，运行在进程的上下文中，共享同样的代码和全局数据\n多线程共享数据比多进程容易\n虚拟内存：对于进程，提供虚拟地址空间\n包含 程序代码和数据，堆malloc 和free，共享库so，栈，内核虚拟内存为内核保留，不允许应用程序读写这个区域\n基本思想：一个进程虚拟内存的内容存储在磁盘，利用主存座位磁盘的高速缓存\n并发和并行：\n并发：同时具有多个活动的系统 并行：用并发是一个系统运行的更快 线程级并发：在一个进程中执行多个控制流 指令级并行：流水线技术 单指令，多数据并行 SIMD并行 操作系统的抽象：\n文件是对I/O设备的抽象 虚拟内存是对主存和磁盘的抽象 进程是对处理器，主存和IO设备的抽象 网络可以看做一种IO设备\n","date":"2021-12-09T19:58:54Z","permalink":"https://blog.ipandai.club/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","title":"操作系统"},{"content":"前记 潘达某天在本机docker部署了他的服务，但是发现无论如何都无法ping通，他冥(疯)思(狂)苦(谷)想(歌)，逛遍了GitHub上的各种issues，stack overflow上的各种回答，各种博客文章，都没有解决他的问题，直到他的mentor来到他的电脑前，一通命令猛如虎啊，发现他竟然在docker内监听了容器中的127.0.0.1的端口，那必然会访问不到，检查发现原来是在服务的config中写了magic number，让服务开在了127.0.0.1，在本地这样必然是没问题的，但是如果要与外部进行通信，那就要改成0.0.0.0了。\n又是一天，潘达又部署起了他的rpc服务，想在服务器上部署一个微服务然后本机去访问，测试框架是否可以通过域名通信各个微服务，然而，服务器上启动成功，本地依然迟迟无法连接，上来就是一个curl: (7) Failed to connect to ababab.ababab port ababa: Connection refused，安全组也放行了对应的端口，然后他看到了一行127.0.0.1，但是他感觉不是这个问题，继续debug，然后再次呼叫他的mentor，希望得到帮助，还是一顿操作猛如虎，找到了那个127.0.0.1的监听服务，乐。\n于是，这篇blog就诞生了。 127.0.0.1 和 localhost 127.0.0.1是回路地址中的一个，在计算机中127.*.*.*被称为回路地址，所有对这些地址的请求都会让本机接收，最最重要的是，外部设备也不能通过这个地址访问到本机的服务。 localhost其实是一个域名，他一般指代本机的网络，大多数机器都会默认localhost指向127.0.0.1，可以自行修改为其他地址。\n0.0.0.0 可能我们都会以为localhost为本地的网络地址，但实际上真正的本地网络是0.0.0.0，但是他是不能被ping通的。在服务器中，0.0.0.0并不是一个真实的的IP地址，它表示本机中所有的ipv4地址。监听0.0.0.0的端口，就是监听本机中所有IP的端口。如果服务监听在0.0.0.0，那么外部访问的所有ip都可以通过对应的端口访问这个服务。\n所以问题得到了解答，如果是在本机的话，127.0.0.1的话显然是没问题的，但是如果要将服务上云或者容器，就需要进行调整，首先要避开127.0.0.1，再根据是否只允许内网ip访问进行端口映射和服务监听。\n后记 这两次问题前前后后折腾了半天，本想自己找到解决办法，查了不少资料后还是要寻求运维☁️的帮助，其实问题并不是很大，还是自己的知识储备不够，不能准确定位的问题的所在。另外，计网应该开始看了。🐼。\n","date":"2021-07-26T22:23:38Z","permalink":"https://blog.ipandai.club/p/127.0.0.1localhost%E5%92%8C0.0.0.0%E6%9A%A8%E4%B8%80%E6%AC%A1%E4%B8%A4%E6%AC%A1%E7%9A%84%E7%A5%9E%E7%A5%9E%E7%A7%98%E7%A7%98%E7%9A%84debug%E8%AE%B0%E5%BD%95/","title":"127.0.0.1,localhost和0.0.0.0暨🐼一次两次的神神秘秘的debug记录"},{"content":"Bilibili（哔哩哔哩）是当下最热门的视频播放网站，人们在该网站对视频进行浏览，会根据自己喜好对视频进行点赞、投币、收藏、分享、回复等操作，Bilibili同时还有一个排行榜机制，记录了近期比较热门的视频，并给出了一个评分，排行榜的排序规则即根据该评分，本文将根据这些排行榜视频的各项数据，进行线性回归分析，结合实际情况找出对评分影响最大的数据。\nBilibili提供了获取排行榜数据的API，因此我们可以利用该API获取实时的排行榜数据，获取的数据为json格式，经过解析，已将数据保存至Bilibili.csv文件中。\n本文的思路即为多元线性回归，在统计学中，线性回归（linear regression）是利用称为线性回归方程的最小二乘函数对一个或多个自变量和因变量之间关系进行建模的一种回归分析。这种函数是一个或多个称为回归系数的模型参数的线性组合。只有一个自变量的情况称为简单回归，大于一个自变量情况的叫做多元回归（multivariable linear regression）。\n完成了对各个自变量权重的计算，找出了对评分影响权重最高的因素，并得到了验证。\n数据获取 在哔哩哔哩官网首页处获取排行榜信息的API，得到为\nhttps://api.bilibili.com/x/web-interface/ranking/v2?rid=0\n请求参数为\nrid 分类，0代表全部分类 返回格式为json格式，json中的data字段为视频信息数组。\n为了防止请求次数过多增加服务器压力，导致本机IP禁止访问哔哩哔哩，先将请求的response保存到data.txt文件中。\n使用python的json包进行解析\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 { \u0026#34;aid\u0026#34;: 375696064, \u0026#34;videos\u0026#34;: 1, \u0026#34;tid\u0026#34;: 17, \u0026#34;tname\u0026#34;: \u0026#34;单机游戏\u0026#34;, \u0026#34;copyright\u0026#34;: 1, \u0026#34;pic\u0026#34;: \u0026#34;http://i0.hdslb.com/bfs/archive/85005893d4c4959ff096d6fb061040e223842bcb.jpg\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;史上最骚魔法师！(第二集)\u0026#34;, \u0026#34;pubdate\u0026#34;: 1621566911, \u0026#34;ctime\u0026#34;: 1621566912, \u0026#34;desc\u0026#34;: \u0026#34;本期请到了Warma参与配音！鼓掌！！！！！\\n游戏：Darkside Detective\\n第一集：BV1M64y1m7gA\\n各位如果看得开心，希望三连支持一下！\u0026#34;, \u0026#34;state\u0026#34;: 0, \u0026#34;duration\u0026#34;: 658, \u0026#34;mission_id\u0026#34;: 24025, \u0026#34;rights\u0026#34;: { \u0026#34;bp\u0026#34;: 0, \u0026#34;elec\u0026#34;: 0, \u0026#34;download\u0026#34;: 0, \u0026#34;movie\u0026#34;: 0, \u0026#34;pay\u0026#34;: 0, \u0026#34;hd5\u0026#34;: 0, \u0026#34;no_reprint\u0026#34;: 1, \u0026#34;autoplay\u0026#34;: 1, \u0026#34;ugc_pay\u0026#34;: 0, \u0026#34;is_cooperation\u0026#34;: 0, \u0026#34;ugc_pay_preview\u0026#34;: 0, \u0026#34;no_background\u0026#34;: 0 }, \u0026#34;owner\u0026#34;: { \u0026#34;mid\u0026#34;: 546195, \u0026#34;name\u0026#34;: \u0026#34;老番茄\u0026#34;, \u0026#34;face\u0026#34;: \u0026#34;http://i0.hdslb.com/bfs/face/bc5ca101313d4db223c395d64779e76eb3482d60.jpg\u0026#34; }, \u0026#34;stat\u0026#34;: { \u0026#34;aid\u0026#34;: 375696064, \u0026#34;view\u0026#34;: 1149043, \u0026#34;danmaku\u0026#34;: 7300, \u0026#34;reply\u0026#34;: 3278, \u0026#34;favorite\u0026#34;: 37490, \u0026#34;coin\u0026#34;: 98319, \u0026#34;share\u0026#34;: 1780, \u0026#34;now_rank\u0026#34;: 0, \u0026#34;his_rank\u0026#34;: 1, \u0026#34;like\u0026#34;: 210211, \u0026#34;dislike\u0026#34;: 0 }, \u0026#34;dynamic\u0026#34;: \u0026#34;用魔法击败魔法\u0026#34;, \u0026#34;cid\u0026#34;: 341808079, \u0026#34;dimension\u0026#34;: { \u0026#34;width\u0026#34;: 1920, \u0026#34;height\u0026#34;: 1080, \u0026#34;rotate\u0026#34;: 0 }, \u0026#34;short_link\u0026#34;: \u0026#34;https://b23.tv/BV1jo4y117Vf\u0026#34;, \u0026#34;short_link_v2\u0026#34;: \u0026#34;https://b23.tv/BV1jo4y117Vf\u0026#34;, \u0026#34;bvid\u0026#34;: \u0026#34;BV1jo4y117Vf\u0026#34;, \u0026#34;score\u0026#34;: 2446535 } 通过解析json格式文件并整理得到bilibili.csv\n数据处理的代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 import numpy as np import pandas as pd import os from urllib.request import Request, urlopen import urllib import requests import json def getDataFromFile(): if not os.path.isfile(\u0026#39;./data.txt\u0026#39;): raise TypeError(\u0026#34;file not exist\u0026#34;) text = open(\u0026#39;./data.txt\u0026#39;).read() return text def getResponse(url): headers = {\u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.8 5 Safari/537.36\u0026#39;} data = requests.get(url = url, headers=headers).text return data url = \u0026#39;https://api.bilibili.com/x/web-interface/ranking/v2?rid=0\u0026amp;type=all\u0026#39; res = getDataFromFile() jsonData = json.loads(res) title = [] # 标题 author= [] # up🐷 view = [] # 播放量 danmu = [] # 弹幕数 coins = [] # 投币 share = [] # 分享 like = [] # 点赞 score = [] # 分数 favor = [] # 收藏 reply = [] # 评论 rank = [] # 排名 cnt = 0 for i in range(0, 104): temp = \u0026#39;\u0026#39; try: videoData = jsonData[\u0026#39;data\u0026#39;][\u0026#39;list\u0026#39;][i] score.append(videoData[\u0026#39;score\u0026#39;]) title.append(videoData[\u0026#39;title\u0026#39;]) author.append(videoData[\u0026#39;owner\u0026#39;][\u0026#39;name\u0026#39;]) videoStat = videoData[\u0026#39;stat\u0026#39;] danmu.append(videoStat[\u0026#39;danmaku\u0026#39;]) view.append(videoStat[\u0026#39;view\u0026#39;]) rank.append(videoStat[\u0026#39;his_rank\u0026#39;]) reply.append(videoStat[\u0026#39;reply\u0026#39;]) favor.append(videoStat[\u0026#39;favorite\u0026#39;]) coins.append(videoStat[\u0026#39;coin\u0026#39;]) share.append(videoStat[\u0026#39;share\u0026#39;]) like.append(videoStat[\u0026#39;like\u0026#39;]) cnt = cnt + 1 except: continue outfile = pd.DataFrame({\u0026#34;title\u0026#34;: title ,\u0026#34;author\u0026#34;: author, \u0026#34;rank\u0026#34;: rank, \u0026#34;score\u0026#34;: score, \u0026#34;view\u0026#34;: view, \u0026#34;coins\u0026#34;: coins, \u0026#34;favorite\u0026#34;: favor, \u0026#34;reply\u0026#34;: reply, \u0026#34;danmu\u0026#34;: danmu}) outfile.to_csv(\u0026#34;bilibili2.csv\u0026#34;, index = False) 数据分析 数据加载\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import pandas as pd # csv文件读写分析 import numpy as np # 线性代数 import matplotlib.pyplot as plt # 制图 data = pd.read_csv(\u0026#39;./bilibili.csv\u0026#39;, index_col=\u0026#39;title\u0026#39;) # 评分 score = data[\u0026#39;score\u0026#39;] # 播放量 view = data[\u0026#39;view\u0026#39;] # 投币 coins = data[\u0026#39;coins\u0026#39;] # 收藏 favor = data[\u0026#39;favorite\u0026#39;] # 评论 reply = data[\u0026#39;reply\u0026#39;] # 点赞 like = data[\u0026#39;like\u0026#39;] # 弹幕数量 danmu = data[\u0026#39;danmu\u0026#39;] # 分享次数 share = data[\u0026#39;share\u0026#39;] 绘制图像，观察数据之前的关系 由图像可以得出，b站综合打分的评分和各个数据之前有一定的相关性，主要为正相关。\n多元线性回归 我们的目的是得到 $f(x_i) = w^{T} x_i + b $ 类似的，使用最小二乘法估计w和b\n利用求解公式 $ \\hat w^{} = (X^{T}X)^{-1}X^{T}y$\n1 2 3 4 5 6 # 计算系数矩阵w-hat w_hat = np.dot(np.dot(np.linalg.inv(np.dot(X.T, X)), X.T), Y) # 获取b矩阵 b = w_hat[-1] # 获取w系数矩阵 w = w_hat[:-1] 看查w的值\n1 2 3 4 5 6 7 [[ 0.53588246] [ 2.01063732] [ 5.79443124] [-4.91889223] [17.51523907] [-3.73019387] [ 0.89537493]] 这里发现w系数矩阵中出现了负值，经检查发现该项目对应的自变量为like和reply，即视频的点赞次数和评论数，这与实际情况是不符的，猜测是因为该自变量对结果的影响过小，导致预测出现了偏差，同时发现弹幕数量对视频评分的影响过大，远超于其他参数，显然与实际生活不符，并且作为对视频质量的估计，弹幕数也的确不能作为一个重要的参数。\n因此我们对弹幕数进行剔除重新进行拟合。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 获取自变量矩阵，剔除弹幕数 X = data.iloc[:,[3, 4, 5, 6, 8, 9]].values # 获取因变量矩阵 Y = data.iloc[:,2].values.reshape(-1,1) # 生成设计矩阵 om = np.ones(X.shape[0]).reshape(-1,1) X = np.hstack((X, om)) # 计算系数矩阵w-hat w_hat = np.dot(np.dot(np.linalg.inv(np.dot(X.T, X)), X.T), Y) # 获取b矩阵 b = w_hat[-1] # 获取w系数矩阵 w = w_hat[:-1] print(w) 得到w的值为\n1 2 3 4 5 6 [[ 0.60269881] [ 2.82157809] [ 5.35461617] [ 3.04630747] [-3.9125348 ] [ 0.33063835]] 观察发现此时各项参数对于评分的影响已经较为接近正常水平。但是share，视频分享数对于评分的影响仍为负值，依然根据上述猜测，share对于总分的影响过小，导致拟合的结果差，因此再次剔除share字段。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 获取自变量矩阵，剔除弹幕数，分享数 X = data.iloc[:,[3, 4, 5, 6, 9]].values # 获取因变量矩阵 Y = data.iloc[:,2].values.reshape(-1,1) # 生成设计矩阵 om = np.ones(X.shape[0]).reshape(-1,1) X = np.hstack((X, om)) # 计算系数矩阵w-hat w_hat = np.dot(np.dot(np.linalg.inv(np.dot(X.T, X)), X.T), Y) # 获取b矩阵 b = w_hat[-1] # 获取w系数矩阵 w = w_hat[:-1] X_test = data.iloc[:, [3, 4, 5, 6, 9]].values Y_predict = np.dot(X_test, w) + b 得到w矩阵为\n1 2 3 4 5 [[0.59149795] [2.85961313] [4.47955342] [0.34492927] [0.35243338]] 绘制预测值与实际值图像 观察预测值与实际值的差距，发现拟合的趋势基本吻合，但仍有较大的误差\n分析得出，该线性模型的拟合误差较为集中，集中在[0, 181348.81788162683]即平均误差之间。\n1 2 3 4 5 [0.59149795] [2.85961313] [4.47955342] [0.34492927] [0.35243338] 根据权重分析各个数据对总分的影响，可以发现，收藏对于视频总评分的影响占比最高，其次是硬币数，播放数，说明哔哩哔哩对与视频的质量高低评判有一定的综合考量，播放量属于可以由视频制作人通过其他方式刷取，但是收藏量是由用户对于视频质量的高低做出的决定，因而更具代表性，更有说服力。反观实际观看体验中，有些视频制作人会以视频收藏满几万后，更新下一期视频，因为该项对视频的收益影响最大，更能给视频制作人带来实际收益。\n本次线性回归的拟合可以较为准确的判断出各各数据对于视频评分的影响，但是对于视频评分的预测误差较大，但是仍能较准确的判断出视频评分所影响的视频排名，认为有如下原因：\n数据量过少，导致拟合程度不足 评分规则非线形模型，应该更换模型 还有其他未考虑的因素 如果要更准确的对视频评分进行预测，应该综合分析数据的特性，或者采用机器学习等更优秀的手段来进行求解和预测，线性回归仍有一定的局限性。 ","date":"2021-07-02T14:05:48Z","permalink":"https://blog.ipandai.club/p/bilibili%E8%A7%86%E9%A2%91%E7%BD%91%E7%AB%99%E6%8E%92%E8%A1%8C%E6%A6%9C%E8%AF%84%E5%88%86%E7%9A%84%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/","title":"Bilibili视频网站排行榜评分的线性回归分析"},{"content":"迭代法求解方程的根 求解方程的根，即$f(x)=0$的数值解等问题，对于经典的二次方程等函数我们可以直接进行求解，但是对于超越方程我们不能用常规方法进行求解。因此我们可以通过使用计算机实现某些求解算法进行计算。\n选取样例\n$f(x) =x^3 - x - 2$\n$\\frac{dy}{dx} = 3x^2-1$\n求解$f(x)$在[1, 2]上的零点\n二分法 在高中数学课本我们就接触过二分法求函数零点，根据零点存在性定理，可以保证我们得到符合要求的一个根，但是该方法局限性太大，只能求解区间内的一个根。\n大致流程如下\n先确定要求解的区间[x, y]，然后不断对区间进行二分，根据精度要求判断根是否合法，再根据中点值与端点值的符号是否相同缩小二分范围。\n$if \\ f(mid)\\times f(l) \u0026gt; 0$\n$let \\ l = mid$\n$or \\ r = mid$\nCode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import numpy as np import math as m def f(x): return x**3-x-2 def binary(x, y): res = 0 eps = 1e-3 h = 1e-3 l = x r = y while l \u0026lt;= r: mid = (l+r)/2 if abs(f(mid)-0) \u0026lt; eps: return mid if f(mid)*f(x) \u0026gt; 0: l = mid else: r = mid return -1 answer = binary(1.0, 2.0) print(np.around(answer, 4)) 运算结果为1.5215\n牛顿迭代法 牛顿迭代法的基本思想为将非线性方程线性化，选取一个初始点，做切线交与x轴一点，然后继续该操作，直到根收敛或者达到精度要求。\n基本流程为\n取任意的迭代初始值$x_0$ 计算 $x_1 = x_0 - \\frac{f(x_0)}{f\u0026rsquo;(x_0)}$ 判断收敛性：如果$|x_1 - x_0|\u0026lt; \\epsilon \\ or |f(x_1)-0| \u0026lt; \\epsilon$ 令$x_0 = x_1$，保存上一步结果，继续迭代 Code\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import numpy as np import math as m # f(x) = x**3 - x - 2 # df/dx = 3x**2 -1 def df(x): return 3*x**2 - 1 def f(x): return x**3 - x - 2 def newton(x): eps = 1e-7 x0 = x x1 = x0 - f(x0)/df(x0) while abs(x1-x0) \u0026gt; eps: t = x1 x1 = t - f(t)/df(t) x0 = t return x1 answer = newton(1.0) print(np.around(answer, 4)) 运算结果为1.5214\n","date":"2021-04-25T13:04:57Z","permalink":"https://blog.ipandai.club/p/%E6%96%B9%E7%A8%8B%E6%B1%82%E6%A0%B9%E7%9A%84%E8%BF%AD%E4%BB%A3%E6%B3%95/","title":"方程求根的迭代法"},{"content":"求解线性方程组 在线性代数中，有一类经典问题，就是求解线性方程组，我们熟知的解法有高斯消元法，但是高斯消元法属于直接求解的方法，不适合编程计算，因此引入更适合计算机求解的迭代法。\n以线性方程组：\n$ \\left[ \\begin{matrix} 10 \u0026amp; -1 \u0026amp; -2 \\ -1 \u0026amp; 10 \u0026amp; -2 \\ -1 \u0026amp; -1 \u0026amp; 5 \\end{matrix} \\right] x = \\left[ \\begin{matrix} 7.2 \\ 8.3 \\ 4.2 \\end{matrix} \\right] $ 为例\nJacobi迭代法 考虑线性方程组$Ax=b$\n用L和U分别表示严格下三角矩阵和严格上三角矩阵\n可以利用迭代公式\n$x^{k+1}=D^{-1}(b-(L+U)x^{k}))$\n进行迭代求解，可以通过精度控制迭代次数，还需要控制迭代是否收敛，不然迭代次数再多也无法求解。\n迭代法需要给定解列向量的初值，因此初值的选取也很重要。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import numpy as np def Jacobi(A, B, N, x): # Ax=B N为迭代次数 # 获得对角矩阵的数组 D = np.diag(A) # 获得L+U矩阵，减去对角矩阵即可 # diagflat为D数组转为对角矩阵 R = A - np.diagflat(D) # R = L + U print(R/D) for i in range(N): # 迭代过程，可以直接/D表示逆矩阵 x = (B - np.dot(R, x))/D return x A = np.array([[10, -1, -2], [-1, 10, -2], [-1, -1, 5]] ) B = np.array([7.2, 8.3, 4.2]) # 设定迭代初始值 x = np.array([1, 1, 1]) answer = Jacobi(A, B, 30, x) print(answer) 求解结果为 x = [1.1, 1.2, 1.3]\nGauss Seidel迭代法 Gauss Seidel法使用了另一种迭代格式，获得了快的收敛速度\n首先我们利用迭代求解的特性，新得到的值总会比老值更优，因此使用新值来进行迭代，即\n$x^{k+1}=D^{-1}(b+Lx^{k+1}+Ux^k)$\n化简\n$x^{k+1}=(D-L)^{-1}(Ux^k+b)$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import numpy as np def GaussSeidel(A, B, N, x): # 下三角矩阵 L = np.tril(A) # 严格上三角矩阵 U = A - L # 获得对角矩阵 D = np.diagflat(np.diag(A)) LL = L - D # x^{k+1} = (D + L)^-1 (b - Ux^{k}) # 输出迭代矩阵 print(np.dot(np.linalg.inv(D-LL), U)) for i in range(N): # 使用linalg包中的inv函数求出L矩阵的逆矩阵 # 使用上述迭代公式求解 x = np.dot(np.linalg.inv(L), B - np.dot(U, x)) return x A = np.array([[10, -1, -2], [-1, 10, -2], [-1, -1, 5]] ) B = np.array([7.2, 8.3, 4.2]) # 设定迭代初始值 x = np.array([1, 1, 1]) answer = GaussSeidel(A, B, 30, x) print(answer) 解得x = [1.1, 1.2, 1.3]\n","date":"2021-04-25T00:38:16Z","permalink":"https://blog.ipandai.club/p/%E8%BF%AD%E4%BB%A3%E6%B3%95%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/","title":"迭代法求解线性方程组"},{"content":"常微分方程初值问题 常微分方程描述了不同变量之间的变化关系，通过该关系我们可以确定变量之间的具体函数关系，但是微分方程不一定总是可解的，并且有些求解起来相当困难。给出积分曲线初始位置的状态，求解需要预测点的状态，为常微分方程的初值问题，我们可以在求解微分方程即的情况下对结果做出复合精度要求的预测。\n以$f(x) = \\sqrt{1+2x}$为例\n有$y\u0026rsquo;=\\frac{dy}{dx}=y-\\frac{2x}{y}$\n本文给出几种算法的原理与实现。\nEuler方法及其改进 从初始点开始，根据不同离散点的导数值对曲线进行预测，导数值可以通过对ODE的化简求解，做出一条折线图，最终曲线会逼近预测值。\n该方法有明显的缺点就是在每一步做出抉择时，只考虑了当前的状态，并没有考虑后面的状态，因此必然会造成较大的误差，因此采用下一个结点的导数值进行修正。\n具体流程如下\n选取一定的步长h，一般为区间的n等分\n预测下一个值$\\overline{y}_{i+1} = y_i + hf(x_i, y_i)$\n校正预测值$y_{i+1} = y_i + \\frac{h}{2}[f(x_i, y_i)+f(x_{i+1}, \\overline{y}_{i+1})]$\n改写成平均化形式\n$y_p = y_i +hf(x_i, y_i)$\n$y_c = y_i + hf(x_{i+1}, y_p)$\n$y_{i+1} = \\frac{1}{2} (y_p+y_c), i =0,1,2,3,\u0026hellip;,n-1$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import numpy as np # 常微分方程化简 def ode(x, y): return y - 2 * x / y def f(x): return np.sqrt(1+2*x) def Euler(bound, start): \u0026#39;\u0026#39;\u0026#39; bound : 预测边界值 start : 起始点 \u0026#39;\u0026#39;\u0026#39; h = 0.1 # 对步长h等分 n = int(bound/h) x = np.zeros(n) y = np.zeros(n) sample = np.zeros(n) for i in range(0, n): # 获取均分后的所有点 x[i] = 0+i*h # 生成标准值做对比 sample[i] = f(x[i]) y[0] = start for i in range(1, n): # 预测值 yp = y[i-1] + h*ode(x[i-1], y[i-1]) yc = y[i-1] + h*ode(x[i], yp) # 使用预测值求加权平均值 y[i] = (yp+yc)/2.0 return y, sample answer,sample = Euler(2, 1) print(answer) print(sample) 运行结果：\n标准值\n[1. 1.09544512 1.18321596 1.26491106 1.34164079 1.41421356 1.4832397 1.54919334 1.61245155 1.67332005 1.73205081 1.78885438 1.84390889 1.8973666 1.94935887 2. 2.04939015 2.0976177 2.14476106 2.19089023]\n预测值\n[1. 1.09590909 1.18409657 1.26620136 1.34336015 1.41640193 1.4859556 1.55251409 1.61647478 1.67816636 1.7378674 1.79581974 1.8522386 1.90732042 1.96124939 2.01420304 2.06635728 2.11789132 2.16899248 2.21986124]\nRunge-Kuta法 Runge-Kuta法在思想上与之前的方法大致相同，都是通过若干个斜率的加权平均值来做出下一步选择。此处只给出常用的四阶Runge-Kuta的处理方式。\n$K_1=f(x_i,y_i)$\n$K_2 =f(x_i + \\frac{h}{2}, y_i + \\frac{h}{2}K_1)$\n$K_3=f(x_i + \\frac{h}{2}, y_i + \\frac{h}{2}K_2)$\n$K_4=f(x_i + h, y_i + hK_3)$\n$y_{i+1}= y_i + \\frac{h}{6}(K_1+K_2+K_3+K_4)$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import numpy as np from matplotlib import pyplot as plt def ode(x, y): return y - 2 * x / y def f(x): return np.sqrt(1+2*x) def RungeKutta(bound, start): \u0026#39;\u0026#39;\u0026#39; bound : 计算边界 start : 初始值f(0) \u0026#39;\u0026#39;\u0026#39; h = 0.1 n = int(bound/h) x = np.zeros(n) y = np.zeros(n) sample = np.zeros(n) for i in range(0, n): x[i] = 0+i*h sample[i] = f(x[i]) y[0] = start for i in range(1, n): # 求各个点的斜率 k1 = ode(x[i-1], y[i-1]) k2 = ode(x[i-1] + h/2, y[i-1] + h/2*k1) k3 = ode(x[i-1] + h/2, y[i-1] + h/2*k2) k4 = ode(x[i-1] + h, y[i-1] + h * k3) # 对斜率求平均值并进行预测 y[i] = y[i-1] + h/6*(k1 + 2 * k2 + 2 * k3 + k4) plt.show() return y, sample y, sample = RungeKutta(2, 1) print(y) print(sample) 运行结果 ： 预测值\n[1. 1.09544553 1.18321675 1.26491223 1.34164235 1.41421558 1.48324222 1.54919645 1.61245535 1.67332466 1.73205637 1.78886107 1.84391692 1.89737622 1.9493704 2.00001382 2.0494067 2.09763752 2.14478481 2.1909187 ]\n标准值\n[1. 1.09544512 1.18321596 1.26491106 1.34164079 1.41421356 1.4832397 1.54919334 1.61245155 1.67332005 1.73205081 1.78885438 1.84390889 1.8973666 1.94935887 2. 2.04939015 2.0976177 2.14476106 2.19089023]\n","date":"2021-04-23T23:26:18Z","permalink":"https://blog.ipandai.club/p/%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%88%9D%E5%80%BC%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A3%E6%96%B9%E6%B3%95/","title":"常微分方程初值问题求解方法"},{"content":"数值积分 应用背景：微积分的基本计算公式为经典的牛顿莱布尼茨公式，但是作为计算机来说，计算原函数等操作过于困难，因此需要其他方法进行优化，代替牛顿莱布尼茨公式进行计算，本文将分享两种求积公式及其代码实现。\n使用语言： Python-Numpy\n使用两种方法计算$f(x)=sin(x)$在[1,2]上的积分\n复化梯形的递推公式 由梯形公式改进，将区间[a, b]等分为n个小区间 $[x_i, x_{i+1}]$\n$\\int_{a}^{b}f(x)dx=\\sum_{i=0}^{n-1}\\int_{x_i}^{x_{i+1}}f(x)dx\\approx \\frac{h_i}{2}[f(x_i)+f(x_{i+1})]$\n根据梯形公式化简为区间端点值组合\n将求和公式展开，分离出左右端点\n得到最终的化简结果\n$T_n = \\frac{h}{2} [f(a)+2\\sum_{i=1}^{n-1}f(x_i)+f(b)]$\n但是该方法的步长太小的话会导致计算次数太大，步长太大又难以保证效率\n采用区间不断对分的方法，取$n = 2^k$，反复使用复合求积公式\n$T^{(k)}=\\frac{1}{2}T^{(k-1)}+\\frac{h_{k-1}}{2}\\sum_{i=0}^{2^{k-1}-1}f(a+ih_{k-1} + 0.5h_{k-1})$\n其中$h_{k-1} = \\frac{b-a}{2^{k-1}}$\nCode\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import numpy as np def f(x): return np.sin(x) def Calc(): eps = 1e-7 Flag = True l = 1.0 r = 2.0 h = r - l t1 = 1.0*(h/2)*(1+f(r)) t2 = 0.0 while Flag: sum = 0 x = l + h/2 while x \u0026lt; r: sum += f(x) x += h t2 = t1/2 + h*sum/2 h /= 2.0 if abs(t2 - t1) \u0026lt; abs(eps): Flag = False t1 = t2 res = t2 return res answer = Calc() print(answer, 6) 0.9564492180077249\nRomberg 算法 基于梯形递推公式，将上一级递推公式的结果进行线性组合，得到Simpson公式，再对Simpson公式结果进行线性组合得出Cotes公式结果，最后对Cotes公式线性组合得出Romberg算法的递推公式\n该方法为Richardson外推法\n$T_{m}^{(k)}=\\frac{4^m T_{m-1}^{(k+1)} - T_{m-1}^{(k)}}{4^m - 1}$\nk为Romberg算法的阶数，Romberg算法具有收敛性，一般情况下我们取四阶 k = 3进行计算就可以满足精度要求\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import numpy as np def f(x): return np.sin(x) # 计算梯形公式的结果 def trapezcomp(l, r, k): h = (r - l)/k x = l Sum = f(x) for i in range(1, k): x += h Sum += 2*f(x) return (Sum + f(r))*h*0.5 def romberg(x, y, n): \u0026#39;\u0026#39;\u0026#39; x : 积分下限 y : 积分上限 n : Romberg算法求解的阶数 \u0026#39;\u0026#39;\u0026#39; I = np.zeros((n, n)) for i in range(0, n): # 获得梯形公式的结果 I[i, 0] = trapezcomp(x, y, 2**i) for j in range(0, i): # 使用加速递推公式计算 I[i, j+1] = (4**(j+1)*I[i, j] - I[i-1, j])/(4**(j+1)-1) # 返回4阶Romberg算法的递推值 return I[n-1, n-1] answer = romberg(1.0, 2.0, 4) print(answer) 运行结果： 0.9564491426149814\n","date":"2021-04-23T20:18:59Z","permalink":"https://blog.ipandai.club/p/%E6%95%B0%E5%80%BC%E7%A7%AF%E5%88%86%E6%96%B9%E6%B3%95/","title":"数值积分方法"},{"content":"插值方法 插值属于数值分析领域中的一种方法，是一种通过已知的离散的数据点，来拟合原函数根据给定的自变量估算因变量的方法。\n常用的插值方法有很多，本文章给出三种常见的插值方法的实现。\n使用语言: Python\n使用下面的数据，预测函数在x=1处的值\n1 2 x = np.array([0.5, 0.6, 0.4, 0.7]) y = np.array([-0.6931, -0.5108, -0.9163, -0.3567]) 线性插值 线性插值及求一次多项式$p(x)$，满足$p(x_0), p(x_1) = y_1$ 可以根据点斜式方程求解 即\n$p(x) =y_0 \\frac{y_{1}-y_{0}}{x_1-x_0}(x-x_0)$ 还可以将公式整理成如下形式\n$p(x) = y_0 \\frac{x - x_1}{x_0 - x_1} + y_1 \\frac{x- x_0}{x_1 - x_0}$\n我们令这里的$l_0(x)=\\frac{x-x_1}{x_0 - x_1}, l_1(x)=\\frac{x-x_0}{x_1-x_0}$\n将其线性组合之后即为\n$p(x)=y_0 l_0(x)+y_1 l_1(x)$\n是Lagrange插值的特殊形式\n此处给出线性插值的代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import numpy as np def linear(x, y, x0): \u0026#39;\u0026#39;\u0026#39; x : 为横坐标数组 y : 为纵坐标数组 x0: 为需要预测点的横坐标 res: 预测结果 \u0026#39;\u0026#39;\u0026#39; res = y[1] + (y[1] - y[0])*(x0 - x[1])/(x[1] - x[0]) # 根据公式计算结果 return res x = np.array([0.5, 0.6, 0.4, 0.7]) y = np.array([-0.6931, -0.5108, -0.9163, -0.3567]) answer = linear(x, y, 1) print(np.around(answer, 4)) # 保留四位小数 Largrange插值 根据Lagrange插值基函数$l_k(x)$，其满足如下性质 当$i=k,l_k(x_i)=1$\n当$i\\not ={k}, l_k(x_i) = 0$\n其中$l_k(x) = \\prod_{i=0,i \\not ={k}}^{n} \\frac{x-x_i}{x_k-x_i}$\n可以得到$p(x)=y_0 l_0(x) + y_1 l_1(x) + \u0026hellip; + y_n l_n(x)$\n$p(x)$满足$p(x_i)=y_i, i = 0,1,\u0026hellip;,n$\n即根据插值结点确定的方程，可以使得$p(x_i)=y_i$，是一种可行的插值方法，极大的提高了插值精度。\n并且当只有两个插值结点时，Lagrange插值就退化成了线性插值，当有三个结点时，退化成抛物线插值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import numpy as np from matplotlib import pyplot as plt def largrange(x, y, x0): \u0026#39;\u0026#39;\u0026#39; x : x数组 y : y数组 x0: 预测点横坐标 res: 预测结果 \u0026#39;\u0026#39;\u0026#39; n = len(x) res = 0 for i in range(n): param = np.append(x[:i], x[(i+1):]) # 获得除去xi的所有横坐标 numerator = (x0 - param).prod() # 分子，使用prod求出矩阵中所有元素的积 denominator = (x[i] - param).prod() # 计算分母 res += y[i]*numerator/denominator # 根据公式计算当前步骤对答案的贡献 return res x = np.array([0.5, 0.6, 0.4, 0.7]) y = np.array([-0.6931, -0.5108, -0.9163, -0.3567]) answer = largrange(x, y, 1) print(np.around(answer, 4)) 运行结果： 0.0634\nNewton插值 我们引入差商的概念， 设有函数$f(x), x_0,\u0026hellip;,x_n$\n$f[x_i, x_j] = \\frac{f(x_j)-f(x_i)}{x_j - x_i}$\n称为$f(x)$关于点$x_i, x_j$的一阶差商\n$f[x_i, x_j, x_k] = \\frac{f[x_j, x_k] - f[x_i, x_j]}{x_k - x_i}$\n称为$f(x)$关于点$x_i， x_j， x_k$二阶差商\n我们可以得到差商的一般定义，对于k阶差商\n$f[x_0, x_1, \u0026hellip;, x_k] = \\frac{f[x_1, \u0026hellip;, x_k] - f[x_0, \u0026hellip;, x_{k-1}]}{x_k - x_0}$ 计算差商可以通过差商表来计算\n$x_i$ $f(x_i)$ 一阶差商 二阶差商 三阶差商 \u0026hellip; n阶差商 $x_0$ $f(x_0)$ $x_1$ $f(x_1)$ $f[x_0, x_1]$ $x_2$ $f(x_2)$ $f[x_1, x_2]$ $f[x_0, x_1, x_2]$ $x_3$ $f(x_3)$ $f[x_2, x_3]$ $f[x_1, x_2, x_3]$ $f[x_0, x_1, x_2, x_3]$ \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; $x_n$ $f(x_n)$ $f[x_{n-1}, x_{n}]$ $f[x_{n-2}, x_{n-1}, x_{n}]$ $f[x_{n-3}, x_{n-2}, x_{n-1}, x_{n}]$ $f[x_0, x_1, \u0026hellip;, x_n]$ 将对角线上的差商值用来构造插值函数\n$f(x) = f(x_0) + f[x_0, x_1](x- x_0) + f[x_0, x_1, x_2](x - x_0)(x - x_1) + \u0026hellip; + f[x_0, \u0026hellip;, x_n](x - x_0)\u0026hellip;(x - x_{n-1}) + f[x,x_0,x_1,x_2,\u0026hellip;,x_n](x - x_0)\u0026hellip;(x - x_{n})$\n其中$R(x) = f[x,x_0,x_1,x_2,\u0026hellip;,x_n](x - x_0)\u0026hellip;(x - x_{n})$为插值余项\n综上，牛顿插值的最终表达式为\n$R(x) = N(x)+R(x)$\n牛顿插值的插值基函数有可继承的特点，可以优化计算方法\n直接利用上一次的计算结果增量更新\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import numpy as np # 计算差商表第j列的元素 def GetColumRes(arr, j): n = len(arr[:,0]) colum = np.zeros(n) for i in range(j-1, n): colum[i] = (arr[i, j-1] - arr[i-1, j-1])/(arr[i, 0] - arr[i-j+1, 0]) return colum # 计算差商 def CalculateDividedDiffernces(x, y): n = len(x) arr = np.zeros((n, n+1)) arr[0:n, 0] = x arr[0:n, 1] = y for i in range(2, n+1): # 获得差商表第i列的元素 arr[:, i] = GetColumRes(arr, i) print(arr) return arr def newton(x, y, x0): res = y[0] n = len(x) factor = 1 DD = CalculateDividedDiffernces(x, y) for i in range(1,n): # factor因数迭乘 factor *= (x0-x[i-1]) # 取出对角线上的元素进行计算 res += DD[i, i+1]*factor return res x = np.array([0.5, 0.6, 0.4, 0.7]) y = np.array([-0.6931, -0.5108, -0.9163, -0.3567]) answer = newton(x, y, 1) print(np.around(answer, 4)) 运行结果：\n差商表\n[ 0.5 -0.6931 0. 0. 0. ]\n[ 0.6 -0.5108 1.823 0. 0. ]\n[ 0.4 -0.9163 2.0275 -2.045 0. ]\n[ 0.7 -0.3567 1.86533333 -1.62166667 2.11666667]\n运行结果 0.0634\n","date":"2021-04-19T22:22:57Z","permalink":"https://blog.ipandai.club/p/%E4%B8%89%E7%A7%8D%E6%8F%92%E5%80%BC%E6%96%B9%E6%B3%95%E5%8F%8A%E5%AE%9E%E7%8E%B0/","title":"三种插值方法及实现"},{"content":"学校重构之后的OJ终于进入了前后端对接的阶段，经过了一周的紧张对接环境，项目依然是(正在稳定推进的阶段)，和前端对接口的一周里，我感觉到自己之前工作的不足，在此做出反思，以后要改掉这些错误。同时在和运维一起部署的过程中，也发现了许许多多的问题，在此一并记录一下。\nAccess to Judger Ana In Docker 因为OJ要防止恶意代码的提交，解决办法就是使用docker，为了让评测机稳定于是又要在docker里跑一个docker。 直接docker run评测机，用了一下judge_test的模块，发现返回的结果全是AC，这就非常奇怪了。问了一下hr发现ana是用grpc通信的，好，没有学过，于是开始看怎么测试grpc是否正常，初步定位问题是没接上。也去docker里配了一下环境，加了工作目录，放行端口，发现还是不行。当hr进入服务器的时候，才发现真正的问题所在。直接docker pull的时候是跑的master分支的镜像，而新评测机接口是在另一个分支的。于是把锅甩给了嘎嘎豪。\nNPM throw error 后端采用了go语言的gin+gorm框架搭建，直接go build然后丢到后台守护进程，前端使用了vue框架，要先用npm build一下，但是我本意是想直接npm run serve的，无奈npm一直疯狂报错。最初我也是打算现在本地run serve然后只测试后台的，但是npm先是依赖问题没有解决，最后重装了全局的依赖之后发现报错有个字段为darwin-arm64，看到这个我就感觉不对劲，可能是M1芯片没有合适的包可以下载，于是才决定丢到服务器上。在服务器上也是遇到了依赖的问题，直接尝试删除所有包，包括全局包，发现一个报错，大概就是说npm要没钱了，快来funding，好家伙，我直接npm uninstall * --no-fund删除了所有依赖，然后重新npm install，跑完之后在此run serve，显然还是不行，问了王哥之后他给出了一个解决办法，先build然后用nginx反代到build之后生成的dist文件夹中。于是开始build，很不错，这回没有报错。于是开始了nginx反代。\nNginx 服务器没有绑定域名，因此直接将服务器的某个端口直接映射到前端渲染出来的dist文件夹中去，需要现在安全组放行端口，这里就不得不提一下宝塔界面了，最初接触服务器的时候感觉宝塔确实很方便，今天运维也吐槽了一下，有些地方宝塔反而做复杂了，我就感觉上传或者下载文件比较方便，懒得用ftp。还不得不提yum包管理器是我用过最难用的，不如pacman，也没apt包全，但是总不能在服务器上跑arch吧 Orz。 在宝塔上装了Nginx，开始做反代。 先是监听一下888端口,并反代/请求到dist文件夹,设置首页为index.html\n1 2 3 4 5 6 server { listen 888; index index.html index.htm index.php; root /root/dev/OnlineJudge/front_end/dist; } 好，重载一下nginx的配。 咦，发现403 forbidden，运维猜测是nginx没有权限访问那个目录。 这就开始打算直接chmod 777了，仔细一看发现，没改nginx配置里的user。\n1 user root root; 正常情况下建议分一个用户单独给nginx。 然后发现访问首页是空白内容，打开F12看看，发现是js和css的请求全阻塞了，又去看了一眼nginx的配置，发现正则匹配的js和css文件目录不对。\n1 2 3 4 5 6 7 8 9 location ~ .*\\.js?$ { root /root/dev/OnlineJudge/front_end/dist; } location ~ .*\\.css?$ { root /root/dev/OnlineJudge/front_end/dist; } 这里要注意，一开始我是分别代理到/dist/js和/dist/css文件夹的，这样是不对的，因为请求的uri里是带有js和css字段的，于是就造成了路径不对，成了/js/js/**。 至此，首页可以成功进入了。 开始测试喜闻乐见的登录环节，发现请求没发出去，前端的请求之前是发送到远程服务器的，现在应该是访问本机localhost，于是进行代理转发请求\n1 2 3 4 location /api { proxy_pass http://127.0.0.1:5000; } 终于可以登录了。到了八点多，感觉要下班了，又发现后台登录不进去了，又发现是只有我自己的chrome登录不进去，看日志的报错是interface提取的时候出问题了，uint和int之间产生了冲突，但是感觉事情没有那么简单，定位到出错的代码之后，发现异常是用_接收的，于是又对id打了log，再次运行。 这个id怎么这么熟悉。原来是前端的session里的id，看来是因为前台后台共用了session，导致id混用了。\nEnd 此时已经到了晚上八点多了，看似已经解决了不少bug，但是很多问题都是和OJ无关的配置问题，真正的debug才刚刚开始。\n项目正在稳定的向前推进。\n","date":"2021-04-03T22:22:14Z","permalink":"https://blog.ipandai.club/p/oj%E9%83%A8%E7%BD%B2debug%E8%AE%B0%E5%BD%95/","title":"OJ部署debug记录"},{"content":"对于git，很早很早就在用了，但是还没有系统整理过，并且有些命令使用时需要注意的事项，在此也一并标出。\nAbout Git git是一个分布式版本控制工具，如果你是一个程序猿，那你必须要学会如何使用git来管理你的代码或者项目。 可能更多人所熟知的是GitHub，顾名思义，按照英语的命名特点，GitHub就是所有git上传的枢纽，汇聚到一起，你可以开源你的代码，指定一款开源协议共享给所有需要的人，也可以将仓库设为私有，只有自己或者受到邀请的人可见或者进行编辑。 除了GitHub，世界上还有很多这种代码托管平台，比如国内的gitee,coding等，国外还有gitlab等平台提供代码托管服务。\nSetup 在一个目录中，你可以使用git init来初始化这个目录，git会把这个文件夹变为一个git目录，\n1 2 \u0026gt; GitTest git init Initialized empty Git repository in /Users/username/GitTest/.git/ 使用git remote add origin {your repo url} 即可添加远程的仓库地址。\nCommit \u0026amp;\u0026amp; Push 对于一个采用迭代式开发或者其他开发模式的项目来说，都避免不了后续对代码进行修改或者添加一些新的文件，对于每一次这样的操作，都要对添加或者修改的文件指定一个commit。 例如：修改了项目功能中的bug，文件名字为a.cpp 可以使用\n1 2 git add a.cpp git commit -m \u0026#34;fix: the bug in xxx\u0026#34; 这样就可以将此次更改添加到提交的队列中 如果使用git add .，git将添加所有监控的文件到缓冲区 再使用git push就可以将修改添加到远程仓库中\n对与一个团队而言，有标准规范的commit格式是很重要的，例如以下格式\n1 2 3 4 5 feat: 新功能feature fix: 解决bug add: 添加模块 update: 更新模块 ... 等等 Dangerous Pull ing 如果是多人协作开发，那么必然会导致本地文件之间存在着不一致，为了解决这个问题，可以使用git pull，执行该命令后将同步仓库中存在并且与本地不同的文件。 这个操作看似简单，但是有时候如果使用了\u0026ndash;force强制执行的话，会覆盖掉本地的文件，属于非常危险的操作，所以无论在什么时候使用\u0026ndash;force之前都要思考清楚自己在干什么。\nBranch 我觉得git很强大的一个功能就是对分支的管理，在不同分支中切换可以让项目的代码得到更有效的管理，例如在main主分支中保存可以稳定运行的版本，在另一个dev分支中保存正在开发的非稳定版，后续改进之后可以将dev分支合并到main分支中去。 如果更新过后的主分支依然出现问题，也是可以通过回滚的方式回到之前某个稳定的版本。 分支的创建也非常简单\n1 2 git branch name git checkout name 切换后git所有的操作将在新的分支进行\n.gitignore 顾名思义，肯定是让git去忽略某些项目，比如文件夹，或者是单个文件，添加到gitignore之后git将不在追踪这些文件的变化，因此我们可以将例如npm庞大的node_modules这种文件夹添加到其中，或者是编译器调试产生的临时文件，优化仓库的存储结构。\n1 git status 使用该命令看查目前项目的改动\n1 2 3 4 5 6 On branch dev Untracked files: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to include in what will be committed) b.cpp nothing added to commit but untracked files present (use \u0026#34;git add\u0026#34; to track) git监控到了文件b.cpp的产生，我们将b.cpp添加到.gitignore中\n1 2 On branch dev nothing to commit, working tree clean 再次使用git status看查，发现b.cpp已经不再被监控了，在.gitignore中还可以使用文件夹名忽略整个文件夹的项目，或者使用通配忽略包含特定后缀名的文件等。\nEnd 随着开发工具的现代化，很多时候我们已经用不到这些git命令了，很多繁琐的命令早已被图形化的界面取代，但不乏还有git爱好者们做出的努力，如lazygit等工具。 当你接收一台崭新的服务器时，这些命令又显得格为重要了。因此，在简便的工具的包裹下，他们背后的原理才是最值得我们去了解的，就如同学习汇编语言一样，给力我们另一种看待程序的方式。 很早就像总结一下git了，拖了这么久终于写完了，后续还想再添加一些更具体的内容，希望能给初入git的同学一些启发。\n","date":"2021-04-02T22:33:25Z","permalink":"https://blog.ipandai.club/p/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"Git学习笔记"},{"content":"最近写了一个go项目，需要部署到服务器进行测试，如果只是go run main.go难免也太麻烦了点，于是学习了项目部署的相关知识。 项目的部署有多种方式，Jenkins,nginx等方式，本文只讲解一下简单的shell脚本部署。\n系统信息 系统信息: CentOS Linux release 8.3.2011 x86_64 Go version: go version go1.14.12 linux/amd64\n几条命令的介绍 nohup nohup命令的全称为no hang up不挂起，可以在系统后台不挂断的运行命令，退出终端后程序也会正常运行。 语法格式： nohup ./xxx \u0026gt; xxx.log 2\u0026gt;\u0026amp;1 \u0026amp; 解释： \u0026gt; xxx.log表示将输出重定向至该文件，可以记录运行时的日志 2\u0026gt;\u0026amp;1将标准错误2重定向到标准输出\u0026amp;1，然后标准输出\u0026amp;1再被重定向至xxx.log文件\ngit pull git pull origin dev 为了方便项目的及时更新，使用改名了保证运行时与上游仓库的代码保持一致。\nps ps命令为 process status,可以查看系统当前的进程状态\n例如\n1 2 3 4 5 6 ~\u0026gt; ps PID TTY TIME CMD 255873 pts/0 00:00:02 zsh 258517 pts/0 00:00:00 sh 258519 pts/0 00:00:00 OnlineJudge 263021 pts/0 00:00:00 ps 我们将用ps命令与grep等命令筛选出项目的pid ps命令有很多参数选择，这里介绍一下用到的两条命令:\n1 2 ps -e 列出所有进程 ps -f 显示进程的全部信息 grep grep命令可以查找文本中符合条件的字符串，用于匹配进程的名称， 还可以匹配文本中的各种信息，本文不再具体展开，后续打算更一篇具体记录Linux命令的博客。\nawk 用于处理文本提取信息，将使用grep查询到的进程信息提取出pid 查询到的结果为 root 263948 263946 0 12:49 pts/0 00:00:00 ./OnlineJudge 我们只需要第二项的pid，使用 awk {print $2} 即可提取出进程的pid 263948\nkill kill pid杀死进程\nShell脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 echo -e \u0026#34;*** Online_Judge ***\\n\u0026#34; echo -e \u0026#34;*** 检查上游代码中 ***\\n\u0026#34; git pull origin dev echo -e \u0026#34;*** 编译中 ***\\n\u0026#34; go build chmod -R 777 OnlineJudge pid=`ps -ef|grep OnlineJudge|grep -v grep|awk \u0026#39;{print $2}\u0026#39;` echo -e \u0026#34;$pid\\n\u0026#34; kill $pid \u0026amp;\u0026amp; nohup ./OnlineJudge \u0026gt; OnlineJudge.log 2\u0026gt;\u0026amp;1 \u0026amp; pid2=`ps -ef|grep OnlineJudge|grep -v grep|awk \u0026#39;{print $2}\u0026#39;` echo -e \u0026#34;项目部署成功***进程ID为:$pid2\u0026#34; 将脚本保存至项目目录，赋予执行权限 chmod +x setup.sh 执行脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ➜ git:(dev) ✗ ./setup.sh *** Online_Judge *** *** 检查上游代码中 *** From url * branch dev -\u0026gt; FETCH_HEAD Already up to date. *** 编译中 *** *** 添加权限 *** 添加权限成功 *** kill进程 *** 258519 ./setup.sh: line 18: 258519 Terminated nohup ./OnlineJudge \u0026gt; OnlineJudge.log 2\u0026gt;\u0026amp;1 项目部署成功***进程ID为:263948 至此项目即可部署成功 上述shell中的视个人情况而修改\nReference Linux命令大全 如何优雅的通过Shell脚本一键部署GO项目到服务器？ ","date":"2021-03-30T12:23:42Z","permalink":"https://blog.ipandai.club/p/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1go%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%83%A8%E7%BD%B2/","title":"记录一次Go项目的部署"},{"content":"简介 本学期选了汇编语言这门选修课，我认为还是有很大的学习价值的，虽然学习的还是年代久远的8086CPU指令集，但对后续接触更多汇编语言还是有很大帮助，方便我们调试程序，多了一种查错的方式。 其实关于调试自己很久之前就想学了，高中的时候看紫书，发现lrj老师讲了一段的gdb调试方法，当时感觉一点都看不懂，现在借此机会学习一下gdb的调试。 本文除了将总结一些汇编语言学习过程中的笔记之外，还计划穿插一些cs213/CSAPP 的内容以及bomb lab的解析。\n准备工作 dos系统现在以及年代久远，想使用8086CPU指令集调试的话需要借助DosBox来实现。 DosBox官网\n由于macOS下没有DOSbox需要的调试工具，因此下载之后需要挂载debug.exe等Windows下的调试工具 在DOSbox中输入\n1 2 3 mount C ~/dos C: debug 即可进入debug模式\n实验1 前置知识 几条汇编指令\n1 2 3 4 mov 目标操作对象,源操作数 add 目标操作对象,源操作数 jmp 寄存器 //修改IP寄存器的值 or 1 2 3 4 5 jmp CS:IP eg: jmp ax == (let IP = ax) jmp 2AE3:3 == let CS = 2AE3H and let IP = 0003H sub ax,bx ax = ax - bx 1 2 3 4 inc and dec inc 操作对象 eg: inc ax == ax+=1 dec ax == ax-=1 注意：不可用mov指令修改段寄存器的值。（代码段寄存器CS，指令指针寄存器IP） CPU中识别CS:IP为执行指令 操作对象可以是寄存器，也可以是地址\nDebug命令\n1 2 3 4 5 6 r: 看查寄存器内容，或者修改寄存器内容 d: 看查内存内容 e: 改写内存内容 u: 将机器指令翻译为汇编指令 t: 执行下一条汇编指令 a: 写入汇编指令 编译指令\n1 2 3 masm test link test.obj debug test.exe lab1 1 2 3 4 5 6 7 8 MOV WORD PTR [1100],3445 MOV WORD PTR [1102],5678 MOV WORD PTR [1106],6732 MOV AX,[1100] SUB AX,[1102] ADD AX,[1106] MOV [1104],AX HLT //使CPU停止工作 1 2 3 4 5 6 7 8 9 10 11 12 MOV\tAX,1234 MOV\t[1000],AX MOV\tBX,1002 MOV\tBYTE PTR[BX],20 MOV\tDL,39 INC\tBX MOV\t[BX],DL DEC\tDL MOV\tSI,3 MOV\t[BX+SI],DL MOV\t[BX+SI+1],DL MOV\tWORD PTR[BX+SI+2],2846 ","date":"2021-03-16T10:29:27Z","permalink":"https://blog.ipandai.club/p/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/","title":"汇编语言笔记"},{"content":"本文随机更新机组笔记\nCH2数据表示 定点数与浮点数 定点数 小数点的位置固定不变，有两种形式，定点小数和定点整数. 定点整数要求小数点在数据最低有效数位之后。 $00101001.$ 定点小数要求小数点在数据最高有效数位之前。 $0.1111111$\n浮点数 基数为2的数F，浮点表示为 $F = M \\times 2^E$ 其中M为尾数，E为阶码。尾数为带符号的纯小数，阶码为带符号的纯整数。按照上式表示的数字既可以是纯整数，也可以是纯小数，因此小数点位置不固定，所以称为浮点数。\n在计算机中，常用的一种浮点数表示方法为\n数符 阶符 阶码数值部分 尾数数值部分 1 1 k n 阶码和尾数的数值范围为\n阶码与尾数 数值 阶码与尾数 数值 阶码最小值 $-2^k$ 阶码最大值 $2^k-1$ 尾数最小负值 $-1$ 尾数最大负值 $-2^{-n}$ 尾数最小正值 $+2^{-n}$ 尾数最大正值 $+(1-2^{-n})$ 因此可以得到浮点数表示的数值范围： 最小负数:$-2^{2^k-1}=-2^{阶码最大值}$\n最大负数:$-2$\n因此浮点数编码位数位 $m=(n+1)+(k+1)$\n补码 补码的特点：\nn位补码表示的整数数值范围为$[-2^{n-1},2^{n-1}-1]$\nn位补码表示的小数数值范围为$[-1,1-2^{-n+1}]$\n在补码中0的表示是唯一的\n变形码，当模数为4时，可以形成双符号位补码，11表示负，00表示正，当两个符号位不同时表示运算溢出，又叫做变形补码。待更\n求补运算，处理器中有求补指令，其功能是对操作数取负数(所有位变反+1)\n简化加减法 $[X+Y]_补= _补+[Y]_补$\n移码 当一个数字的正数所对的二进制与负数所对的二进制直接比较大小时，会出现负数所对的二进制更大的情况。例如对于十进制数31\n$10011111_{-31} \u0026gt; 01100001_{31}$\n如果对负数补码上加上一个偏移量，再进行比较即可反应实际情况。\n定义为: 对于包括符号位在内的n位字长，在其真值上加上$2^{n-1}$ $[X]_移 =2^{n-1}+X$\n特点： $[X]_移\u0026lt;符号为取反\u0026gt;[X]_补$\n纠错码 若有n位数据，添加k位校验位，共有n+k位编码\n海明距离： $d = |x-y|=\\sum_{i=0}^{m-1}|x_i-y_i|$\n可以使用位运算异或求解，获得海明距离\n奇偶校验码 奇校验：设 $X = x_0x_1x_2x_3x_4\u0026hellip;x_{n-1}$ 是一个n位字，在最高位添加一位奇校验c使得 $X\u0026rsquo;=cx_0x_1x_2x_3x_4\u0026hellip;x_{n-1}$ 有 $c \\oplus x_1\\oplus \u0026hellip; \\oplus x_{n-1} = 1$\n偶校验则相反，只能判断是否出错，无法纠错\n海明校验码 对于16位数据，用 $D_{16}-D_{0}$ 分别表示高位到低位，要使其拥有1位纠错功能，则需要在有效信息中添加5个校验位，H4～H0 此时海明码的码长为 $m=n+k=16+5=21$\n循环冗余校验码 大概就是用一个性能比较好的生成多项式构造一个编码，利用模2除法的余数进行校验，而且纠错性能不是100%，先Pass\n运算方法和运算器 加减运算 利用补码的性质，可以将运算转化为补码的加法。\n$[X+Y]_补=[X]_补+[Y]_补$\n这里有一个需要区分的概念，求补运算和求补码的区别\n求补：对一个正数求补，令其包括符号位在内的各位取反再加1，即可得到该数的负数，若对该负数再求补，可以得到原来的正数。\n$[[X]_补]_求=[-X]_补$\n同理有\n$[[-X]_补]_求=[X]_补$\n可以总结出补码减法的运算法则为\n$[X-Y]_补 = [X]_补+[-Y]_补 =[X]_补+[[Y]_补]_求$\n因此可以将减法转化为加法运算\n溢出判断 只有两个符号相同的数字相加，或者符号相异的数相减才有可能发生溢出。 若分别用xyz表示三个数字的符号位，可得标准最小项 $\\overline{x} \\cdot \\overline{y} \\cdot z+x\\cdot y\\cdot \\overline{z}$ 只有该式为真时，将发生溢出。\n双符号位判定 每个数字有两个符号位，其中00表示正数，11表示负数 令OF OverflowFlag表示溢出符号 $S_1,S_2$ 分别表示运算结果的两符号， 有 $OF = S_1 \\oplus S_2$\n进位符号判定 $令 C_{n-1}表示最高数值位产生的进位，C_n表示符号位产生的进位$ 即有 $OF = C_{n-1}\\oplus C_n$\n一位全加器 计算每一位逻辑 $Z_i=X_i\\oplus Y_i \\oplus C_i$ 进位信号通过递推产生 可以设计出简单的行波式进位加法器，从最低位开始传递进位信号，是异步时序电路，因此运算速度比较慢。\n在位数已知的情况下，可以设计电路一次性计算出所有的进位信号，比较理想的情况是以四个位数为一组，该电路增长量级太大，如果需要更多位数可以利用多个该电路组合使用，组成组内并行组间串行进位加法器。\n","date":"2021-03-15T19:53:04Z","permalink":"https://blog.ipandai.club/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/","title":"计算机组成原理笔记"},{"content":"文章总结自KaTex Support 待更新\nKATEX Support\nKATEX测试 $$ \\frac{\\sum_{i=1}^Nf(x_i)}{\\int_1^\\infin \\frac{1}{e^x}} $$\n","date":"2021-03-14T20:50:48+08:00","permalink":"https://blog.ipandai.club/p/katex%E6%B5%8B%E8%AF%95%E5%8F%8A%E5%85%B6%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/","title":"Katex测试及其语法总结"},{"content":"从hexo到hugo 从高中开始就采用hexo+GitHub Pages的方式搭建博客，hexo确实很强大，但是由于需要借助node的原因，用起来总是没那么舒服，尤其是在换了电脑之后，配置环境比较麻烦，npm install也比较臃肿，于是决定采用hugo。\nhugo是一个使用go语言开发的博客框架，由于是go编写的，所以渲染速度总的来说比hexo快不少，而且安装起来也很简单，也有不少美观的主题，方便部署到各个平台。\n环境配置 系统环境：macOS arm64 (M1 Silicon) Go Version: go1.16beta1 darwin/arm64 homebrew版本：3.0.5\n我是用的为arm平台的golang，没有测试过用intel平台的go版本进行配置\n安装hugo 1 brew install hugo 创建一个新网站 1 hugo new site blog 添加一个主题 1 2 git init // 初始化git git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack //主题下载 添加篇文章 我的主题文章保存在了content文件夹中的post目录\n1 hugo new /post/first.md 本地进行渲染预览 1 hugo server -D 之后可以通过打开localhost:1313来进行预览\n部署到GitHub仓库 1 2 3 4 5 6 7 hugo -D cd public git init git add . git commit -m \u0026#34;first commit\u0026#34; git remote add origin https://github.com/yourname/yourname.github.io git push origin master ","date":"2021-03-13T23:28:31+08:00","permalink":"https://blog.ipandai.club/p/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%AE%B0%E5%BD%95/","title":"博客迁移记录"},{"content":"Luogu3964\nDescription 草原上住着一群小松鼠，每个小松鼠都有一个家。时间长了，大家觉得应该聚一聚。但是草原非常大，松鼠们都很头疼应该在谁家聚会才最合理。 每个小松鼠的家可以用一个点$(x,y)$表示,两个点的距离定义为点 $(x,y)$ 和它周围的8个点 $(x-1,y)，(x+1,y),(x,y-1)，(x,y+1)$ $(x−1,y+1),(x-1,y-1),(x+1,y+1),(x+1,y-1)$距离为1。输出一个整数，表示松鼠为了聚会走的路程和最小是多少。\nSolution 观察题目发现，松鼠家之间的距离为切比雪夫距离，可以通过转换成曼哈顿距离求解，即问题转换为给出平面中的N个点，求一个点到其他所有点的曼哈顿距离之和最小是多少。 如果选定的点为第j个 答案即为$\\sum_{i=1}^{N}dis(i,j)$,dis表示两个点的曼哈顿距离 将两个坐标拆开计算，可以得到 $ans_x = \\sum_{i=1}^Ndis(j,i)$ $dis(1,j)+dis(2,j)+dis(3,j) +\u0026hellip;+dis(n,j)$ 将横坐标按照升序排序 $(x_j-x_1)+(x_j-x_2)+(x_j-x_3)+\u0026hellip;+(x_j-x_{j-1})+(x_{j+1}-x_j)+\u0026hellip;+(x_n-x_j)$\n$\\sum_{i=1}^{j-1}(x_j-x_i)+\\sum_{i=j+1}^{N}(x_i-x_j)$\n$(j-1)*x_j-\\sum_{i=1}^{j-1}x_i + \\sum_{i=j+1}^Nx_i-(N-j)*x_j$\n$\\sum_{i=1}^Nx_i-2\\sum_{i=1}^jx_i-x_j*(n-2*j)$ 于是可以使用前缀和优化，坐标排序后预处理前缀和 在每次进行计算时在有序坐标数组中找到对应的下标 精度问题可以先把坐标都扩大二倍，最后令答案处以2\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;set\u0026gt; #define debug cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl #define ll long long const int MAXN = 1e5 + 10; const int MOD = 1e9 + 7; using namespace std; int N; struct point { ll x, y; } a[MAXN]; ll x[MAXN]; ll prex[MAXN]; ll y[MAXN]; ll prey[MAXN]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin \u0026gt;\u0026gt; N; for (int i = 1; i \u0026lt;= N; i++) { int xx, yy; cin \u0026gt;\u0026gt; xx \u0026gt;\u0026gt; yy; x[i] = a[i].x = (xx + yy); y[i] = a[i].y = (xx - yy); } sort(x+1, x+N+1); sort(y+1, y+N+1); for (int i = 1; i \u0026lt;= N; i++) { prex[i] = prex[i-1] + x[i]; prey[i] = prey[i-1] + y[i]; } ll ans = __LONG_LONG_MAX__; for (int i = 1; i \u0026lt;= N; i++) { ll temp; int lx = lower_bound(x+1,x+N+1,a[i].x) - x; int ly = lower_bound(y+1,y+1+N,a[i].y) - y; temp = (prex[N]-2*prex[lx]-a[i].x*(N-2*lx)) +(prey[N]-2*prey[ly]-a[i].y*(N-2*ly)); // cout \u0026lt;\u0026lt; \u0026#34; list = \u0026#34;\u0026lt;\u0026lt; a[i].x \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; a[i].y \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; temp \u0026lt;\u0026lt; endl; ans = min(ans, temp); } cout \u0026lt;\u0026lt; (ans/2); return 0; } ","date":"2020-10-11T19:45:39Z","permalink":"https://blog.ipandai.club/p/luogu3964-%E6%9D%BE%E9%BC%A0%E8%81%9A%E4%BC%9A/","title":"Luogu3964-松鼠聚会"},{"content":"51nod3143\nDescription n位战士即将奔赴战场，他们每个人都有一个攻击值ai和一个防御值bi，现在你想设计一种装备给这n位战士，如果这件装备的攻击值为A，防御值为B，那么对于第i位战士这件装备的不匹配度为$max(|A−a_i|,|B−b_i|)$ A，B都是正整数，要让所有战士的不匹配度之和最小，求出最小的不匹配度之和$2\\le N \\le 100000$\nSolution 题意中很明显是切比雪夫距离，可以将其转换为曼哈顿距离 对于点$(x,y)$,转换为$(\\frac{x+y}{2},\\frac{x-y}{2})$ 然后可以求出转换后横坐标和纵坐标的中位数，再以这个中位数为基准，将四周3*3的范围内的点都进行计算，去最小值。 由于涉及除法，可能会发生精度丢失，可以将所有坐标都扩大二倍，最后让答案除以2 同时要注意，这里的A，B都是整数，也就是说我们进行计算的点必须也是整数点，可以通过奇偶关系来判断。答案只用A，B为整数点转换过来的点进行计算。\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;set\u0026gt; #define debug cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl #define ll long long const int MAXN = 1e5 + 10; const int MOD = 1e9 + 7; using namespace std; struct point { ll a, b; } arr[MAXN]; int dx[] = {0, 1, -1, 0, 0, 1, 1, -1, -1}; int dy[] = {0, 0, 0, 1, -1, 1, -1, 1, -1}; ll x[MAXN]; ll y[MAXN]; int main() { ios::sync_with_stdio(false); cin.tie(0); int N; cin \u0026gt;\u0026gt; N; int xx, yy; for (int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; xx \u0026gt;\u0026gt; yy; x[i] = arr[i].a = (xx + yy); y[i] = arr[i].b = (xx - yy); } sort(x+1,x+N+1); sort(y+1,y+N+1); int A, B; ll ans = __LONG_LONG_MAX__; if (N\u0026amp;1) { A = x[N/2+1]; B = y[N/2+1]; } else { A = x[N/2+1]; B = y[N/2+1]; } ll ans2 = 0; for (int i = 0; i \u0026lt;= 8; i++) { int tx = A + dx[i]; int ty = B + dy[i]; if ((tx-ty)%2==1 || ((tx+ty))%2==1) continue; ll temp = 0; for (int j = 1; j \u0026lt;= N; j++) { temp += abs(arr[j].a-tx) + abs(arr[j].b-ty); } ans = min(ans, temp); } cout \u0026lt;\u0026lt; ans/2; return 0; } ","date":"2020-10-11T19:45:25Z","permalink":"https://blog.ipandai.club/p/51nod3143-%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB%E4%B8%8E%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB/","title":"51nod3143-切比雪夫距离与曼哈顿距离"},{"content":"Description P2709 小B 有一个长为n的整数序列$a$，值域为$[1,k]$。 他一共有m个询问，每个询问给定一个区间$[l,r]$ 求：$\\sum_{i=1}^k c_i^2$ 其中 $c_i$ 表示数字 $i$ 在$[l,r]$ 中的出现次数。 小B请你帮助他回答询问。\nSolution 莫队算法板子题 mark\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;set\u0026gt; #define mem(a,b) memset(a,b,sizeof(a)) #define debug cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl #define ll long long const int MAXN = 5e4 + 10; const int MOD = 1e9 + 7; using namespace std; struct Q{ int l, r, k; } q[MAXN]; int N, M, K; int pos[MAXN], a[MAXN], cnt[MAXN]; ll ans[MAXN]; ll res; inline void Add(int n) { cnt[a[n]]++; res += 2ll*cnt[a[n]] - 1; } inline void Sub(int n) { cnt[a[n]]--; res -= 2ll*cnt[a[n]] + 1; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M \u0026gt;\u0026gt; K; int siz = sqrt(N); for (int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; a[i]; pos[i] = i/siz; } for (int i = 1; i \u0026lt;= M; i++) { cin \u0026gt;\u0026gt; q[i].l \u0026gt;\u0026gt; q[i].r; q[i].k = i; } sort(q+1,q+M+1,[](Q x, Q y){ return pos[x.l] == pos[y.l] ? x.r \u0026lt; y.r : pos[x.l] \u0026lt; pos[y.l]; }); int l = 1, r = 0; for (int i = 1; i \u0026lt;= M; i++) { while (q[i].l \u0026lt; l) Add(--l); while (q[i].r \u0026gt; r) Add(++r); while (q[i].l \u0026gt; l) Sub(l++); while (q[i].r \u0026lt; r) Sub(r--); ans[q[i].k] = res; } for (int i = 1; i \u0026lt;= M; i++) { cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; endl; } return 0; } ","date":"2020-10-07T22:04:49Z","permalink":"https://blog.ipandai.club/p/%E8%8E%AB%E9%98%9F-%E5%B0%8Fb%E7%9A%84%E8%AF%A2%E9%97%AE%E6%B4%9B%E8%B0%B7p2709/","title":"莫队-小B的询问洛谷P2709"},{"content":"Description 兔八哥躲藏在树林旁边的果园里。果园有M × N棵树，组成一个M行N列的矩阵，水平或垂直相邻的两棵树的距离为1。兔八哥在一棵果树下。 猎人背着猎枪走进了果园，他爬上一棵果树，准备杀死兔八哥。 如果猎人与兔八哥之间没有其它的果树，猎人就可以看到兔八哥。 现己知猎人和兔八哥的位置，编写程序判断兔子所在的位置是否安全. 输入：　第一行为n，表示有n(n ≤ 100,000)组数据，每组数据的第一行为两个正整数ax和ay，表示猎人的位置，第二行为两个正整数bx和by，表示兔八哥的位置(1 ≤ ax, ay, bx, by ≤ 100,000,000)。 输出： 共有n行，每行为“yes”或“no”表示兔八哥的位置是否安全。\nSolution 容易想到，兔八哥和猎人只要连线上无整数点即可，可以转化成$|a_x - b_x| 和 |a_y - b_y|$互质，即$gcd(|a_x - b_x|,|a_y - b_y|)=1$\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include\u0026lt;bits/stdc++.h\u0026gt; #define mem(a,b) memset(a,b,sizeof(a)) typedef long long ll; typedef unsigned long long ull; using namespace std; inline int gcd(int a, int b) { return b == 0 ? a : gcd(b,a%b); } int main() { //freopen(\u0026#34;test.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); ios::sync_with_stdio(false); cin.tie(0); int N; cin \u0026gt;\u0026gt; N; while (N--) { int ax, ay, bx, by; cin \u0026gt;\u0026gt; ax \u0026gt;\u0026gt; ay; cin \u0026gt;\u0026gt; bx \u0026gt;\u0026gt; by; int xx = abs(ax - bx); int yy = abs(ay - by); if (gcd(xx,yy) != 1) { cout \u0026lt;\u0026lt; \u0026#34;yes\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;no\u0026#34; \u0026lt;\u0026lt; endl; } } return 0; } ","date":"2020-10-07T22:04:23Z","permalink":"https://blog.ipandai.club/p/gcd-%E5%85%94%E5%85%AB%E5%93%A5%E4%B8%8E%E7%8C%8E%E4%BA%BA/","title":"GCD-兔八哥与猎人"},{"content":"Description HDU 2566 假设一堆由1分、2分、5分组成的n个硬币总面值为m分，求一共有多少种可能的组合方式（某种面值的硬币可以数量可以为0）。\nSolution 坑题，没给数据范围，只能瞎猜，一发搜索挂掉发现无法去重，但是考虑到该问题满足从1开始分配并无后效性，可以直接递推（类似背包），三种物品可选任意次\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include\u0026lt;bits/stdc++.h\u0026gt; #define mem(a,b) memset(a,b,sizeof(a)) typedef long long ll; typedef unsigned long long ull; using namespace std; int main() { //freopen(\u0026#34;test.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); ios::sync_with_stdio(false); int N, M; int ans;\tint dp[2000][2000]; int n[] = {1,2,5}; cin.tie(0); int T; cin \u0026gt;\u0026gt; T; while (T--) { cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; mem(dp,0); dp[0][0] = 1; for (int i = 0; i \u0026lt; 3; ++i) { for (int j = 1; j \u0026lt;= N; ++j) { for (int k = n[i]; k \u0026lt;= M; ++k) { dp[j][k] += dp[j-1][k-n[i]]; } } } cout \u0026lt;\u0026lt; dp[N][M] \u0026lt;\u0026lt; endl; } return 0; } ","date":"2020-10-07T22:04:23Z","permalink":"https://blog.ipandai.club/p/%E7%BB%9F%E8%AE%A1%E7%A1%AC%E5%B8%81-%E9%80%92%E6%8E%A8/dp/","title":"统计硬币-递推/DP"},{"content":"中缀表达式求值 对于表达式求值，我们通常用栈来操作。 常用的做法是先转换为后缀表达式，再利用栈来求值。 步骤如下：\n开一个栈一个储存运算符，再开一个结构存后缀表达式，可以选择string数组 每遇到一个数字，将其加入到后缀表达式种 遇到左括号，加入到符号栈种 遇到右括号，不断将栈顶元素添加到后缀表达式中，直到遇到左括号，然后弹出左括号 遇到普通运算符，只要栈顶符号的优先级不低于新符号，就不断取出栈顶元素存到后缀表达式，然后将新符号入栈，优先级顺序为乘除\u0026gt;加减\u0026gt;左括号 依次取出符号栈中剩余元素，加入到后缀表达式中 将得到的后缀表达式求值 Note 代码在取栈顶元素时容易出错，需要注意对栈为空时的判断\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;set\u0026gt; #define mem(a,b) memset(a,b,sizeof(a)) #define debug cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl #define ll long long const int MAXN = 1e4 + 10; const int MOD = 1e9 + 7; using namespace std; stack\u0026lt;int\u0026gt; stnumber; stack\u0026lt;char\u0026gt; stsign; stack\u0026lt;int\u0026gt; ans; struct node { string s=\u0026#34;\u0026#34;; } a[MAXN]; int oder(char c) { if (c == \u0026#39;+\u0026#39; || c == \u0026#39;-\u0026#39;) return 1; else if (c == \u0026#39;*\u0026#39; || c == \u0026#39;/\u0026#39;) return 2; return 0; } int toInt(string ss) { int res = 0; for (int i = 0; i \u0026lt; ss.length(); i++) { res = res*10 + ss[i] - \u0026#39;0\u0026#39;; } return res; } int calc(int aa, int bb, char op) { switch (op) { case \u0026#39;+\u0026#39;: return aa + bb; break; case \u0026#39;/\u0026#39;: return bb / aa; break; case \u0026#39;*\u0026#39;: return aa*bb; break; case \u0026#39;-\u0026#39;: return bb - aa; break; default: break; } } bool isnum(char si) { if (si \u0026lt;= \u0026#39;9\u0026#39; \u0026amp;\u0026amp; si \u0026gt;= \u0026#39;0\u0026#39;) return true; return false; } int cur = 0; int main() { ios::sync_with_stdio(false); cin.tie(0); int N; cin \u0026gt;\u0026gt; N; string s; cin \u0026gt;\u0026gt; s; N = s.length(); int len = 0; for (int i = 0; i \u0026lt; N; i += len) { len = 0; if (isnum(s[i])) { string t = \u0026#34;\u0026#34;; for (int j = i; j \u0026lt; N; j++) { if (isnum(s[j])) { t += s[j]; len++; } else { break; } } a[++cur].s = t; } else { if (s[i] == \u0026#39;(\u0026#39;) stsign.push(s[i]); else if (s[i] == \u0026#39;)\u0026#39;) { while (stsign.top() != \u0026#39;(\u0026#39;) { char op = stsign.top(); stsign.pop(); a[++cur].s += op; } stsign.pop(); } else { char op = s[i]; if (!stsign.empty()) while (!stsign.empty() \u0026amp;\u0026amp; oder(stsign.top()) \u0026gt;= oder(op)) { a[++cur].s += stsign.top(); stsign.pop(); //if (stsign.empty()) break; } stsign.push(op); } len = 1; } } while (!stsign.empty()) { char op = stsign.top(); stsign.pop(); a[++cur].s += op; } // for (int i = 1; i \u0026lt;= cur; i++) { // cout \u0026lt;\u0026lt; a[i].s \u0026lt;\u0026lt; endl; // } for (int i = 1; i \u0026lt;= cur; i++) { int temp; if (isnum(a[i].s[0])) { temp = toInt(a[i].s); ans.push(temp); } else { int aa = ans.top(); ans.pop(); int bb = ans.top(); ans.pop(); ans.push(calc(aa, bb, a[i].s[0])); } } cout \u0026lt;\u0026lt; ans.top(); return 0; } ","date":"2020-10-07T22:03:17Z","permalink":"https://blog.ipandai.club/p/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/","title":"中缀表达式求值"},{"content":"Description 给出整数$n,k$,计算$G(n,k)=\\sum\\limits_{i=1}^n=k \\ mod \\ i$,$1\u0026lt;=n,k\u0026lt;=1e9$\nSolution 将k mod i展开可以得到$k - i*\\lfloor \\frac{k}{i} \\rfloor$ 将求和式子展开可以得到$ \\sum\\limits_{i=1}^n = nk-\\sum\\limits_{i=1}^n i * \\lfloor\\frac{k}{i} \\rfloor $ 利用整除分块，可以发现，对于相同的$\\lfloor\\frac{k}{i} \\rfloor$，即每个区间$l 到 r$，每次只需要再对i求和即可 即每次计算$(r-l+1)\\lfloor \\frac{k}{i} \\rfloor * (l+r)/2$\nNote 在分块的时候误写为r=N/(N/i)导致调试耽误大量时间，而且交了四发才发现\n1 2 3 4 5 6 7 for (ll l = 1, r; l \u0026lt;= N; l = r + 1) { if (l \u0026gt; K) { break; } r = min(N, K/(K/l)); ans -= (r - l + 1)*(K/l)*(l + r)/2; } Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 //https://www.luogu.com.cn/problem/P2261 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;set\u0026gt; #define mem(a,b) memset(a,b,sizeof(a)) #define debug cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl #define ll long long const int MAXN = 1e2 + 10; const int MOD = 1e9 + 7; using namespace std; ll ans = 0; void solve(ll N, ll K) { ans = N*K; for (ll l = 1, r; l \u0026lt;= N; l = r + 1) { if (l \u0026gt; K) { break; } r = min(N, K/(K/l)); ans -= (r - l + 1)*(K/l)*(l + r)/2; } cout \u0026lt;\u0026lt; ans; } int main() { ios::sync_with_stdio(false); cin.tie(0); ll N, K; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; K; solve(N, K); return 0; } ","date":"2020-10-07T21:47:20Z","permalink":"https://blog.ipandai.club/p/%E4%BD%99%E6%95%B0%E6%B1%82%E5%92%8C-%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/","title":"余数求和-整除分块"},{"content":"Description 求平面上n个点构成的平行四边形个数。 输入 一行一个数n。 接下来n行，每行两个数x,y，表示这个点的坐标为(x,y)。 保证任意两点不重合，任意三点不共线。 输出 一行一个整数表示平行四边形个数。\nSolution 按照平行四边形的性质，两组顶点的中点重合，可以统计出每组顶点的中点，再统计每个顶点的个数，排列组合一下\nNote 第一发对于顶点的统计出锅了，排序条件写错，提交都要检查排序\n","date":"2020-05-13T22:05:25Z","permalink":"https://blog.ipandai.club/p/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95-%E5%B9%B3%E8%A1%8C%E5%9B%9B%E8%BE%B9%E5%BD%A2/","title":"计算几何-平行四边形"},{"content":"Description 请输出$Fib(n) mod 10000$ $n \\leq 1000000000$\nSolution 由于$n$的范围在$1e9$直接递推铁TLE，考虑矩阵快速幂 Fibonacci数列有如下性质 通过多次迭代 算是个板子题吧，记得在WUST新生赛做过一道想矩阵快速幂的题，然而正解是找规律QAQ，在此贴个板子。\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;string\u0026gt; typedef long long LL; const int MOD = 1e4; using namespace std; struct Matrix{ LL m[2][2]; void print(){ for (int i = 0; i \u0026lt; 2; i++) { for (int j = 0; j \u0026lt; 2; j++) cout \u0026lt;\u0026lt; m[i][j] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; endl;\t} } } base, ans; Matrix times(Matrix a, Matrix b) { Matrix ans; ans.m[0][1] = ans.m[0][0] = ans.m[1][0] = ans.m[1][1] = 0; for (int i = 0; i \u0026lt; 2; i++) { for (int j = 0; j \u0026lt; 2; j++) { for (int k = 0; k \u0026lt; 2; k++) ans.m[i][j] = (ans.m[i][j] + a.m[i][k]*b.m[k][j])%MOD; } } return ans; } void Matrixpow(LL x) { base.m[0][0] = base.m[1][0] = base.m[0][1] = 1; base.m[1][1] = 0; ans.m[0][0] = ans.m[1][1] = 1; ans.m[0][1] = ans.m[1][0] = 0; while (x) { if (x\u0026amp;1){ ans = times(ans, base); } x \u0026gt;\u0026gt;= 1; base = times(base, base); } } LL N; int main(){ while (cin \u0026gt;\u0026gt; N) { if (N == -1) break; if (N == 0) { cout \u0026lt;\u0026lt; \u0026#34;0\u0026#34; \u0026lt;\u0026lt; endl; continue; } Matrixpow(N); cout \u0026lt;\u0026lt; ans.m[0][1] % MOD \u0026lt;\u0026lt; endl; }\treturn 0; } ","date":"2019-12-13T18:58:24Z","permalink":"https://blog.ipandai.club/p/fibonacci-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/","title":"Fibonacci 矩阵快速幂"},{"content":"Description 有$n$个木棍，长度为$1,2,3\u0026hellip;n$，现在要从中删掉一些木棍，使得剩下的木棍不能构成三角形，使删掉木棍的数量最少。T组数组，$T \\leq 20$ $n \\leq 20$\nSolution 由于数据范围很小，可以直接暴力求解，依次选取两个数$a,b(a\u0026lt;b)$相加，要知道不能有任何一个数小于这个值，直接删掉$(a,a+b)$范围中的数即可 如果$n$的范围是$1e9$呢？ 通过找规律发现我们剩下的数是这样的 $1,2,3,5,8,13,21\u0026hellip;$ 这是Fibonacci数列!!!! 所以我们只需要找到$\\leq n$的Fibonacci数有几个，减去就是答案 可以直接lower_bound注意处理极限数据！！！即$n==1||n==2$的情况 也可手写二分，但是二分貌似常数有点大，又考虑到第$88$个Fibonacci数就爆掉$1e9$了，所以直接便利也完全没问题\nCode 暴力版本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; bool vis[23]; int main() { int T; cin \u0026gt;\u0026gt; T; for (int i = 1; i \u0026lt;= T; i++) { int N, ans = 0; cin \u0026gt;\u0026gt; N; memset(vis, false, sizeof(vis)); for (int j = 1; j \u0026lt;= N - 1; j++) if (!vis[j]) { for (int k = j + 1; k \u0026lt;= N; k++) { if (!vis[k]) { for (int l = k + 1; l \u0026lt;= j + k - 1; l++) if (!vis[l] \u0026amp;\u0026amp; l \u0026lt;= N) vis[l] = true, ans++; break; } } } printf(\u0026#34;Case #%d: %d\\n\u0026#34;, i, ans); } return 0; } 二分+Fib 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;queue\u0026gt; typedef unsigned long long uLL; typedef long long LL; const LL MOD = 1e18; using namespace std; LL f[100]; int main() { f[0] = 1; f[1] = 1; for (int i = 2; i \u0026lt;= 80; i++) f[i] = f[i - 1] + f[i - 2]; int T; cin \u0026gt;\u0026gt; T; for (int i = 1; i \u0026lt;= T; i++){ LL N; cin \u0026gt;\u0026gt; N; if (N == 1 || N == 2) { printf(\u0026#34;Case #%d: 0\\n\u0026#34;, i); continue; } int l = 1, r = 80; /*手写二分查找 while (l \u0026lt;= r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (f[mid] \u0026lt;= N) l = mid + 1; else r = mid - 1; } int pos = l; */ int pos = lower_bound(f, f + 80, N) - f; if (f[pos] != N) pos--; printf(\u0026#34;Case #%d: %d\\n\u0026#34;, i, N - pos); } return 0; } ","date":"2019-12-13T18:58:14Z","permalink":"https://blog.ipandai.club/p/triangle-fibonacci-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","title":"Triangle Fibonacci+二分查找"},{"content":"Description 在杨辉三角中，从第一行第一列$(0,0)$开始，每次可选择向正下方走或向右下方走，走到第$n$行时不能超过第$n$行第$k$个元素，询问所经过路径的值的和的最小值$mod(p)$，一共有T组询问，$T \\leq 100000$， $0 \\leq k \\leq n \\leq 1e9$, 保证$p$是质数， 其中$p \u0026lt; 1e4$\nSolution 名字虽然是DP，但是可以找出最优方案。 优先考虑$k \\leq \\frac{n}{2}$的情况，先向下走$n-k$步到达$(n-k-1,0)$ 再一路沿着右下方走，直到到达底部，即有$C_{n-k}^{0}+C_{n-k+1}^{1}+C_{n-k+2}^{2}+\u0026hellip;+C_{n}^{k}=C_{n+1}^{k}$ 通过变换$C_{n-k}^{0} = C_{n-k+1}{0}$ 再通过公式$C_{n}^{m}=C_{n-1}^{m}+C_{n-1}^{m-1}$可将上述公式合并 得到$C_{n+1}^{k}$ 所以答案为$C_{n+1}^{k}+n-k$ 当$k \u0026gt; \\frac{n}{2}$时，根据对称性，令$k=n-k$即可转化成上一种情况 又发现题目涉及组合数取模，所以要用到费马小定理\n费马小定理: 假如$a$是一个整数，$p$是一个质数，且$gcd(a,p)=1$，即$a,p$互质，那么有$a^{p−1}≡1(modp)$\n已知$a^{p-1}≡1$，可以得到$a \\cdot a^{p-2}≡1$，我们称$a$和$a^{p-2}$为在$mod(p)$意义下的乘法逆元 然而这只解决了除法取模的问题，注意到$n$的范围在$1e9$直接计算组合数又是铁套老鹅(TLE)，于是借助Lucas定理\n对于质数$p$,有$C_n^m\\ mod \\ p = C_{\\lfloor \\frac{n}{p} \\rfloor}^{\\lfloor \\frac{m}{p} \\rfloor} \\cdot C_{n\\ mod\\ p}^{m\\ mod\\ p} \\ mod \\ p$\n可知$n\\ mod\\ p$和$m\\ mod\\ p$一定是小于$p$的数，可直接求解，其余部分继续用Lucas定理求解，当$m=0$的时候返回$1$\n1 2 3 4 long long Lucas(long long n, long long m, long long p) { if (m == 0) return 1; return (C(n % p, m % p, p) * Lucas(n / p, m / p, p)) % p; } 有了这些工具之后就可以预处理阶乘和逆元了\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;queue\u0026gt; typedef long long LL; const int MAXN = 10000; using namespace std; LL N,K,MOD; bool isnotp[MAXN + 10]; LL pri[1500], num = 0;//素数表 int f[1300][MAXN];//阶乘 int inv[1300][MAXN];//逆元 inline void Euler() { isnotp[1] = true; memset(isnotp, false, sizeof(isnotp)); for (int i = 2; i \u0026lt;= MAXN; i++) { if (!isnotp[i]) pri[++num] = i; for (int j = 1; j \u0026lt;= num \u0026amp;\u0026amp; i*pri[j] \u0026lt;= MAXN; j++) { isnotp[i*pri[j]] = true; if (i%pri[j]==0) break; } } } LL fffpow(LL x, LL y, LL pp) { LL sum = 1; LL a = x; while (y) { if (y\u0026amp;1) { sum = (sum*a) % pp; } a = (a*a)%pp; y\u0026gt;\u0026gt;=1; } return (sum)%pp; } int cnt = 0; inline LL Lucas(int N,int M,int o) { LL a,b,ans=1; while(N \u0026amp;\u0026amp; M) { a = N%pri[o]; b = M%pri[o]; if(a \u0026lt; b)return 0; ans = ans*f[o][a]%pri[o]*inv[o][b]%pri[o]*inv[o][a-b]%pri[o]; N /= pri[o]; M /= pri[o]; } return ans; } int main() {\tEuler(); for(int i = 1; i \u0026lt;= num; i++) { f[i][0] = f[i][1] = 1; inv[i][0] = inv[i][1] = 1; for(int j = 2;j \u0026lt; pri[i]; j++) { f[i][j] = f[i][j-1]*j % pri[i]; inv[i][j] = fffpow(f[i][j], pri[i]-2, pri[i]); } } while (cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; K \u0026gt;\u0026gt; MOD) { LL ans; if(K \u0026gt; N/2) K = N - K; int l = 1, r = 1229; while(l \u0026lt;= r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if(MOD \u0026lt; pri[mid]) r = mid - 1; else l = mid + 1; } ans = (Lucas(N + 1, K, l - 1) + N - K)%MOD; printf(\u0026#34;Case #%d: %lld\\n\u0026#34;, ++cnt, ans);\t} return 0; } ","date":"2019-12-13T18:57:13Z","permalink":"https://blog.ipandai.club/p/dp-%E7%B4%A0%E6%95%B0%E7%AD%9B-lucas%E5%AE%9A%E7%90%86-%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/","title":"DP? 素数筛+Lucas定理+费马小定理"},{"content":"Description 小兔的叔叔从外面旅游回来给她带来了一个礼物，小兔高兴地跑回自己的房间，拆开一看是一个棋盘，小兔有所失望。不过没过几天发现了棋盘的好玩之处。从起点$(0，0)$走到终点$(n,n)$的最短路径数是$C_{2n}^{n}$,现在小兔又想如果不穿越对角线(但可接触对角线上的格点)，这样的路径数有多少?小兔想了很长时间都没想出来，现在想请你帮助小兔解决这个问题，对于你来说应该不难吧! $n \\leq 35$\nSolution 由于规定不能超过对角线，可用分治的思想，只考虑沿对角线分隔开的三角形的情况，对于一个三角形中，求从$(0，0)$走到终点$(n,n)$的最短路径，观察发现无论怎么走，设到达某一点时向上走了$i$步，向右走了$j$步，都有$i \\leq j$这也能通过线性规划相关知识证明。不难发现只是一个类括号匹配问题，可用$Catalan$数求解，计算$C(n)$后即是在一个三角形中的解，答案是$2C(n)$\n$C(n) = \\sum_{i=0}^{n-1} C(i) \\cdot C(n-i-1)$ 通项公式$C(n)=\\frac{C_{2n}^{n}}{n+1}$\n预处理$C(n)$即可\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;queue\u0026gt; typedef long long LL; using namespace std; LL C[100]; int main() { C[0] = 1; C[1] = 1; for (int i = 2; i \u0026lt;= 80; i++) { LL t = 0; for (int j = 0; j \u0026lt; i; j++) t += C[j]*C[i - j - 1]; C[i] = t; } LL N; int cnt = 1; while (cin \u0026gt;\u0026gt; N) { if (N == -1) break; cout \u0026lt;\u0026lt; cnt++ \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; N \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; C[N]*2 \u0026lt;\u0026lt; endl; } return 0; } ","date":"2019-12-13T18:56:57Z","permalink":"https://blog.ipandai.club/p/%E5%B0%8F%E5%85%94%E7%9A%84%E6%A3%8B%E7%9B%98-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/","title":"小兔的棋盘 组合数学"},{"content":"Day -N 快新生赛了啊啊啊啊，半个多月没碰算法题了，一直在搞ToKen的前端任务，还在搞服务器的事，感觉要凉凉。\nDay 1 嗯，就只有Day1. 早上起的很晚，八点半才从床上爬起来，起来之后第一件事是看我的USB-HUB发货没有!!!都好几天了，一个USB接口坏了，机械键盘没法用啊，想去买usb转type-c线的想了想还是再等等吧ε=ε=ε=┏(゜ロ゜;)┛ 下楼去堕落一条街吃了早饭。 中午吃完饭回来买了杯奶茶丫丫精，发现喝完了有点撑得慌~~~~然后就等12.30了。 比赛开始赶紧去找签到题。\nA题 emmmmm像是的数学题，递推，一看数据范围感觉不可做。\nB题 这题面稍微有点问题啊。室友就以为是按顺序组合起来的，虽然感觉仔细想想也想出来是求和的，直接DFS走了？？？不存在的，这里有个老年人sum没重置，debug一万年啊，最后才发现sum每次没有赋初值ε=ε=ε=┏(゜ロ゜;)┛\nC题 签到题\nD题 一开始没看清题意，直接while求Σa*0.1一直到不影响答案为止，算到了1e-5，第一发不知道咋WA了，两发才过。\nE题 博弈论，不可做\nF题 并查集。但是！！老年人在这里又拉胯了！！！要输出没有感染的人，我输出了一万年感染的人，交了五六发？？？\nJ题 模拟题。\nＨ题 贪心交了一发没过，分类讨论情况可能会很多，没敢用搜索。\nI题 博弈论sg==就会三种博弈的蒟蒻枯了。听WHU的巨巨说记忆化搜索也能过。\nJ题 计算几何。我认输。在线处理当成直线做的，没考虑到路程是个线段，debug一万年，最后还有半个小时封板的时候放弃了QAQ\nK题 模拟题，我充分意识到半个小时可能写不出来了，想去debug一下J题吧\n后记 最后五题榜19。校内 榜二。WHU和HUST的巨巨们霸榜啊orz。\n进队了orz\n其实感觉中间耽误了好多时间啊，低级错误，不然可能会在开出两题，just可能。orz\nJ题一大遗憾。也是给自己个教训吧。\n至此 成为WHUTer之后，又成为了ToKener，又成为了ACMer。 专心训练和学习啦。 逃ε=ε=ε=┏(゜ロ゜;)┛：蒟蒻 蒟蒻 蒟蒻\n","date":"2019-11-16T21:48:04Z","permalink":"https://blog.ipandai.club/p/whut%E6%96%B0%E7%94%9F%E8%B5%9B%E6%B8%B8%E8%AE%B0/","title":"WHUT新生赛\"游记\""}]