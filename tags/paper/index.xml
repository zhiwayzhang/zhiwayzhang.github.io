<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Paper on Coding_Panda&#39;s Blog</title>
        <link>https://blog.ipandai.club/tags/paper/</link>
        <description>Recent content in Paper on Coding_Panda&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Sat, 29 Oct 2022 16:48:32 +0800</lastBuildDate><atom:link href="https://blog.ipandai.club/tags/paper/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>[OSDI&#39;21] Modernizing File System through In-Storage Indexing</title>
        <link>https://blog.ipandai.club/p/osdi21-modernizing-file-system-through-in-storage-indexing/</link>
        <pubDate>Sat, 29 Oct 2022 16:48:32 +0800</pubDate>
        
        <guid>https://blog.ipandai.club/p/osdi21-modernizing-file-system-through-in-storage-indexing/</guid>
        <description>&lt;h1 id=&#34;questions&#34;&gt;Questions&lt;/h1&gt;
&lt;p&gt;核心思想部分需要再思考和梳理下，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为什么采用 KV SSD 替代传统 block SSD 能够解决上述问题？&lt;/li&gt;
&lt;li&gt;其中，利用了 KV SSD 的什么特性？&lt;/li&gt;
&lt;li&gt;对文件系统哪些地方做了什么以优化？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;论文试图解决的问题：&lt;/p&gt;
&lt;p&gt;随着存储设备的不断发展，存储设备的性能越来越高，但当前操作系统内核的文件系统在一些操作上并不能够充分利用如今存储设备的性能。&lt;/p&gt;
&lt;p&gt;文件系统在执行数据写入时，需要执行大量操作维护元数据、进行硬盘的空间管理、维护文件系统的一致性，工作量大。&lt;/p&gt;
&lt;p&gt;核心思想：&lt;/p&gt;
&lt;p&gt;使用Key-Value存储接口取代传统的快设备接口。&lt;/p&gt;
&lt;p&gt;具体实现：&lt;/p&gt;
&lt;p&gt;提出Kevin，分为Kevin=KevinFS + KevinSSD&lt;/p&gt;
&lt;p&gt;KevinFS&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;维护文件和目录到KV对象的映射关系&lt;/li&gt;
&lt;li&gt;将POSIX系统调用转译成KV操作指令&lt;/li&gt;
&lt;li&gt;保证KV-SSD的一致性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;KevinSSD&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在存储设备中索引KV对象&lt;/li&gt;
&lt;li&gt;对多个KV对象提供事务操作&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;0x00-intro&#34;&gt;0x00 Intro&lt;/h1&gt;
&lt;p&gt;Kevin避免了大量元数据的维护带来的I/O放大&lt;/p&gt;
&lt;p&gt;不需要日志即可完成崩溃一致性的维护&lt;/p&gt;
&lt;p&gt;可以抵御文件分段后造成的性能下降&lt;/p&gt;
&lt;p&gt;存储的文件块通过LSM进行分部排序和索引&lt;/p&gt;
&lt;h1 id=&#34;0x01-bg--related-work&#34;&gt;0x01 BG &amp;amp;&amp;amp; Related Work&lt;/h1&gt;
&lt;h2 id=&#34;传统块设备&#34;&gt;传统块设备&lt;/h2&gt;
&lt;p&gt;提供块粒度（512B or 4KB）的访问&lt;/p&gt;
&lt;p&gt;HDD通过维护一个间接表来处理坏块&lt;/p&gt;
&lt;p&gt;基于闪存的SSD通过FTL来维护逻辑块到物理地址的映射索引表，以便在异地更新的NAND上模拟可重写介质并且排除坏块。&lt;/p&gt;
&lt;p&gt;现有研究缓解了I/O调度、文件碎片化、日志相关问题，没能消除元数据的修改带来的I/O流量&lt;/p&gt;
&lt;p&gt;DevFS实现了在存储设备内部的文件系统，直接将接口暴露给应用，调用时不用发生Trap，对于元数据的维护都在存储设备端执行，移除了I/O 栈减少了通信接口的开销。缺点是需要大量的DRAM和多核心的CPU、能提供的功能有限，还限制了快照、重复数据删除等文件系统高级功能的实现。&lt;/p&gt;
&lt;p&gt;KV存储可以高效处理元数据和小文件的写入&lt;/p&gt;
&lt;h2 id=&#34;lsm-tree&#34;&gt;LSM-Tree&lt;/h2&gt;
&lt;img src=&#34;https://cdn.ipandai.club/image-20221102145019013.png&#34; alt=&#34;image-20221102145019013&#34; style=&#34;zoom:70%;&#34; /&gt;
&lt;p&gt;LSM Tree有多级，包括$L_1,L_2,&amp;hellip;,L_{h-1},L_{h}$，h是树的高度，对于各级的大小有如下关系，$Size(L_{i+1})&amp;gt;=T*Size(L_i)$&lt;/p&gt;
&lt;p&gt;每层都有按Key排序的唯一KV对象。各层之间的Key范围可能会出现重叠。&lt;/p&gt;
&lt;p&gt;KV对象首先写入DRAM中的Memtable，当Memtable不为空时，缓存的KV对象将刷新到L1中进行持久化，当L1不为空时，KV对象刷新到L2中，依此类推。在刷新过程中会执行压缩操作来对两层之间的KV对象进行合并和排序，在排序后写回磁盘中。&lt;/p&gt;
&lt;p&gt;为了改善压缩操作的I/O开销，可以将所有的value存储在value log中，在LSM tree中只保存value指针，存储&lt;code&gt;&amp;lt;key, value pointer&amp;gt;&lt;/code&gt;形式。对于失效的value要考虑垃圾回收问题。&lt;/p&gt;
&lt;p&gt;在对KV对象进行检索时，可能需要在多级进行查找，当在Li不匹配时，查找Li+1。为了减少多级查找的读取，可以使用布隆过滤器进行优化，当检索到目标KV对象时，LSM tree将会返回相应的value，KV分离存储的情况下，将会额外去读一次value log。&lt;/p&gt;
&lt;h1 id=&#34;0x02-architecture&#34;&gt;0x02 Architecture&lt;/h1&gt;
&lt;p&gt;KEVIN分为两个部分&lt;/p&gt;
&lt;p&gt;KEVINFS：维护文件、目录到KV对象映射的文件系统&lt;/p&gt;
&lt;p&gt;KEVINSSD：索引KV对象到闪存的LSM-tree&lt;/p&gt;
&lt;h2 id=&#34;kv-command&#34;&gt;KV Command&lt;/h2&gt;
&lt;p&gt;支持多种KV指令，同时支持事务&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.ipandai.club/image-20221102154423353.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221102154423353&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;作者将Key限制为256B，value大小没有限制&lt;/p&gt;
&lt;h2 id=&#34;文件和目录的映射&#34;&gt;文件和目录的映射&lt;/h2&gt;
&lt;p&gt;KevinFS只使用三个类型的KV对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$superblock$：保存文件系统的信息，大小128B&lt;/li&gt;
&lt;li&gt;$meta$：保存文件、目录的元数据，大小256B&lt;/li&gt;
&lt;li&gt;$data$：保存文件数据，unlimited，不超过文件大小&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于目录的遍历通过ITERATE&lt;/p&gt;
&lt;p&gt;Key的命名遵循如下规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;meta对象的key组成：
&lt;ul&gt;
&lt;li&gt;前缀&lt;code&gt;m:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;父目录的inode number&lt;/li&gt;
&lt;li&gt;分隔符&lt;code&gt;:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;文件/目录名&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;data对象的key组成：
&lt;ul&gt;
&lt;li&gt;前缀&lt;code&gt;d:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;文件的inode number&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Key命名规范参考了其他论文（Kai Ren and Garth Gibson. TABLEFS: Enhancing Metadata Efficiency in the Local File System. In Proceedings of the USENIX Annual Technical Conference, pages 145–156, 2013.），本篇文章将其扩展到了存储设备层面&lt;/p&gt;
&lt;p&gt;KevinFS没有实现dentry，如果需要访问一个目录内的所有项目，可以通过&lt;code&gt;ITERATE(m:50:, 2)&lt;/code&gt;，来获取两个父目录inode为50（前缀匹配给定的pattern）的子目录/文件的元数据。&lt;/p&gt;
&lt;p&gt;一个优化：为了防止ITERATE消耗太长时间，建议指定cnt&lt;/p&gt;
&lt;p&gt;一个优化：为了高效处理小文件，KevinFS将总体小于4KB的小文件的元数据和数据内容打包，I/O直接操作meta对象GET/SET来进行读写&lt;/p&gt;
&lt;p&gt;@TODO 一个优化：使用全路径索引来取代基于inode的索引，这提高了基于排序算法的KV存储的扫描性能，主要对seek time开销大的HDD优化比较明显&lt;/p&gt;
&lt;h2 id=&#34;kv对象索引&#34;&gt;KV对象索引&lt;/h2&gt;
&lt;p&gt;KevinSSD基本实现了传统SSD 中FTL的所有功能，将KV对象映射到闪存、分配和释放闪存的空间。&lt;/p&gt;
&lt;p&gt;FTL只做坏块管理和磨损均衡等简单工作。&lt;/p&gt;
&lt;p&gt;每个Level维护一个内存表，来记录Flash中的KV对象。表的每个记录都有&lt;code&gt;&amp;lt;start key, end key, pointer&amp;gt;&lt;/code&gt;，其中指针指向保存KV对象的闪存页面的位置，start key和end key是页面中key的范围。key的范围可以在多个Level上重叠。为了快速查找，所有记录都按开始键排序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.ipandai.club/image-20221102165350981.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221102165350981&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;meta和data对象的Key和Value会被分离存储。通过&lt;code&gt;&amp;lt;key, value pointer&amp;gt;&lt;/code&gt;的方式进行存储，会有专门的flash page来分别存储这些信息（meta和data对象使用不同的flash page），key-index pages&lt;/p&gt;
&lt;h3 id=&#34;meta-object&#34;&gt;Meta object&lt;/h3&gt;
&lt;p&gt;在对KV对象进行检索时，可能需要在多级进行查找，当在Li不匹配时，查找Li+1。为了减少多级查找的读取，可以使用布隆过滤器进行优化，当检索到目标KV对象时，LSM tree将会返回相应的value，KV分离存储的情况下，将会额外去读一次value log。&lt;/p&gt;
&lt;p&gt;对目录项的更新只需要修改其元数据即可完成，而不需要修改4KB的块&lt;/p&gt;
&lt;h3 id=&#34;data-object&#34;&gt;Data object&lt;/h3&gt;
&lt;p&gt;为了避免对大数据的小范围更新带来的I/O高负载，KevinSSD将data object分割为4KB大小的子对象，使用单独的后缀来对他们进行表示，后缀从0开始，拼接在原始的data object Key后，因此data object的key最终构成为
$$
d:{inode\ \ \ number}:{subobject \ \ number,start\ with \ 0}
$$
不需要中间表进行索引，只需要通过偏移量即可定位要修改的对象&lt;/p&gt;
&lt;p&gt;Data object同样使用保存指针的方式将映射存储在key-index pages中，key-index pages会对键进行排序，因此属于同一个文件的subobject一般会在同一个flash page中。&lt;/p&gt;
&lt;p&gt;==优化==：在查找指针时，会将一整个闪存页内的数据全部取出，存储在控制器的DRAM中，减轻后续查找可能带来的负载&lt;/p&gt;
&lt;h2 id=&#34;缓解索引负载&#34;&gt;缓解索引负载&lt;/h2&gt;
&lt;p&gt;使用LSM-tree由于多级查找带来额外的I/O，传统FTL的映射都保存在DRAM，因此没有额外开销。作者介绍了三种主要原因和解决方案。&lt;/p&gt;
&lt;h3 id=&#34;压缩操作的开销&#34;&gt;压缩操作的开销&lt;/h3&gt;
&lt;p&gt;同上文介绍的方案，通过分离Value可以显著缓解I/O的数据传输负载，对data进行分片我个人感觉反而会加大压缩操作的合并过程，即使分片后键值都是有序的。&lt;/p&gt;
&lt;h3 id=&#34;层级查找的开销&#34;&gt;层级查找的开销&lt;/h3&gt;
&lt;p&gt;由于LSM-tree的特性，需要逐层进行查找，为了防止大量的顺序查找，作者使用布隆过滤器进行了优化。&lt;/p&gt;
&lt;p&gt;同时还缓存了热点K2V索引数据（与目标索引处在同一个flash page中的）&lt;/p&gt;
&lt;p&gt;为了利用大容量SSD中提供的超大DRAM，作者采用压缩存储K2V索引，并在其中插入没有压缩的K2V索引来作为二分查找的参照物。（快速在缓存中查找？不如继续用布隆过滤器）&lt;/p&gt;
&lt;h3 id=&#34;分散的对象带来的开销&#34;&gt;分散的对象带来的开销&lt;/h3&gt;
&lt;p&gt;LSM-tree允许各层之间的key范围重叠，因此有同一个前缀的目录或者文件可能被分配到不同的Level中，对于获取一个目录中所有目录、文件的操作，需要对多个闪存页进行访问。这个问题作者没有给出一个明确的方案（在压缩合并时隐式解决），但是提供了一个用户工具来主动触发合并，效率较高。&lt;/p&gt;
&lt;p&gt;作者对比了各种方法在随机读、局部读（？）、顺序读情况下对闪存页的读取次数，使用布隆过滤器的时候稳定会有一次读取&lt;/p&gt;
&lt;p&gt;使用了KevinSSD后对于SSD而言，I/O延迟有轻微的增加，整体而言效率提高了&lt;/p&gt;
&lt;h1 id=&#34;0x03-implement-vfs&#34;&gt;0x03 Implement VFS&lt;/h1&gt;
&lt;h2 id=&#34;write&#34;&gt;write&lt;/h2&gt;
&lt;p&gt;所有的写相关系统调用可以通过SET和DELETE来实现。&lt;/p&gt;
&lt;p&gt;例如unlink，只需要两次DELETE指令，移除meta和data object。&lt;/p&gt;
&lt;p&gt;SET时现在Memtable中保存一个KV对象，然后持久化到flash中，若Key已存在则丢弃旧的对象&lt;/p&gt;
&lt;p&gt;DELETE时在树上写入一个4B大小的墓碑&lt;/p&gt;
&lt;p&gt;失效的对象（被SET覆盖）和删除的对象在压缩期间被永久删除&lt;/p&gt;
&lt;h2 id=&#34;read&#34;&gt;read&lt;/h2&gt;
&lt;p&gt;通过GET和ITERATE实现&lt;/p&gt;
&lt;p&gt;如下图所示&lt;/p&gt;
&lt;p&gt;执行open系统调用时，查询meta object获取文件的inode，通过GET命令实现&lt;/p&gt;
&lt;p&gt;执行lookup系统调用时，给定一个完整的路径&lt;code&gt;/home/alice/&lt;/code&gt;，从根目录开始获取多个meta object，最终获取目标文件的inode&lt;/p&gt;
&lt;p&gt;执行read系统调用时，将GET一个data object&lt;/p&gt;
&lt;p&gt;执行readdir系统调用时，使用ITERATE，批量获取一组meta objects来获取inode&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.ipandai.club/image-20221102210344432.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221102210344432&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;相较于Ext4，KevinFS可以更好的防止文件碎片化带来的影响。&lt;/p&gt;
&lt;h1 id=&#34;0x04-crash-consistency&#34;&gt;0x04 Crash Consistency&lt;/h1&gt;
&lt;h2 id=&#34;一致性维护&#34;&gt;一致性维护&lt;/h2&gt;
&lt;p&gt;通过事务即可实现原子化的操作&lt;/p&gt;
&lt;p&gt;在传统的日志结构中，由于事务的大小受日志大小的限制，一个系统调用可能会被划分到多个事务中。KVFS通过强制限制对一个文件的操作驻留在同一个事务中来确保原子性。&lt;/p&gt;
&lt;p&gt;事务的隔离？对==fsync==指令单独创建一个小型事务来提高效率。&lt;/p&gt;
&lt;p&gt;KevinFS基于KV事务的特性来维护一致性，不使用日志系统。&lt;/p&gt;
&lt;h2 id=&#34;kv事务的实现&#34;&gt;KV事务的实现&lt;/h2&gt;
&lt;p&gt;使用了三个数据结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务表$TxTable$：记录事务基本信息&lt;/li&gt;
&lt;li&gt;事务日志$TxLogs$：维护事务对象的K2V索引，存储在DRAM或者闪存中&lt;/li&gt;
&lt;li&gt;恢复日志$TxRecovery$：用于恢复和终止事务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是收到BeginTx指令时，KevinSSD在TxTable中创建一个对象，包含TID，当前事务的状态，与事务相关K2V索引的位置，初始状态为RUNNING（如①）。当后续指令到达后，KevinSSD将KV索引记录在TxLogs，并缓存在Memtable中。&lt;/p&gt;
&lt;p&gt;当收到EndTx指令后，完成事务的提交，标记事务状态为COMMITTED（如②）。将提交的KV索引同步到LSM-tree中&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.ipandai.club/image-20221103102304181.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20221103102304181&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;为了减少在COMMITTED阶段，将TxLogs中的KV索引同步到LSM tree L1中时的负载，对每个事务在DRAM中维护了一个Skiplist，便于快速查找KV对象在TxLogs中的索引，在L1和L2需要进行压缩时再将skiplist中的数据同步到checkpoint，当同步完成后，事务的状态将变为CHECKPOINTED（如③），最终即将对DRAM中的TxTable和TxLogs进行回收。&lt;/p&gt;
&lt;h2 id=&#34;recovery&#34;&gt;Recovery&lt;/h2&gt;
&lt;p&gt;若发生掉电，KVSSD会利用电容将KV索引持久化到闪存中的TxLogs，TxTable更新内部的指针，在TxRecovery中进行记录。在系统重启时，KVSSD会扫描Tx Recovery，加载最新的TxTable，对于处于COMMITTED状态的事务，将其TxLogs索引加载到Skiplist中，对于处于RUNNING状态的事务，直接进行Abort并回收其资源。&lt;/p&gt;
&lt;h1 id=&#34;conclusion--thinking&#34;&gt;Conclusion &amp;amp;&amp;amp; Thinking&lt;/h1&gt;
&lt;p&gt;本文提出了一种基于K/V存储架构的文件系统，通过对Key的设计保证了在I/O操作中的高效性。通过本文了解了一些KV存储的trick，对于KV存储的各种场景，无论是在Redis中还是在KV文件系统中，对于Key的设计都至关重要，好的设计往往能够带来极大的效率提升，例如布隆过滤器的应用，有很多经验值得学习。同时了解了对事务的一些控制机制。&lt;/p&gt;
&lt;p&gt;此篇论文让我惊讶于文件系统还能通过KV存储来实现的通知，还让我回想起了TiDB，通过KV存储系统来实现了分布式关系型数据库，并完全兼容MySQL，说明在利用好KV存储的特性的情况下，可以有效的解决问题，要多去学习他们的设计思想。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>[ATC&#39;19] Asynchronous I/O Stack: A Low-latency Kernel I/O Stack for Ultra-Low Latency SSDs</title>
        <link>https://blog.ipandai.club/p/atc19-asynchronous-i/o-stack-a-low-latency-kernel-i/o-stack-for-ultra-low-latency-ssds/</link>
        <pubDate>Wed, 17 Aug 2022 10:30:41 +0800</pubDate>
        
        <guid>https://blog.ipandai.club/p/atc19-asynchronous-i/o-stack-a-low-latency-kernel-i/o-stack-for-ultra-low-latency-ssds/</guid>
        <description>&lt;h1 id=&#34;intro&#34;&gt;Intro&lt;/h1&gt;
&lt;p&gt;优化I/O的方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户层面直接调用外部存储设备，需要应用包含文件系统的调用，臃肿，同时不同应用和用户间的冲突问题。&lt;/li&gt;
&lt;li&gt;优化操作系统内核的I/O 栈
&lt;ul&gt;
&lt;li&gt;使用轮询来减少上下文切换的开销&lt;/li&gt;
&lt;li&gt;在底层减少一半的中断处理&lt;/li&gt;
&lt;li&gt;分散I/O指令&lt;/li&gt;
&lt;li&gt;I/O block调度机制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;related-work&#34;&gt;Related Work&lt;/h1&gt;
&lt;p&gt;减少内核的开销&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少中断处理的后半部分&lt;/li&gt;
&lt;li&gt;是用轮询技术而非中断，减少上下文切换&lt;/li&gt;
&lt;li&gt;混合轮询&lt;/li&gt;
&lt;li&gt;基于SSD的闪存随机读写简化调度策略&lt;/li&gt;
&lt;li&gt;在NVMe固件中进行调度&lt;/li&gt;
&lt;li&gt;对高优先级的任务，提供不同的IO path支持，最小化IO path的开销&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;修改存储接口&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分散/分散 IO合并多个IO到一个指令，减少往返次数&lt;/li&gt;
&lt;li&gt;移除doorbell机制和完成信号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;改善fsync&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;冲fsync请求发出到收到response，延长数据持久化的时间&lt;/li&gt;
&lt;li&gt;在日志提交记录中使用校验和，有效的重叠日志写入和块写入&lt;/li&gt;
&lt;li&gt;提出&lt;code&gt;写守序系统调用&lt;/code&gt;，重叠的fsync效果相同，当应用需要使用fsync时，关于IO的操作将同步进行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用户层直接访问外设，存在隔离、保护等安全问题&lt;/p&gt;
&lt;h1 id=&#34;motivation&#34;&gt;Motivation&lt;/h1&gt;
&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;现状：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I/O 请求过程中太多的步骤&lt;/li&gt;
&lt;li&gt;页面缓存分配和索引&lt;/li&gt;
&lt;li&gt;DMA，一系列数据结构的创建&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前的 ULL SDD实现了低于10微妙的IO延迟，然而操作系统内核产生的延迟没有明显变化&lt;/p&gt;
&lt;p&gt;本文专注于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux内核中的&lt;code&gt;read()&lt;/code&gt;和&lt;code&gt;write()+fsync()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;基于NVMe SSD的Ext4文件系统&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;for-read-path&#34;&gt;For Read Path&lt;/h2&gt;
&lt;p&gt;研究发现许多剩余的操作不必在设备I/O之前或之后执行&lt;/p&gt;
&lt;p&gt;此类操作可以在设备I/O操作进行时执行&lt;/p&gt;
&lt;p&gt;因为此类操作大多独立于设备I/O操作，因此考虑让这些操作与IO重叠&lt;/p&gt;
&lt;h2 id=&#34;for-write-path&#34;&gt;For Write Path&lt;/h2&gt;
&lt;p&gt;缓冲写&lt;code&gt;write()&lt;/code&gt;，并不发起IO请求，不能异步处理&lt;/p&gt;
&lt;p&gt;由于fsync的回写机制和文件系统崩溃一致性（日志系统），包含部分IO请求&lt;/p&gt;
&lt;p&gt;由于文件系统带来的三次IO操作&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据块写&lt;/li&gt;
&lt;li&gt;jbd2发起写入日志Block I/O&lt;/li&gt;
&lt;li&gt;提交Block I/O&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些IO的创建，涉及众多过程（block分配，请求缓冲页，创建和提交bio，设置DMA地址），因此可以让CPU将这些前置操作在IO请求发起前预执行。&lt;/p&gt;
&lt;h2 id=&#34;for-lightweight-block-layer&#34;&gt;For Lightweight Block Layer&lt;/h2&gt;
&lt;p&gt;传统Block Layer涉及过多过程，推迟了IO指令提交给设备的时间&lt;/p&gt;
&lt;p&gt;因为ULL SSD的高速随机IO性能和低速的顺序IO，请求重排的效果很低&lt;/p&gt;
&lt;p&gt;简化block layer，针对异步IO stack进行优化&lt;/p&gt;
&lt;h1 id=&#34;design&#34;&gt;Design&lt;/h1&gt;
&lt;h2 id=&#34;轻量化的block-io-layer&#34;&gt;轻量化的Block I/O Layer&lt;/h2&gt;
&lt;p&gt;LBIO，为LL NVMe SSD而设计，只支持IO submission/completion和IO指令tagging&lt;/p&gt;
&lt;p&gt;只使用&lt;code&gt;lbio&lt;/code&gt;来表示一个block I/O请求，减少了&lt;code&gt;bio-to-request&lt;/code&gt;的时间&lt;/p&gt;
&lt;p&gt;每个lbio包括&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LBA&lt;/li&gt;
&lt;li&gt;I/O 长度&lt;/li&gt;
&lt;li&gt;复制的页面&lt;/li&gt;
&lt;li&gt;页面的DMA地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用全局的lbio二位数组来记录&lt;/p&gt;
&lt;p&gt;行的个数为CPU核心数，行成组被分配到一个NVMe队列&lt;/p&gt;
&lt;p&gt;例如8核心，4NVMe队列，每个队列分配2个核心的lbio
当核心数等于队列数时，可以实现无锁的命令提交&lt;/p&gt;
&lt;p&gt;lbio在全局数组中的索引用作NVMe指令的tag，减少了之前赋tag的过程&lt;/p&gt;
&lt;p&gt;lbio提交后，调用&lt;code&gt;nvme_queue_lbio&lt;/code&gt;来提交I/O指令&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LBIO不会合并和调度IO请求&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;read-path&#34;&gt;Read Path&lt;/h2&gt;
&lt;p&gt;Ext4文件系统中，由extent status tree保存缓存到物理文件block的映射&lt;/p&gt;
&lt;p&gt;预加载映射到内存中，当树太大时，可以只对某个文件预加载&lt;/p&gt;
&lt;h3 id=&#34;异步页面申请和dma分配&#34;&gt;异步页面申请和DMA分配&lt;/h3&gt;
&lt;p&gt;提前分配空闲页池&lt;/p&gt;
&lt;p&gt;为了减少页面DMA的分配，为每个核维护一个DMA映射空闲页（4KB DMA映射页的链表）&lt;/p&gt;
&lt;p&gt;当空闲页池不够用时，将退化为同步进行（origin）&lt;/p&gt;
&lt;h3 id=&#34;缓存页索引&#34;&gt;缓存页索引&lt;/h3&gt;
&lt;p&gt;自旋锁防止并发问题，影响效率&lt;/p&gt;
&lt;p&gt;在请求发出，但是页面还没有更新时，可能重复请求更新页面&lt;/p&gt;
&lt;p&gt;解决方案是不限制request，在request completion阶段解决问题&lt;/p&gt;
&lt;p&gt;尽管多个block请求，但是只能有一个页面被索引&lt;/p&gt;
&lt;p&gt;对于其他页面，标记为abandoned，中断发生之后，如果标记为abandoned，则清除已经完成的页面&lt;/p&gt;
&lt;h3 id=&#34;dma解除映射&#34;&gt;DMA解除映射&lt;/h3&gt;
&lt;p&gt;原本使用中断来处理，改为当系统空闲或等待一个IO请求时处理&lt;/p&gt;
&lt;p&gt;该方式可能会产生漏洞窗口，若不受到恶意访问，不会产生影响，否则用户可以自行选择关闭惰性DMA映射接触&lt;/p&gt;
&lt;h2 id=&#34;write--fsync-path&#34;&gt;Write &amp;amp;&amp;amp; fsync Path&lt;/h2&gt;
&lt;p&gt;当fsync涉及文件系统中事务时，可以将jbd2日志处理重叠处理&lt;/p&gt;
&lt;h1 id=&#34;experiment&#34;&gt;Experiment&lt;/h1&gt;
&lt;p&gt;基于Linux内核5.0.5版本&lt;/p&gt;
&lt;p&gt;使用文件描述符&lt;code&gt;O_AIOS&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;evaluation&#34;&gt;Evaluation&lt;/h1&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;提出了AIOS&lt;/p&gt;
&lt;p&gt;LBIO层&lt;/p&gt;
&lt;p&gt;AIOS将I/O路径中的同步操作替换为异步操作，以将与读取和fsync相关的计算与设备I/O访问重叠。&lt;/p&gt;
&lt;p&gt;AIOS在Optane SSD上实现了一位数微秒的I/O延迟。&lt;/p&gt;
&lt;p&gt;此外，AIOS通过Z-SSD和Optane SSD上的模拟实验和实际测试显著降低延迟和性能改进。&lt;/p&gt;
&lt;h1 id=&#34;一些启发&#34;&gt;一些启发&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;优化I/O可以从CPU的空闲时间分析，需要考虑内核和文件系统的工作流程，最大程度的利用CPU资源，减少空闲。&lt;/li&gt;
&lt;li&gt;硬件设备在发展的同时，软件应该提供必要适配&lt;/li&gt;
&lt;li&gt;减少内核中与I/O相关的结构类型转化，可以有效节省时间开销&lt;/li&gt;
&lt;li&gt;惰性修改会存在安全问题，在保证安全的情况下，可以提高效率&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>[OSDI&#39;19] Flashshare: Punching Through Server Storage Stack from Kernel to Firmware for Ultra-Low Latency SSDs</title>
        <link>https://blog.ipandai.club/p/osdi19-flashshare-punching-through-server-storage-stack-from-kernel-to-firmware-for-ultra-low-latency-ssds/</link>
        <pubDate>Wed, 17 Aug 2022 10:30:30 +0800</pubDate>
        
        <guid>https://blog.ipandai.club/p/osdi19-flashshare-punching-through-server-storage-stack-from-kernel-to-firmware-for-ultra-low-latency-ssds/</guid>
        <description>&lt;p&gt;超低延迟固态硬盘从内核到固件的服务器存储堆栈&lt;/p&gt;
&lt;h1 id=&#34;个别名词解释&#34;&gt;个别名词解释&lt;/h1&gt;
&lt;p&gt;the 99^th percentile 超过统计数据99%的数是多少&lt;/p&gt;
&lt;p&gt;blk-mq Linux Multiqueue block layer 内核对ssd随机I/O的优化&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;message signaled interrupt (MSI)&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;1摘要&#34;&gt;1.摘要&lt;/h1&gt;
&lt;p&gt;flash share&lt;/p&gt;
&lt;p&gt;在内核中，扩展了系统堆栈的数据结构，传递应用程序的属性（？），包括内核层到SSD固件。&lt;/p&gt;
&lt;p&gt;对于给定的属性，FlashShare的块层管理IO调度并处理NVMe中断。&lt;/p&gt;
&lt;p&gt;评估结果表明，FLASHSHARE可以将共同运行应用程序的平均周转响应时间分别缩短22%和31%。&lt;/p&gt;
&lt;h1 id=&#34;10-intro&#34;&gt;1.0 Intro&lt;/h1&gt;
&lt;h2 id=&#34;11-现状&#34;&gt;1.1 现状&lt;/h2&gt;
&lt;p&gt;网络服务提供商，满足服务级别协议SLA，延迟敏感&lt;/p&gt;
&lt;p&gt;某个段时间短可能有大量请求涌入，供应商会超额配置机器以满足SLA&lt;/p&gt;
&lt;p&gt;现状：该场景并不常见，因此大部分情况下服务器的资源占用率非常低，能耗比低。&lt;/p&gt;
&lt;p&gt;为了解决利用率低，服务器会运行离线的数据分析应用，延迟不敏感，以吞吐量为导向。&lt;/p&gt;
&lt;p&gt;因此，在运行了多个进程的服务器上，I/O延迟增高，满足SLA非常困难。&lt;/p&gt;
&lt;p&gt;现有的ULL SSD相较于NVMe SSD可以减少10倍的延迟&lt;/p&gt;
&lt;p&gt;但是这些ULL SSD在同时运行多个进程下高强度压榨服务器的时候，不能充分利用ULL SSD的优势/表现一般。&lt;/p&gt;
&lt;p&gt;the 99th percentile 是0.8ms（apache）&lt;/p&gt;
&lt;p&gt;但是当服务器同时运行pagerank的时候，延迟会增加228.5%。&lt;/p&gt;
&lt;p&gt;原因：略&lt;/p&gt;
&lt;p&gt;从固件到内核优化堆栈的存储。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;内核级别的增强：&lt;/p&gt;
&lt;p&gt;两个挑战&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux的blk-mq导致I/O请求队列化，引入延迟&lt;/li&gt;
&lt;li&gt;NVMe的队列机制没有对I/O优先级的策略，因此，来自离线应用的IO请求容易阻塞在线应用的紧急请求，造成延迟。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于latency critical的请求，绕过NVMe的请求队列。同时令NVMe的驱动通过知晓每个应用的延迟临界匹配NVMe的提交和请求队列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;固件层设计：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​		即使内核级的优化保证了延迟敏感的请求可以获得高优先级，但如果基础固件不了解延迟临界值，ULL特性（类似内存的性能）无法完全暴露给用户。本文中重新设计了I/O调度和缓存的固件，以直接向用户暴露ULL特性。将ULL SSD的集成缓存进行分区，并根据工作负载的属性对每个I/O服务独立的分配缓存。固件动态的更新分区大小并以精细粒度调整预取I/O粒度。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ULL SSD的新中断处理服务：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​	当前的NVMe中断机制没有对ULL I/O服务优化。轮询方法（Linux 4.9.30）消耗了大量的CPU资源去检查I/O服务的完成情况。当轮询在线交互服务的IO请求完成状态时，flashShare使用一个仅对离线应用程序使用消息信号中断的选择性中断服务程序Select-ISR。&lt;/p&gt;
&lt;p&gt;​	通过将NVMe队列和ISR卸载到硬件加速器中来进一步优化NVMe completion routine。&lt;/p&gt;
&lt;p&gt;​	各种仿真实验后效果不错，效率提高了22%和31%。&lt;/p&gt;
&lt;h1 id=&#34;20-background&#34;&gt;2.0 Background&lt;/h1&gt;
&lt;h2 id=&#34;21-存储内核栈&#34;&gt;2.1 存储内核栈&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.ipandai.club/image-20220810145032258.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20220810145032258&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Linux文件系统IO&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bio&lt;/li&gt;
&lt;li&gt;request&lt;/li&gt;
&lt;li&gt;nvme_rw_command&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;存储堆栈中，NVMe驱动发起的请求通过nvme_rw_command的形式传递到PCI/PCIe设备驱动中。&lt;/p&gt;
&lt;p&gt;当I/O请求完成后，发送信号中断，中断直接被写入到中断处理器的中断向量中。被中断的核心选择ISR处理该中断请求，随后NVMe驱动再SQ/CQ中清空相应的记录并将结果返回至上一层（比如blk-mq和文件系统）。&lt;/p&gt;
&lt;h2 id=&#34;22-设备固件栈&#34;&gt;2.2 设备固件栈&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.ipandai.club/image-20220810232230437.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20220810232230437&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;收到request&lt;/li&gt;
&lt;li&gt;SQ tail++入队&lt;/li&gt;
&lt;li&gt;写入SQ门铃寄存器&lt;/li&gt;
&lt;li&gt;通过DMA读取数据的物理位置&lt;/li&gt;
&lt;li&gt;SQ head++出队&lt;/li&gt;
&lt;li&gt;将请求转发至嵌入式缓存层或者FTL&lt;/li&gt;
&lt;li&gt;当出现缺页或者页面替换时，FTL将目标LBA转换成Z-NAND中相应的物理地址，必要时自行GC&lt;/li&gt;
&lt;li&gt;在完成I/O请求之后，NVMe控制器增加这个CQ的tail，入队&lt;/li&gt;
&lt;li&gt;通过DMA传输数据，并修改phase tag&lt;/li&gt;
&lt;li&gt;主机ISR通过搜索队列中检查phase tag，对于有效的phase tag，ISR清除tag位，并且处理剩余的I/O完成请求程序。&lt;/li&gt;
&lt;li&gt;CQ head++出队，在SQ中移除相应的记录，并且写入CQ的head doorbell&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;30-跨层设计&#34;&gt;3.0 跨层设计&lt;/h1&gt;
&lt;h2 id=&#34;31-快速存储的挑战&#34;&gt;3.1 快速存储的挑战&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.ipandai.club/image-20220811110758918.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20220811110758918&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;原因是存储栈无法区分来自Apache的I/O请求，及时两个应用需要不同级别I/O的响应。&lt;/p&gt;
&lt;h1 id=&#34;32-预知灵敏响应&#34;&gt;3.2 预知灵敏响应&lt;/h1&gt;
&lt;p&gt;为了让内核可以区分I/O 请求的优先级和紧迫程度，修改Linux的进程控制快&lt;code&gt;task_struct&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;为了保证有效性，在&lt;code&gt;address_space&lt;/code&gt;,&lt;code&gt;bio&lt;/code&gt;,&lt;code&gt;request&lt;/code&gt;,&lt;code&gt;nvme_rw_command&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;中都保存工作负载属性，在存储堆栈上打孔。&lt;/p&gt;
&lt;p&gt;FlashShare同时提供了一个可以在服务器上配置这些属性的工具。叫做&lt;code&gt;chworkload_attr&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;可以方便的修改每个应用的属性并绑定到&lt;code&gt;task_struct&lt;/code&gt;中&lt;/p&gt;
&lt;p&gt;修改了syscall表&lt;code&gt;arch/x86/entry/syscalls/syscall 64.tbl&lt;/code&gt;添加了两个系统调用，可以从&lt;code&gt;task_struct&lt;/code&gt;中set/get工作属性。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;/linux/syscall.h&lt;/code&gt;中进行注册，并带有&lt;code&gt;asmlinkage&lt;/code&gt;标签。&lt;/p&gt;
&lt;p&gt;用户通过shell给定特定进程，实现于&lt;code&gt;/sched/cores.c&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;33-内核优化&#34;&gt;3.3 内核优化&lt;/h2&gt;
&lt;p&gt;优化文件系统中的blk-mq和NVMe驱动&lt;/p&gt;
&lt;p&gt;blk-mq合并重排请求提高了带宽使用，但是引入了延迟&lt;/p&gt;
&lt;p&gt;跳过所有在线应用的I/O 请求&lt;/p&gt;
&lt;p&gt;如果离线应用程序的 I/O 请求被 blk-mq 调度到后续在线应用程序发出的同一 LBA，则可能发生危险。&lt;/p&gt;
&lt;p&gt;如果两个请求的操作类型不同，blk-mq会将两个请求串联。否则blk-mq会将两个请求合并为一个&lt;code&gt;request&lt;/code&gt;并交给NVMe驱动。&lt;/p&gt;
&lt;p&gt;为了防止延迟敏感的I/O 被NVMe控制器杀死：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为每个核心创建两个SQ队列和一个CQ队列&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.ipandai.club/image-20220811173922087.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20220811173922087&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;其中一个SQ保存来自在线应用的I/O请求。&lt;strong&gt;NVMe驱动程序通过管理员队列发送消息，通知NVMe控制器选择一种新的队列调度方法，该方法始终优先安排该SQ中的请求。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;未来避免因优先级带来的饥饿，当该队列中的请求数量大于阈值时，或者没有在规定时间内被满足，NVMe驱动会满足所有离线应用I/O 。&lt;/p&gt;
&lt;p&gt;实验表明，队列大小为8或者200us的阈值最好。&lt;/p&gt;
&lt;h1 id=&#34;40-io-completion和缓存&#34;&gt;4.0 I/O Completion和缓存&lt;/h1&gt;
&lt;p&gt;采用轮询机制时查询I/O Completion时，内核态占用97%。&lt;/p&gt;
&lt;p&gt;带来两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;没有为处理I/O 响应单独分配核心，对于多进程下低效&lt;/li&gt;
&lt;li&gt;我们要减轻处理I/O轮询的核心开销，进一步降低延迟&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;41-中断处理程序&#34;&gt;4.1 中断处理程序&lt;/h2&gt;
&lt;p&gt;flash share仅对来自在线应用的I/O 请求使用轮询&lt;/p&gt;
&lt;p&gt;使用信号处理离线应用&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.ipandai.club/image-20220811231355037.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20220811231355037&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;修改blk-mq中的&lt;code&gt;submit_bio()&lt;/code&gt;，将由文件系统或缓存的bio插入到mq&lt;/li&gt;
&lt;li&gt;如果bio是来自离线应用的，则插入队列，as normal&lt;/li&gt;
&lt;li&gt;如果bio是来自在线应用的，blk-mq则调用&lt;code&gt;queue_rq()&lt;/code&gt;将请求发送至NVMe驱动。&lt;/li&gt;
&lt;li&gt;NVMe驱动转换I/O 请求为NVMe指令并非插入到响应SQ队列中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用Select-ISR，当请求为离线应用时，CPU核心可以通过上下文切换从NVMe驱动中释放。否则，blk-mq调用轮询机制&lt;code&gt;blk-poll()&lt;/code&gt;。&lt;code&gt;blk-poll()&lt;/code&gt;持续调用&lt;code&gt;nvme_poll()&lt;/code&gt;，检查有效的完成记录是否存在于目标NVMe CQ中。如果存在，blk-mq禁用此CQ的IRQ，以至于MSI信号无法再次捕获blk-mq程序。&lt;code&gt;nvme_poll()&lt;/code&gt;通过检查CQ中的phase tags查找CQ中的新记录。&lt;/p&gt;
&lt;p&gt;具体来说，&lt;code&gt;nvme poll()&lt;/code&gt;搜索一个CQ记录，其请求信息与&lt;code&gt;blk poll()&lt;/code&gt;等待完成的标签匹配。一旦检测到这样的新记录，blk-mq就会退出在&lt;code&gt;blk poll()&lt;/code&gt;中实现的无限迭代，并将上下文切换到其用户进程。&lt;/p&gt;
&lt;p&gt;提出&lt;code&gt;I/O-stack accelerator&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;主要目的是将blk-mq的任务迁移到附属于PCIe的加速器中&lt;/p&gt;
&lt;p&gt;可以使得通过上层文件系统生成的bio直接转换成&lt;code&gt;nvm_rw_command&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;通过特殊的tag索引搜索队列中的元素，并且代表CPU合并bio&lt;/p&gt;
&lt;p&gt;该方法可以减少36%的I/O completion时间。&lt;/p&gt;
&lt;h2 id=&#34;42-固件层&#34;&gt;4.2 固件层&lt;/h2&gt;
&lt;p&gt;创建两个内存分区，一个服务于在线应用，一个服务于离线应用。&lt;/p&gt;
&lt;p&gt;三种模式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;固定拆分缓存&lt;/li&gt;
&lt;li&gt;根据I/O动态划分&lt;/li&gt;
&lt;li&gt;数据可保留&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.ipandai.club/image-20220812003132031.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20220812003132031&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;43-io-stack-acceleration&#34;&gt;4.3 I/O-Stack Acceleration&lt;/h2&gt;
&lt;p&gt;添加了一个barrier logic，简单的MUX，作为硬件仲裁&lt;/p&gt;
&lt;p&gt;引入status bitmap来过滤SQ队列中的记录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;合并逻辑插入一个行的nvme 指令，status bitmap设置为1&lt;/li&gt;
&lt;li&gt;如果监测到ULL SSD从I/O SQ中读取NVMe指令，status bitmap设置为0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果状态位图表明CAM中的请求条目（与目标SQ相关联）无效，CAM将跳过对这些条目的搜索。&lt;/p&gt;
&lt;h1 id=&#34;50-实验&#34;&gt;5.0 实验&lt;/h1&gt;
&lt;h2 id=&#34;51-实验步骤&#34;&gt;5.1 实验步骤&lt;/h2&gt;
&lt;p&gt;使用gem5系统结构模拟&lt;/p&gt;
&lt;p&gt;64位arm指令集&lt;/p&gt;
&lt;p&gt;Linux 4.9.30&lt;/p&gt;
&lt;p&gt;8核心2GHz&lt;/p&gt;
&lt;p&gt;L1 Cache 64KB&lt;/p&gt;
&lt;p&gt;2GB Memory&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.ipandai.club/image-20220812191343849.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image-20220812191343849&#34;
	
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;related-work&#34;&gt;Related Work&lt;/h1&gt;
&lt;p&gt;将SSD固件转移到主机上，消除冗余的地址转换&lt;/p&gt;
&lt;p&gt;根据应用程序特征对缓存进行分区处理，然而不能发挥ULL SSD的作用&lt;/p&gt;
&lt;p&gt;从文件系统和block IO设备方面优化移动端操作系统，使其提高SQLite的性能，有局限性，应用程序、ULL SSD&lt;/p&gt;
&lt;p&gt;在内核的多个层对写请求进行调度，容易阻塞读请求和ULL操作&lt;/p&gt;
&lt;p&gt;根据前台任务和后台任务中的依赖关系，分配优先级，允许后台任务高优先级，IO通常情况下没有依赖关系，效果差，服务器大部分都是多进程&lt;/p&gt;
&lt;p&gt;考虑对在线应用设置高优先级，但是没有考虑对IO stack中其他部分的影响&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
