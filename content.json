{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"51nod3143-切比雪夫距离与曼哈顿距离","text":"51nod3143 Descriptionn位战士即将奔赴战场，他们每个人都有一个攻击值ai和一个防御值bi，现在你想设计一种装备给这n位战士，如果这件装备的攻击值为A，防御值为B，那么对于第i位战士这件装备的不匹配度为$max(|A−a_i|,|B−b_i|)$A，B都是正整数，要让所有战士的不匹配度之和最小，求出最小的不匹配度之和$2\\le N \\le 100000$ Solution题意中很明显是切比雪夫距离，可以将其转换为曼哈顿距离对于点$(x,y)$,转换为$(\\frac{x+y}{2},\\frac{x-y}{2})$然后可以求出转换后横坐标和纵坐标的中位数，再以这个中位数为基准，将四周3*3的范围内的点都进行计算，去最小值。由于涉及除法，可能会发生精度丢失，可以将所有坐标都扩大二倍，最后让答案除以2同时要注意，这里的A，B都是整数，也就是说我们进行计算的点必须也是整数点，可以通过奇偶关系来判断。答案只用A，B为整数点转换过来的点进行计算。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;set&gt;#define debug cout&lt;&lt;0&lt;&lt;endl#define ll long longconst int MAXN = 1e5 + 10;const int MOD = 1e9 + 7;using namespace std;struct point{ ll a, b;} arr[MAXN];int dx[] = {0, 1, -1, 0, 0, 1, 1, -1, -1};int dy[] = {0, 0, 0, 1, -1, 1, -1, 1, -1};ll x[MAXN];ll y[MAXN];int main() { ios::sync_with_stdio(false); cin.tie(0); int N; cin &gt;&gt; N; int xx, yy; for (int i = 1; i &lt;= N; i++) { cin &gt;&gt; xx &gt;&gt; yy; x[i] = arr[i].a = (xx + yy); y[i] = arr[i].b = (xx - yy); } sort(x+1,x+N+1); sort(y+1,y+N+1); int A, B; ll ans = __LONG_LONG_MAX__; if (N&amp;1) { A = x[N/2+1]; B = y[N/2+1]; } else { A = x[N/2+1]; B = y[N/2+1]; } ll ans2 = 0; for (int i = 0; i &lt;= 8; i++) { int tx = A + dx[i]; int ty = B + dy[i]; if ((tx-ty)%2==1 || ((tx+ty))%2==1) continue; ll temp = 0; for (int j = 1; j &lt;= N; j++) { temp += abs(arr[j].a-tx) + abs(arr[j].b-ty); } ans = min(ans, temp); } cout &lt;&lt; ans/2; return 0;}","link":"/2020/10/11/51nod3143/"},{"title":"GCD-兔八哥与猎人","text":"Description兔八哥躲藏在树林旁边的果园里。果园有M × N棵树，组成一个M行N列的矩阵，水平或垂直相邻的两棵树的距离为1。兔八哥在一棵果树下。猎人背着猎枪走进了果园，他爬上一棵果树，准备杀死兔八哥。如果猎人与兔八哥之间没有其它的果树，猎人就可以看到兔八哥。现己知猎人和兔八哥的位置，编写程序判断兔子所在的位置是否安全.输入： 第一行为n，表示有n(n ≤ 100,000)组数据，每组数据的第一行为两个正整数ax和ay，表示猎人的位置，第二行为两个正整数bx和by，表示兔八哥的位置(1 ≤ ax, ay, bx, by ≤ 100,000,000)。输出： 共有n行，每行为“yes”或“no”表示兔八哥的位置是否安全。 Solution容易想到，兔八哥和猎人只要连线上无整数点即可，可以转化成$|a_x - b_x| 和 |a_y - b_y|$互质，即$gcd(|a_x - b_x|,|a_y - b_y|)=1$ Code12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;#define mem(a,b) memset(a,b,sizeof(a))typedef long long ll;typedef unsigned long long ull;using namespace std;inline int gcd(int a, int b) { return b == 0 ? a : gcd(b,a%b);}int main() { //freopen(&quot;test.txt&quot;, &quot;r&quot;, stdin); ios::sync_with_stdio(false); cin.tie(0); int N; cin &gt;&gt; N; while (N--) { int ax, ay, bx, by; cin &gt;&gt; ax &gt;&gt; ay; cin &gt;&gt; bx &gt;&gt; by; int xx = abs(ax - bx); int yy = abs(ay - by); if (gcd(xx,yy) != 1) { cout &lt;&lt; &quot;yes&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;no&quot; &lt;&lt; endl; } } return 0;}","link":"/2020/10/07/GCD/"},{"title":"余数求和-整除分块","text":"Description给出整数$$n,k$$,计算$$G(n,k)=\\sum\\limits_{i=1}^n=k \\ mod \\ i$$,$$1&lt;=n,k&lt;=1e9$$ Solution将k mod i展开可以得到$$k - i\\lfloor \\frac{k}{i} \\rfloor$$将求和式子展开可以得到$$ \\sum\\limits_{i=1}^n = nk-\\sum\\limits_{i=1}^n i * \\lfloor\\frac{k}{i} \\rfloor $$利用整除分块，可以发现，对于相同的$$\\lfloor\\frac{k}{i} \\rfloor$$，即每个区间$$l 到 r$$，每次只需要再对i求和即可即每次计算$$(r-l+1)*\\lfloor \\frac{k}{i} \\rfloor * (l+r)/2$$ Note在分块的时候误写为r=N/(N/i)导致调试耽误大量时间，而且交了四发才发现 1234567for (ll l = 1, r; l &lt;= N; l = r + 1) { if (l &gt; K) { break; } r = min(N, K/(K/l)); ans -= (r - l + 1)*(K/l)*(l + r)/2; } Code1234567891011121314151617181920212223242526272829303132333435363738//https://www.luogu.com.cn/problem/P2261#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;set&gt;#define mem(a,b) memset(a,b,sizeof(a))#define debug cout&lt;&lt;0&lt;&lt;endl#define ll long longconst int MAXN = 1e2 + 10;const int MOD = 1e9 + 7;using namespace std;ll ans = 0;void solve(ll N, ll K) { ans = N*K; for (ll l = 1, r; l &lt;= N; l = r + 1) { if (l &gt; K) { break; } r = min(N, K/(K/l)); ans -= (r - l + 1)*(K/l)*(l + r)/2; } cout &lt;&lt; ans;}int main() { ios::sync_with_stdio(false); cin.tie(0); ll N, K; cin &gt;&gt; N &gt;&gt; K; solve(N, K); return 0;}","link":"/2020/10/07/divide/"},{"title":"统计硬币-递推&#x2F;DP","text":"DescriptionHDU 2566假设一堆由1分、2分、5分组成的n个硬币总面值为m分，求一共有多少种可能的组合方式（某种面值的硬币可以数量可以为0）。 Solution坑题，没给数据范围，只能瞎猜，一发搜索挂掉发现无法去重，但是考虑到该问题满足从1开始分配并无后效性，可以直接递推（类似背包），三种物品可选任意次 Code1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;#define mem(a,b) memset(a,b,sizeof(a))typedef long long ll;typedef unsigned long long ull;using namespace std;int main() { //freopen(&quot;test.txt&quot;, &quot;r&quot;, stdin); ios::sync_with_stdio(false); int N, M; int ans; int dp[2000][2000]; int n[] = {1,2,5}; cin.tie(0); int T; cin &gt;&gt; T; while (T--) { cin &gt;&gt; N &gt;&gt; M; mem(dp,0); dp[0][0] = 1; for (int i = 0; i &lt; 3; ++i) { for (int j = 1; j &lt;= N; ++j) { for (int k = n[i]; k &lt;= M; ++k) { dp[j][k] += dp[j-1][k-n[i]]; } } } cout &lt;&lt; dp[N][M] &lt;&lt; endl; } return 0;}","link":"/2020/10/07/cntcoin/"},{"title":"小兔的棋盘 组合数学","text":"Description小兔的叔叔从外面旅游回来给她带来了一个礼物，小兔高兴地跑回自己的房间，拆开一看是一个棋盘，小兔有所失望。不过没过几天发现了棋盘的好玩之处。从起点$(0，0)$走到终点$(n,n)$的最短路径数是$C_{2n}^{n}$,现在小兔又想如果不穿越对角线(但可接触对角线上的格点)，这样的路径数有多少?小兔想了很长时间都没想出来，现在想请你帮助小兔解决这个问题，对于你来说应该不难吧! $n \\leq 35$ Solution由于规定不能超过对角线，可用分治的思想，只考虑沿对角线分隔开的三角形的情况，对于一个三角形中，求从$(0，0)$走到终点$(n,n)$的最短路径，观察发现无论怎么走，设到达某一点时向上走了$i$步，向右走了$j$步，都有$i \\leq j$这也能通过线性规划相关知识证明。不难发现只是一个类括号匹配问题，可用$Catalan$数求解，计算$C(n)$后即是在一个三角形中的解，答案是$$2C(n)$$ $$C(n) = \\sum_{i=0}^{n-1} C(i) \\cdot C(n-i-1)$$通项公式$$C(n)=\\frac{C_{2n}^{n}}{n+1}$$ 预处理$C(n)$即可 Code1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;queue&gt;typedef long long LL;using namespace std;LL C[100];int main() { C[0] = 1; C[1] = 1; for (int i = 2; i &lt;= 80; i++) { LL t = 0; for (int j = 0; j &lt; i; j++) t += C[j]*C[i - j - 1]; C[i] = t; } LL N; int cnt = 1; while (cin &gt;&gt; N) { if (N == -1) break; cout &lt;&lt; cnt++ &lt;&lt; &quot; &quot; &lt;&lt; N &lt;&lt; &quot; &quot; &lt;&lt; C[N]*2 &lt;&lt; endl; } return 0;}","link":"/2019/12/13/catalan/"},{"title":"DP? 素数筛+Lucas定理+费马小定理","text":"Description在杨辉三角中，从第一行第一列$(0,0)$开始，每次可选择向正下方走或向右下方走，走到第$n$行时不能超过第$n$行第$k$个元素，询问所经过路径的值的和的最小值$mod(p)$，一共有T组询问，$T \\leq 100000$， $0 \\leq k \\leq n \\leq 1e9$, 保证$p$是质数， 其中$p &lt; 1e4$ Solution名字虽然是DP，但是可以找出最优方案。优先考虑$k \\leq \\frac{n}{2}$的情况，先向下走$n-k$步到达$(n-k-1,0)$再一路沿着右下方走，直到到达底部，即有$$C_{n-k}^{0}+C_{n-k+1}^{1}+C_{n-k+2}^{2}+…+C_{n}^{k}=C_{n+1}^{k}$$通过变换$$C_{n-k}^{0} = C_{n-k+1}{0}$$再通过公式$$C_{n}^{m}=C_{n-1}^{m}+C_{n-1}^{m-1}$$可将上述公式合并得到$$C_{n+1}^{k}$$所以答案为$$C_{n+1}^{k}+n-k$$当$$k &gt; \\frac{n}{2}$$时，根据对称性，令$k=n-k$即可转化成上一种情况又发现题目涉及组合数取模，所以要用到费马小定理 费马小定理:假如$a$是一个整数，$p$是一个质数，且$gcd(a,p)=1$，即$a,p$互质，那么有$a^{p−1}≡1(modp)$ 已知$a^{p-1}≡1$，可以得到$a \\cdot a^{p-2}≡1$，我们称$a$和$a^{p-2}$为在$mod(p)$意义下的乘法逆元然而这只解决了除法取模的问题，注意到$n$的范围在$1e9$直接计算组合数又是铁套老鹅(TLE)，于是借助Lucas定理 对于质数$p$,有$$C_n^m\\ mod \\ p = C_{\\lfloor \\frac{n}{p} \\rfloor}^{\\lfloor \\frac{m}{p} \\rfloor} \\cdot C_{n\\ mod\\ p}^{m\\ mod\\ p} \\ mod \\ p$$ 可知$n\\ mod\\ p$和$m\\ mod\\ p$一定是小于$p$的数，可直接求解，其余部分继续用Lucas定理求解，当$m=0$的时候返回$1$ 1234long long Lucas(long long n, long long m, long long p) { if (m == 0) return 1; return (C(n % p, m % p, p) * Lucas(n / p, m / p, p)) % p;} 有了这些工具之后就可以预处理阶乘和逆元了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;queue&gt;typedef long long LL;const int MAXN = 10000;using namespace std;LL N,K,MOD;bool isnotp[MAXN + 10];LL pri[1500], num = 0;//素数表int f[1300][MAXN];//阶乘int inv[1300][MAXN];//逆元inline void Euler() { isnotp[1] = true; memset(isnotp, false, sizeof(isnotp)); for (int i = 2; i &lt;= MAXN; i++) { if (!isnotp[i]) pri[++num] = i; for (int j = 1; j &lt;= num &amp;&amp; i*pri[j] &lt;= MAXN; j++) { isnotp[i*pri[j]] = true; if (i%pri[j]==0) break; } }}LL fffpow(LL x, LL y, LL pp) { LL sum = 1; LL a = x; while (y) { if (y&amp;1) { sum = (sum*a) % pp; } a = (a*a)%pp; y&gt;&gt;=1; } return (sum)%pp;}int cnt = 0;inline LL Lucas(int N,int M,int o){ LL a,b,ans=1; while(N &amp;&amp; M) { a = N%pri[o]; b = M%pri[o]; if(a &lt; b)return 0; ans = ans*f[o][a]%pri[o]*inv[o][b]%pri[o]*inv[o][a-b]%pri[o]; N /= pri[o]; M /= pri[o]; } return ans;} int main() { Euler(); for(int i = 1; i &lt;= num; i++) { f[i][0] = f[i][1] = 1; inv[i][0] = inv[i][1] = 1; for(int j = 2;j &lt; pri[i]; j++) { f[i][j] = f[i][j-1]*j % pri[i]; inv[i][j] = fffpow(f[i][j], pri[i]-2, pri[i]); } } while (cin &gt;&gt; N &gt;&gt; K &gt;&gt; MOD) { LL ans; if(K &gt; N/2) K = N - K; int l = 1, r = 1229; while(l &lt;= r) { int mid = (l + r) &gt;&gt; 1; if(MOD &lt; pri[mid]) r = mid - 1; else l = mid + 1; } ans = (Lucas(N + 1, K, l - 1) + N - K)%MOD; printf(&quot;Case #%d: %lld\\n&quot;, ++cnt, ans); } return 0;}","link":"/2019/12/13/lucas/"},{"title":"Fibonacci 矩阵快速幂","text":"Description请输出$Fib(n) mod 10000$$n \\leq 1000000000$ Solution由于$n$的范围在$1e9$直接递推铁TLE，考虑矩阵快速幂Fibonacci数列有如下性质通过多次迭代算是个板子题吧，记得在WUST新生赛做过一道想矩阵快速幂的题，然而正解是找规律QAQ，在此贴个板子。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;string&gt;typedef long long LL;const int MOD = 1e4;using namespace std;struct Matrix{ LL m[2][2]; void print(){ for (int i = 0; i &lt; 2; i++) { for (int j = 0; j &lt; 2; j++) cout &lt;&lt; m[i][j] &lt;&lt; ' '; cout &lt;&lt; endl; } }} base, ans;Matrix times(Matrix a, Matrix b) { Matrix ans; ans.m[0][1] = ans.m[0][0] = ans.m[1][0] = ans.m[1][1] = 0; for (int i = 0; i &lt; 2; i++) { for (int j = 0; j &lt; 2; j++) { for (int k = 0; k &lt; 2; k++) ans.m[i][j] = (ans.m[i][j] + a.m[i][k]*b.m[k][j])%MOD; } } return ans;}void Matrixpow(LL x) { base.m[0][0] = base.m[1][0] = base.m[0][1] = 1; base.m[1][1] = 0; ans.m[0][0] = ans.m[1][1] = 1; ans.m[0][1] = ans.m[1][0] = 0; while (x) { if (x&amp;1){ ans = times(ans, base); } x &gt;&gt;= 1; base = times(base, base); }}LL N;int main(){ while (cin &gt;&gt; N) { if (N == -1) break; if (N == 0) { cout &lt;&lt; &quot;0&quot; &lt;&lt; endl; continue; } Matrixpow(N); cout &lt;&lt; ans.m[0][1] % MOD &lt;&lt; endl; } return 0;}","link":"/2019/12/13/fibMatrix/"},{"title":"计算几何-平行四边形","text":"Description求平面上n个点构成的平行四边形个数。输入一行一个数n。接下来n行，每行两个数x,y，表示这个点的坐标为(x,y)。保证任意两点不重合，任意三点不共线。输出一行一个整数表示平行四边形个数。 Solution按照平行四边形的性质，两组顶点的中点重合，可以统计出每组顶点的中点，再统计每个顶点的个数，排列组合一下 Note第一发对于顶点的统计出锅了，排序条件写错，提交都要检查排序","link":"/2020/05/13/jsjh/"},{"title":"莫队-小B的询问洛谷P2709","text":"DescriptionP2709小B 有一个长为n的整数序列$a$，值域为$[1,k]$。他一共有m个询问，每个询问给定一个区间$[l,r]$求：$\\sum_{i=1}^k c_i^2$其中 $c_i$表示数字 $i$ 在$[l,r]$ 中的出现次数。小B请你帮助他回答询问。 Solution莫队算法板子题 mark Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;set&gt;#define mem(a,b) memset(a,b,sizeof(a))#define debug cout&lt;&lt;0&lt;&lt;endl#define ll long longconst int MAXN = 5e4 + 10;const int MOD = 1e9 + 7;using namespace std;struct Q{ int l, r, k;} q[MAXN];int N, M, K;int pos[MAXN], a[MAXN], cnt[MAXN];ll ans[MAXN];ll res;inline void Add(int n) { cnt[a[n]]++; res += 2ll*cnt[a[n]] - 1;}inline void Sub(int n) { cnt[a[n]]--; res -= 2ll*cnt[a[n]] + 1;}int main() { ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; N &gt;&gt; M &gt;&gt; K; int siz = sqrt(N); for (int i = 1; i &lt;= N; i++) { cin &gt;&gt; a[i]; pos[i] = i/siz; } for (int i = 1; i &lt;= M; i++) { cin &gt;&gt; q[i].l &gt;&gt; q[i].r; q[i].k = i; } sort(q+1,q+M+1,[](Q x, Q y){ return pos[x.l] == pos[y.l] ? x.r &lt; y.r : pos[x.l] &lt; pos[y.l]; }); int l = 1, r = 0; for (int i = 1; i &lt;= M; i++) { while (q[i].l &lt; l) Add(--l); while (q[i].r &gt; r) Add(++r); while (q[i].l &gt; l) Sub(l++); while (q[i].r &lt; r) Sub(r--); ans[q[i].k] = res; } for (int i = 1; i &lt;= M; i++) { cout &lt;&lt; ans[i] &lt;&lt; endl; } return 0;}","link":"/2020/10/07/modui/"},{"title":"Triangle Fibonacci+二分查找","text":"Description有$n$个木棍，长度为$1,2,3…n$，现在要从中删掉一些木棍，使得剩下的木棍不能构成三角形，使删掉木棍的数量最少。T组数组，$T \\leq 20$$n \\leq 20$ Solution由于数据范围很小，可以直接暴力求解，依次选取两个数$a,b(a&lt;b)$相加，要知道不能有任何一个数小于这个值，直接删掉$(a,a+b)$范围中的数即可如果$n$的范围是$1e9$呢？通过找规律发现我们剩下的数是这样的$1,2,3,5,8,13,21…$这是Fibonacci数列!!!!所以我们只需要找到$\\leq n$的Fibonacci数有几个，减去就是答案可以直接lower_bound注意处理极限数据！！！即$n==1||n==2$的情况也可手写二分，但是二分貌似常数有点大，又考虑到第$88$个Fibonacci数就爆掉$1e9$了，所以直接便利也完全没问题 Code暴力版本12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;bool vis[23];int main() { int T; cin &gt;&gt; T; for (int i = 1; i &lt;= T; i++) { int N, ans = 0; cin &gt;&gt; N; memset(vis, false, sizeof(vis)); for (int j = 1; j &lt;= N - 1; j++) if (!vis[j]) { for (int k = j + 1; k &lt;= N; k++) { if (!vis[k]) { for (int l = k + 1; l &lt;= j + k - 1; l++) if (!vis[l] &amp;&amp; l &lt;= N) vis[l] = true, ans++; break; } } } printf(&quot;Case #%d: %d\\n&quot;, i, ans); } return 0;} 二分+Fib123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;queue&gt;typedef unsigned long long uLL;typedef long long LL;const LL MOD = 1e18; using namespace std;LL f[100];int main() { f[0] = 1; f[1] = 1; for (int i = 2; i &lt;= 80; i++) f[i] = f[i - 1] + f[i - 2]; int T; cin &gt;&gt; T; for (int i = 1; i &lt;= T; i++){ LL N; cin &gt;&gt; N; if (N == 1 || N == 2) { printf(&quot;Case #%d: 0\\n&quot;, i); continue; } int l = 1, r = 80; /*手写二分查找 while (l &lt;= r) { int mid = (l + r) &gt;&gt; 1; if (f[mid] &lt;= N) l = mid + 1; else r = mid - 1; } int pos = l; */ int pos = lower_bound(f, f + 80, N) - f; if (f[pos] != N) pos--; printf(&quot;Case #%d: %d\\n&quot;, i, N - pos); } return 0;}","link":"/2019/12/13/fib/"},{"title":"Luogu3964-松鼠聚会","text":"Luogu3964 Description草原上住着一群小松鼠，每个小松鼠都有一个家。时间长了，大家觉得应该聚一聚。但是草原非常大，松鼠们都很头疼应该在谁家聚会才最合理。每个小松鼠的家可以用一个点$(x,y)$表示,两个点的距离定义为点 $(x,y)$ 和它周围的8个点 $$(x-1,y)，(x+1,y),(x,y-1)，(x,y+1)$$$(x−1,y+1),(x-1,y-1),(x+1,y+1),(x+1,y-1)$距离为1。输出一个整数，表示松鼠为了聚会走的路程和最小是多少。 Solution观察题目发现，松鼠家之间的距离为切比雪夫距离，可以通过转换成曼哈顿距离求解，即问题转换为给出平面中的N个点，求一个点到其他所有点的曼哈顿距离之和最小是多少。如果选定的点为第j个答案即为$$\\sum_{i=1}^{N}dis(i,j)$$,dis表示两个点的曼哈顿距离将两个坐标拆开计算，可以得到$$ans_x = \\sum_{i=1}^Ndis(j,i)$$$$dis(1,j)+dis(2,j)+dis(3,j) +…+dis(n,j)$$将横坐标按照升序排序$$(x_j-x_1)+(x_j-x_2)+(x_j-x_3)+…+(x_j-x_{j-1})+(x_{j+1}-x_j)+…+(x_n-x_j)$$ $$\\sum_{i=1}^{j-1}(x_j-x_i)+\\sum_{i=j+1}^{N}(x_i-x_j)$$ $$(j-1)*x_j-\\sum_{i=1}^{j-1}x_i + \\sum_{i=j+1}^Nx_i-(N-j)*x_j$$ $$\\sum_{i=1}^Nx_i-2\\sum_{i=1}^jx_i-x_j*(n-2*j)$$于是可以使用前缀和优化，坐标排序后预处理前缀和在每次进行计算时在有序坐标数组中找到对应的下标精度问题可以先把坐标都扩大二倍，最后令答案处以2 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;set&gt;#define debug cout&lt;&lt;0&lt;&lt;endl#define ll long longconst int MAXN = 1e5 + 10;const int MOD = 1e9 + 7;using namespace std;int N;struct point { ll x, y;} a[MAXN];ll x[MAXN]; ll prex[MAXN];ll y[MAXN];ll prey[MAXN];int main() { ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; N; for (int i = 1; i &lt;= N; i++) { int xx, yy; cin &gt;&gt; xx &gt;&gt; yy; x[i] = a[i].x = (xx + yy); y[i] = a[i].y = (xx - yy); } sort(x+1, x+N+1); sort(y+1, y+N+1); for (int i = 1; i &lt;= N; i++) { prex[i] = prex[i-1] + x[i]; prey[i] = prey[i-1] + y[i]; } ll ans = __LONG_LONG_MAX__; for (int i = 1; i &lt;= N; i++) { ll temp; int lx = lower_bound(x+1,x+N+1,a[i].x) - x; int ly = lower_bound(y+1,y+1+N,a[i].y) - y; temp = (prex[N]-2*prex[lx]-a[i].x*(N-2*lx)) +(prey[N]-2*prey[ly]-a[i].y*(N-2*ly)); // cout &lt;&lt; &quot; list = &quot;&lt;&lt; a[i].x &lt;&lt; ' ' &lt;&lt; a[i].y &lt;&lt; ' ' &lt;&lt; temp &lt;&lt; endl; ans = min(ans, temp); } cout &lt;&lt; (ans/2); return 0;}","link":"/2020/10/11/luogu3964/"},{"title":"WHUT新生赛&quot;游记&quot;","text":"Day -N快新生赛了啊啊啊啊，半个多月没碰算法题了，一直在搞ToKen的前端任务，还在搞服务器的事，感觉要凉凉。 Day 1嗯，就只有Day1.早上起的很晚，八点半才从床上爬起来，起来之后第一件事是看我的USB-HUB发货没有!!!都好几天了，一个USB接口坏了，机械键盘没法用啊，想去买usb转type-c线的想了想还是再等等吧ε=ε=ε=┏(゜ロ゜;)┛下楼去堕落一条街吃了早饭。中午吃完饭回来买了杯奶茶丫丫精，发现喝完了有点撑得慌~~~~然后就等12.30了。比赛开始赶紧去找签到题。 A题emmmmm像是的数学题，递推，一看数据范围感觉不可做。 B题这题面稍微有点问题啊。室友就以为是按顺序组合起来的，虽然感觉仔细想想也想出来是求和的，直接DFS走了？？？不存在的，这里有个老年人sum没重置，debug一万年啊，最后才发现sum每次没有赋初值ε=ε=ε=┏(゜ロ゜;)┛ C题签到题 D题一开始没看清题意，直接while求Σa*0.1一直到不影响答案为止，算到了1e-5，第一发不知道咋WA了，两发才过。 E题博弈论，不可做 F题并查集。但是！！老年人在这里又拉胯了！！！要输出没有感染的人，我输出了一万年感染的人，交了五六发？？？ J题模拟题。 Ｈ题贪心交了一发没过，分类讨论情况可能会很多，没敢用搜索。 I题博弈论sg==就会三种博弈的蒟蒻枯了。听WHU的巨巨说记忆化搜索也能过。 J题计算几何。我认输。在线处理当成直线做的，没考虑到路程是个线段，debug一万年，最后还有半个小时封板的时候放弃了QAQ K题模拟题，我充分意识到半个小时可能写不出来了，想去debug一下J题吧 后记最后五题榜19。校内 榜二。WHU和HUST的巨巨们霸榜啊orz。 进队了orz 其实感觉中间耽误了好多时间啊，低级错误，不然可能会在开出两题，just可能。orz J题一大遗憾。也是给自己个教训吧。 至此成为WHUTer之后，又成为了ToKener，又成为了ACMer。专心训练和学习啦。逃ε=ε=ε=┏(゜ロ゜;)┛：蒟蒻 蒟蒻 蒟蒻","link":"/2019/11/16/whutacm/"},{"title":"中缀表达式求值","text":"中缀表达式求值对于表达式求值，我们通常用栈来操作。常用的做法是先转换为后缀表达式，再利用栈来求值。步骤如下： 开一个栈一个储存运算符，再开一个结构存后缀表达式，可以选择string数组 每遇到一个数字，将其加入到后缀表达式种 遇到左括号，加入到符号栈种 遇到右括号，不断将栈顶元素添加到后缀表达式中，直到遇到左括号，然后弹出左括号 遇到普通运算符，只要栈顶符号的优先级不低于新符号，就不断取出栈顶元素存到后缀表达式，然后将新符号入栈，优先级顺序为乘除&gt;加减&gt;左括号 依次取出符号栈中剩余元素，加入到后缀表达式中 将得到的后缀表达式求值 Note代码在取栈顶元素时容易出错，需要注意对栈为空时的判断 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;set&gt;#define mem(a,b) memset(a,b,sizeof(a))#define debug cout&lt;&lt;0&lt;&lt;endl#define ll long longconst int MAXN = 1e4 + 10;const int MOD = 1e9 + 7;using namespace std;stack&lt;int&gt; stnumber;stack&lt;char&gt; stsign;stack&lt;int&gt; ans;struct node { string s=&quot;&quot;;} a[MAXN];int oder(char c) { if (c == '+' || c == '-') return 1; else if (c == '*' || c == '/') return 2; return 0;}int toInt(string ss) { int res = 0; for (int i = 0; i &lt; ss.length(); i++) { res = res*10 + ss[i] - '0'; } return res;}int calc(int aa, int bb, char op) { switch (op) { case '+': return aa + bb; break; case '/': return bb / aa; break; case '*': return aa*bb; break; case '-': return bb - aa; break; default: break; }}bool isnum(char si) { if (si &lt;= '9' &amp;&amp; si &gt;= '0') return true; return false;}int cur = 0;int main() { ios::sync_with_stdio(false); cin.tie(0); int N; cin &gt;&gt; N; string s; cin &gt;&gt; s; N = s.length(); int len = 0; for (int i = 0; i &lt; N; i += len) { len = 0; if (isnum(s[i])) { string t = &quot;&quot;; for (int j = i; j &lt; N; j++) { if (isnum(s[j])) { t += s[j]; len++; } else { break; } } a[++cur].s = t; } else { if (s[i] == '(') stsign.push(s[i]); else if (s[i] == ')') { while (stsign.top() != '(') { char op = stsign.top(); stsign.pop(); a[++cur].s += op; } stsign.pop(); } else { char op = s[i]; if (!stsign.empty()) while (!stsign.empty() &amp;&amp; oder(stsign.top()) &gt;= oder(op)) { a[++cur].s += stsign.top(); stsign.pop(); //if (stsign.empty()) break; } stsign.push(op); } len = 1; } } while (!stsign.empty()) { char op = stsign.top(); stsign.pop(); a[++cur].s += op; } // for (int i = 1; i &lt;= cur; i++) { // cout &lt;&lt; a[i].s &lt;&lt; endl; // } for (int i = 1; i &lt;= cur; i++) { int temp; if (isnum(a[i].s[0])) { temp = toInt(a[i].s); ans.push(temp); } else { int aa = ans.top(); ans.pop(); int bb = ans.top(); ans.pop(); ans.push(calc(aa, bb, a[i].s[0])); } } cout &lt;&lt; ans.top(); return 0;}","link":"/2020/10/07/zhongzhui/"},{"title":"算法竞赛坑点","text":"谨以此博客总结算法竞赛中的坑点和自己的失误 恶意出题人篇 区间查询，不保证$$a \\leq b$$ 铁头憨憨篇 比赛开始的时候开题不乱开，如果很久调不出来快弃掉，说不定又是恶意出题人在卡你","link":"/2019/12/15/note/"}],"tags":[{"name":"Math","slug":"Math","link":"/tags/Math/"},{"name":"ACM","slug":"ACM","link":"/tags/ACM/"},{"name":"数论","slug":"数论","link":"/tags/%E6%95%B0%E8%AE%BA/"},{"name":"Lucas定理","slug":"Lucas定理","link":"/tags/Lucas%E5%AE%9A%E7%90%86/"},{"name":"费马小定理","slug":"费马小定理","link":"/tags/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/"},{"name":"计算几何","slug":"计算几何","link":"/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"},{"name":"莫队","slug":"莫队","link":"/tags/%E8%8E%AB%E9%98%9F/"},{"name":"游记","slug":"游记","link":"/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"Note","slug":"Note","link":"/tags/Note/"}],"categories":[{"name":"ACM","slug":"ACM","link":"/categories/ACM/"},{"name":"数论","slug":"数论","link":"/categories/%E6%95%B0%E8%AE%BA/"},{"name":"ACM","slug":"数论/ACM","link":"/categories/%E6%95%B0%E8%AE%BA/ACM/"},{"name":"Note","slug":"Note","link":"/categories/Note/"}]}