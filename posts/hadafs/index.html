<!DOCTYPE html>
<html itemscope itemtype="http://schema.org/WebPage" lang="en">
  <head>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
    <meta name="robots" content="noodp" />
    <meta name="google-site-verification" content="BgUHgNcBMb7gYvy2sM6W6KrWgBuDk4YU9eooUbig5oM" />
    <title>[FAST&#39;23] HadaFS: A File System Bridging the Local and Shared Burst Buffer for Exascale Supercomputers - Coding Panda&#39;s Blog</title><meta name="author" content="Zhiwei Zhang">
<meta name="author-link" content="https://github.com/zhiwayzhang">
<meta name="description" content="HadaFS，一个为超算提供本地和共享Burst Buffer的文件系统
0x00 Intro 现代的超算通过SSD来实现Burst Buffer（BB）layer。
根据部署位置，BB可以分为两种：
Local BB，作为本地硬盘部署在每个计算节点上，有高伸缩性和性能 Shared BB，部署在专用节点上，可以被多个计算节点访问，可以共享数据，部署成本低 HadaFS已经部署在了神威新一代超算（Sunway New- generation Supercomputer，SNS）中。支持最大600000用户，最大I/O带宽3.1TB/s。
Burst Buffer作为数据加速层，一般使用SSD。自2016年起，越来越多的超算开始使用Burst Buffer。
对于local BB，有一些局限性：
由于难以进行数据共享，Local BB不适用于所有场景，例如N-1 I/O mode，所有进程共享一个文件、workflow 由于超算程序之间的I/O负载差异较大，而数据密集型应用的比例较低，造成了大量的资源浪费 随着超算规模的扩大，local BB的部署成本未来会急剧升高 相比于Local BB，Share BB便于数据共享，部署成本低，但是在超算上部署也面临许多问题。LPCC将SSD集成到Lustre FS Client，提高read/write性能的一种缓存技术，LPCC存储在Lustre client SSD中的数据必须先刷新到Lustre server才能进行共享。BeeOND类似于LPCC，继承了BeeGFS的可伸缩性和缓存共享限制。
超算的发展使得并行I/O需求增加，BB架构相较于传统GFS有着同样的高性能，但是容量较小，因此BB要与GFS进行整合。目前的BB架构数据迁移的效率很低，浪费了很多计算资源，因此高伸缩性的BB数据管理和迁移也是目前要解决的问题。
为了解决这个问题，作者提出了BB File System&ndash;HadaFS。
基于share BB，结合了local BB的伸缩性、性能优势和share BB的数据共享、部署成本低的优点。
HadaFS提供Localized Triage Architecture（LTA）局部分类架构，解决了shared BB伸缩性不足的问题，实现了超大规模的扩展和数据共享，LTA将所有HadaFS server构建为一个共享存储池，可以在client和server之间灵活的控制并发问题，来保证数据共享。 HadaFS提出了一个运行时的user-level接口，来保证来自client的I/O请求可以被最近的server处理，类似local BB。 为了解决由POSIX接口强一致性导致的性能问题，HadaFS提出了一种包含三种元数据同步机制的全路径索引方法，来解决传统文件系统在复杂元数据的管理上的问题，以及文件系统和应用I/O行为不匹配的问题。使用KV的方法来代替传统的目录树结构。 HadaFS集成了数据管理工具，帮助用户管理BB中的数据，完成BB和GFS之间的高效数据迁移。 提出Hadash，在BB中提供高效的数据查询，加速BB和传统超算存储的数据迁移。 0x01 Motivation &amp;&amp; Bg Motivation BB可伸缩性和应用行为的矛盾 随着超算百亿亿次计算记录的打破，尖端超算中的I/O并行可以达到数十万，加大了BB在伸缩性上的压力。
目前的一些顶尖超算：
Frontier使用独立的硬件来分别构造local BB和shared BB，需要使用大量的SSD和高昂的建设维护成本。 Fugaku使用shared BB，使用软件来提供存储服务，local BB和shared BB使用不同的name space。这种方式是静态的，很难控制在高并发情况下的I/O竞态问题。 Summit部署local BB，支持数据在应用之间的共享，基于GFS，效率较低。 由于shared BB既可以用于计算节点，也可以用于数据转发节点，作者相信shared BB更适合超级计算机。" /><meta name="keywords" content='Paper, FAST, GFS, SNS, Burst Buffer, Supercomputer' /><meta itemprop="name" content="[FAST&#39;23] HadaFS: A File System Bridging the Local and Shared Burst Buffer for Exascale Supercomputers">
<meta itemprop="description" content="HadaFS，一个为超算提供本地和共享Burst Buffer的文件系统
0x00 Intro 现代的超算通过SSD来实现Burst Buffer（BB）layer。
根据部署位置，BB可以分为两种：
Local BB，作为本地硬盘部署在每个计算节点上，有高伸缩性和性能 Shared BB，部署在专用节点上，可以被多个计算节点访问，可以共享数据，部署成本低 HadaFS已经部署在了神威新一代超算（Sunway New- generation Supercomputer，SNS）中。支持最大600000用户，最大I/O带宽3.1TB/s。
Burst Buffer作为数据加速层，一般使用SSD。自2016年起，越来越多的超算开始使用Burst Buffer。
对于local BB，有一些局限性：
由于难以进行数据共享，Local BB不适用于所有场景，例如N-1 I/O mode，所有进程共享一个文件、workflow 由于超算程序之间的I/O负载差异较大，而数据密集型应用的比例较低，造成了大量的资源浪费 随着超算规模的扩大，local BB的部署成本未来会急剧升高 相比于Local BB，Share BB便于数据共享，部署成本低，但是在超算上部署也面临许多问题。LPCC将SSD集成到Lustre FS Client，提高read/write性能的一种缓存技术，LPCC存储在Lustre client SSD中的数据必须先刷新到Lustre server才能进行共享。BeeOND类似于LPCC，继承了BeeGFS的可伸缩性和缓存共享限制。
超算的发展使得并行I/O需求增加，BB架构相较于传统GFS有着同样的高性能，但是容量较小，因此BB要与GFS进行整合。目前的BB架构数据迁移的效率很低，浪费了很多计算资源，因此高伸缩性的BB数据管理和迁移也是目前要解决的问题。
为了解决这个问题，作者提出了BB File System&ndash;HadaFS。
基于share BB，结合了local BB的伸缩性、性能优势和share BB的数据共享、部署成本低的优点。
HadaFS提供Localized Triage Architecture（LTA）局部分类架构，解决了shared BB伸缩性不足的问题，实现了超大规模的扩展和数据共享，LTA将所有HadaFS server构建为一个共享存储池，可以在client和server之间灵活的控制并发问题，来保证数据共享。 HadaFS提出了一个运行时的user-level接口，来保证来自client的I/O请求可以被最近的server处理，类似local BB。 为了解决由POSIX接口强一致性导致的性能问题，HadaFS提出了一种包含三种元数据同步机制的全路径索引方法，来解决传统文件系统在复杂元数据的管理上的问题，以及文件系统和应用I/O行为不匹配的问题。使用KV的方法来代替传统的目录树结构。 HadaFS集成了数据管理工具，帮助用户管理BB中的数据，完成BB和GFS之间的高效数据迁移。 提出Hadash，在BB中提供高效的数据查询，加速BB和传统超算存储的数据迁移。 0x01 Motivation &amp;&amp; Bg Motivation BB可伸缩性和应用行为的矛盾 随着超算百亿亿次计算记录的打破，尖端超算中的I/O并行可以达到数十万，加大了BB在伸缩性上的压力。
目前的一些顶尖超算：
Frontier使用独立的硬件来分别构造local BB和shared BB，需要使用大量的SSD和高昂的建设维护成本。 Fugaku使用shared BB，使用软件来提供存储服务，local BB和shared BB使用不同的name space。这种方式是静态的，很难控制在高并发情况下的I/O竞态问题。 Summit部署local BB，支持数据在应用之间的共享，基于GFS，效率较低。 由于shared BB既可以用于计算节点，也可以用于数据转发节点，作者相信shared BB更适合超级计算机。"><meta itemprop="datePublished" content="2023-03-17T23:30:48+08:00" />
<meta itemprop="dateModified" content="2023-03-17T23:30:48+08:00" />
<meta itemprop="wordCount" content="358">
<meta itemprop="keywords" content="Paper,FAST,GFS,SNS,Burst Buffer,Supercomputer," /><meta property="og:title" content="[FAST&#39;23] HadaFS: A File System Bridging the Local and Shared Burst Buffer for Exascale Supercomputers" />
<meta property="og:description" content="HadaFS，一个为超算提供本地和共享Burst Buffer的文件系统
0x00 Intro 现代的超算通过SSD来实现Burst Buffer（BB）layer。
根据部署位置，BB可以分为两种：
Local BB，作为本地硬盘部署在每个计算节点上，有高伸缩性和性能 Shared BB，部署在专用节点上，可以被多个计算节点访问，可以共享数据，部署成本低 HadaFS已经部署在了神威新一代超算（Sunway New- generation Supercomputer，SNS）中。支持最大600000用户，最大I/O带宽3.1TB/s。
Burst Buffer作为数据加速层，一般使用SSD。自2016年起，越来越多的超算开始使用Burst Buffer。
对于local BB，有一些局限性：
由于难以进行数据共享，Local BB不适用于所有场景，例如N-1 I/O mode，所有进程共享一个文件、workflow 由于超算程序之间的I/O负载差异较大，而数据密集型应用的比例较低，造成了大量的资源浪费 随着超算规模的扩大，local BB的部署成本未来会急剧升高 相比于Local BB，Share BB便于数据共享，部署成本低，但是在超算上部署也面临许多问题。LPCC将SSD集成到Lustre FS Client，提高read/write性能的一种缓存技术，LPCC存储在Lustre client SSD中的数据必须先刷新到Lustre server才能进行共享。BeeOND类似于LPCC，继承了BeeGFS的可伸缩性和缓存共享限制。
超算的发展使得并行I/O需求增加，BB架构相较于传统GFS有着同样的高性能，但是容量较小，因此BB要与GFS进行整合。目前的BB架构数据迁移的效率很低，浪费了很多计算资源，因此高伸缩性的BB数据管理和迁移也是目前要解决的问题。
为了解决这个问题，作者提出了BB File System&ndash;HadaFS。
基于share BB，结合了local BB的伸缩性、性能优势和share BB的数据共享、部署成本低的优点。
HadaFS提供Localized Triage Architecture（LTA）局部分类架构，解决了shared BB伸缩性不足的问题，实现了超大规模的扩展和数据共享，LTA将所有HadaFS server构建为一个共享存储池，可以在client和server之间灵活的控制并发问题，来保证数据共享。 HadaFS提出了一个运行时的user-level接口，来保证来自client的I/O请求可以被最近的server处理，类似local BB。 为了解决由POSIX接口强一致性导致的性能问题，HadaFS提出了一种包含三种元数据同步机制的全路径索引方法，来解决传统文件系统在复杂元数据的管理上的问题，以及文件系统和应用I/O行为不匹配的问题。使用KV的方法来代替传统的目录树结构。 HadaFS集成了数据管理工具，帮助用户管理BB中的数据，完成BB和GFS之间的高效数据迁移。 提出Hadash，在BB中提供高效的数据查询，加速BB和传统超算存储的数据迁移。 0x01 Motivation &amp;&amp; Bg Motivation BB可伸缩性和应用行为的矛盾 随着超算百亿亿次计算记录的打破，尖端超算中的I/O并行可以达到数十万，加大了BB在伸缩性上的压力。
目前的一些顶尖超算：
Frontier使用独立的硬件来分别构造local BB和shared BB，需要使用大量的SSD和高昂的建设维护成本。 Fugaku使用shared BB，使用软件来提供存储服务，local BB和shared BB使用不同的name space。这种方式是静态的，很难控制在高并发情况下的I/O竞态问题。 Summit部署local BB，支持数据在应用之间的共享，基于GFS，效率较低。 由于shared BB既可以用于计算节点，也可以用于数据转发节点，作者相信shared BB更适合超级计算机。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhiwayzhang.github.io/posts/hadafs/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-17T23:30:48+08:00" />
<meta property="article:modified_time" content="2023-03-17T23:30:48+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="[FAST&#39;23] HadaFS: A File System Bridging the Local and Shared Burst Buffer for Exascale Supercomputers"/>
<meta name="twitter:description" content="HadaFS，一个为超算提供本地和共享Burst Buffer的文件系统
0x00 Intro 现代的超算通过SSD来实现Burst Buffer（BB）layer。
根据部署位置，BB可以分为两种：
Local BB，作为本地硬盘部署在每个计算节点上，有高伸缩性和性能 Shared BB，部署在专用节点上，可以被多个计算节点访问，可以共享数据，部署成本低 HadaFS已经部署在了神威新一代超算（Sunway New- generation Supercomputer，SNS）中。支持最大600000用户，最大I/O带宽3.1TB/s。
Burst Buffer作为数据加速层，一般使用SSD。自2016年起，越来越多的超算开始使用Burst Buffer。
对于local BB，有一些局限性：
由于难以进行数据共享，Local BB不适用于所有场景，例如N-1 I/O mode，所有进程共享一个文件、workflow 由于超算程序之间的I/O负载差异较大，而数据密集型应用的比例较低，造成了大量的资源浪费 随着超算规模的扩大，local BB的部署成本未来会急剧升高 相比于Local BB，Share BB便于数据共享，部署成本低，但是在超算上部署也面临许多问题。LPCC将SSD集成到Lustre FS Client，提高read/write性能的一种缓存技术，LPCC存储在Lustre client SSD中的数据必须先刷新到Lustre server才能进行共享。BeeOND类似于LPCC，继承了BeeGFS的可伸缩性和缓存共享限制。
超算的发展使得并行I/O需求增加，BB架构相较于传统GFS有着同样的高性能，但是容量较小，因此BB要与GFS进行整合。目前的BB架构数据迁移的效率很低，浪费了很多计算资源，因此高伸缩性的BB数据管理和迁移也是目前要解决的问题。
为了解决这个问题，作者提出了BB File System&ndash;HadaFS。
基于share BB，结合了local BB的伸缩性、性能优势和share BB的数据共享、部署成本低的优点。
HadaFS提供Localized Triage Architecture（LTA）局部分类架构，解决了shared BB伸缩性不足的问题，实现了超大规模的扩展和数据共享，LTA将所有HadaFS server构建为一个共享存储池，可以在client和server之间灵活的控制并发问题，来保证数据共享。 HadaFS提出了一个运行时的user-level接口，来保证来自client的I/O请求可以被最近的server处理，类似local BB。 为了解决由POSIX接口强一致性导致的性能问题，HadaFS提出了一种包含三种元数据同步机制的全路径索引方法，来解决传统文件系统在复杂元数据的管理上的问题，以及文件系统和应用I/O行为不匹配的问题。使用KV的方法来代替传统的目录树结构。 HadaFS集成了数据管理工具，帮助用户管理BB中的数据，完成BB和GFS之间的高效数据迁移。 提出Hadash，在BB中提供高效的数据查询，加速BB和传统超算存储的数据迁移。 0x01 Motivation &amp;&amp; Bg Motivation BB可伸缩性和应用行为的矛盾 随着超算百亿亿次计算记录的打破，尖端超算中的I/O并行可以达到数十万，加大了BB在伸缩性上的压力。
目前的一些顶尖超算：
Frontier使用独立的硬件来分别构造local BB和shared BB，需要使用大量的SSD和高昂的建设维护成本。 Fugaku使用shared BB，使用软件来提供存储服务，local BB和shared BB使用不同的name space。这种方式是静态的，很难控制在高并发情况下的I/O竞态问题。 Summit部署local BB，支持数据在应用之间的共享，基于GFS，效率较低。 由于shared BB既可以用于计算节点，也可以用于数据转发节点，作者相信shared BB更适合超级计算机。"/>
<meta name="application-name" content="FixIt">
<meta name="apple-mobile-web-app-title" content="FixIt"><meta name="theme-color" data-light="#f8f8f8" data-dark="#252627" content="#f8f8f8"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="canonical" href="https://zhiwayzhang.github.io/posts/hadafs/" /><link rel="prev" href="https://zhiwayzhang.github.io/posts/femu-bbssd/" /><link rel="next" href="https://zhiwayzhang.github.io/posts/cgroups/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "[FAST'23] HadaFS: A File System Bridging the Local and Shared Burst Buffer for Exascale Supercomputers",
    "inLanguage": "en",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https:\/\/zhiwayzhang.github.io\/posts\/hadafs\/"
    },"genre": "posts","keywords": "Paper, FAST, GFS, SNS, Burst Buffer, Supercomputer","wordcount":  358 ,
    "url": "https:\/\/zhiwayzhang.github.io\/posts\/hadafs\/","datePublished": "2023-03-17T23:30:48+08:00","dateModified": "2023-03-17T23:30:48+08:00","publisher": {
      "@type": "Organization",
      "name": ""},"author": {
        "@type": "Person",
        "name": "Zhiwei Zhang"
      },"description": ""
  }
  </script></head>
  <body data-header-desktop="sticky" data-header-mobile="auto"><script>(window.localStorage?.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('data-theme', 'dark');</script><div class="wrapper" data-page-style="normal"><header class="desktop animate__faster" id="header-desktop">
  <div class="header-wrapper">
    <div class="header-title">
      <a href="/" title="Coding Panda&#39;s Blog"><img loading="lazy" src="/img/kaifanle.gif" srcset="/img/kaifanle.gif, /img/kaifanle.gif 1.5x, /img/kaifanle.gif 2x" sizes="auto" data-title="Coding Panda&#39;s Blog" data-alt="Coding Panda&#39;s Blog" class="logo" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/><span class="header-title-text">Coding Panda&#39;s Blog</span></a><span class="header-subtitle"></span></div>
    <nav>
      <ul class="menu"><li class="menu-item">
              <a
                class="menu-link"
                href="/"
                
                
              ><i class="fa fa-home fa-fw fa-sm" aria-hidden="true"></i> Home</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/posts/"
                
                
              ><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden="true"></i> Archives</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/categories/"
                
                
              ><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden="true"></i> Categories</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/tags/"
                
                
              ><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden="true"></i> Tags</a></li><li class="menu-item delimiter"></li><li class="menu-item theme-switch" title="Switch Theme">
          <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
        </li></ul>
    </nav>
  </div>
</header><header class="mobile animate__faster" id="header-mobile">
  <div class="header-container">
    <div class="header-wrapper">
      <div class="header-title">
        <a href="/" title="Coding Panda&#39;s Blog"><img loading="lazy" src="/img/kaifanle.gif" srcset="/img/kaifanle.gif, /img/kaifanle.gif 1.5x, /img/kaifanle.gif 2x" sizes="auto" data-title="/img/kaifanle.gif" data-alt="/img/kaifanle.gif" class="logo" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/><span class="header-title-text">Coding Panda&#39;s Blog</span></a><span class="header-subtitle"></span></div>
      <div class="menu-toggle" id="menu-toggle-mobile">
        <span></span><span></span><span></span>
      </div>
    </div>
    <nav>
      <ul class="menu" id="menu-mobile"><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/"
                  
                  
                ><i class="fa fa-home fa-fw fa-sm" aria-hidden="true"></i> Home</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/posts/"
                  
                  
                ><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden="true"></i> Archives</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/categories/"
                  
                  
                ><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden="true"></i> Categories</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/tags/"
                  
                  
                ><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden="true"></i> Tags</a></li><li class="menu-item menu-system">
          <span class="menu-system-item theme-switch" title="Switch Theme"><i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i></span></li>
      </ul>
    </nav>
  </div>
</header><main class="container container-reverse"><aside class="toc" id="toc-auto"><h2 class="toc-title">Contents&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden="true"></i></h2>
      <div class="toc-content" id="toc-content-auto"></div></aside>

  <aside class="aside-custom">
    </aside>

  <article class="page single">
    <div class="header"><h1 class="single-title animate__animated animate__flipInX"><span>[FAST&#39;23] HadaFS: A File System Bridging the Local and Shared Burst Buffer for Exascale Supercomputers</span>
      </h1></div><div class="post-meta">
      <div class="post-meta-line"><span class="post-author"><a href="https://github.com/zhiwayzhang" title="Author"target="_blank" rel="external nofollow noopener noreferrer author" class="author"><img loading="lazy" src="/img/avatar.png" srcset="/img/avatar.png, /img/avatar.png 1.5x, /img/avatar.png 2x" sizes="auto" data-title="Zhiwei Zhang" data-alt="Zhiwei Zhang" class="avatar" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/>&nbsp;Zhiwei Zhang</a></span>
          <span class="post-category">included in <a href="/categories/storage/"><i class="fa-regular fa-folder fa-fw" aria-hidden="true"></i> Storage</a>&ensp;<a href="/categories/notes/"><i class="fa-regular fa-folder fa-fw" aria-hidden="true"></i> Notes</a></span></div>
      <div class="post-meta-line"><span title="published on 2023-03-17 23:30:48"><i class="fa-regular fa-calendar-alt fa-fw me-1" aria-hidden="true"></i><time datetime="2023-03-17">2023-03-17</time></span>&nbsp;<span title="Updated on 2023-03-17 23:30:48"><i class="fa-regular fa-edit fa-fw me-1" aria-hidden="true"></i><time datetime="2023-03-17">2023-03-17</time></span>&nbsp;<span><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden="true"></i>358 words</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden="true"></i>2 minutes</span>&nbsp;</div>
    </div><div class="details toc" id="toc-static" data-kept="false">
        <div class="details-summary toc-title">
          <span>Contents</span>
          <span><i class="details-icon fa-solid fa-angle-right" aria-hidden="true"></i></span>
        </div>
        <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#0x00-intro">0x00 Intro</a></li>
    <li><a href="#0x01-motivation--bg">0x01 Motivation &amp;&amp; Bg</a>
      <ul>
        <li><a href="#motivation">Motivation</a>
          <ul>
            <li><a href="#bb可伸缩性和应用行为的矛盾">BB可伸缩性和应用行为的矛盾</a></li>
            <li><a href="#复杂元数据管理与应用行为的不匹配">复杂元数据管理与应用行为的不匹配</a></li>
            <li><a href="#低效的数据管理">低效的数据管理</a></li>
          </ul>
        </li>
        <li><a href="#bg-神威超算架构">Bg-神威超算架构</a></li>
      </ul>
    </li>
    <li><a href="#0x02-design">0x02 Design</a>
      <ul>
        <li><a href="#overview">Overview</a></li>
        <li><a href="#lta-localized-triage-architecture">LTA (Localized Triage Architecture)</a></li>
        <li><a href="#namespace--metadata-handing">Namespace &amp;&amp; metadata handing</a></li>
        <li><a href="#hadafs-io-control--data-flow">HadaFS I/O Control &amp;&amp; Data Flow</a></li>
        <li><a href="#data-management-tool">Data Management Tool</a></li>
        <li><a href="#hadafs优化">HadaFS优化</a>
          <ul>
            <li><a href="#持久化语义和元数据优化">持久化语义和元数据优化</a></li>
            <li><a href="#优化共享文件">优化共享文件</a></li>
            <li><a href="#避免干扰">避免干扰</a></li>
          </ul>
        </li>
        <li><a href="#超算中的hadafs">超算中的HadaFS</a></li>
      </ul>
    </li>
    <li><a href="#0x03-evaluation">0x03 Evaluation</a>
      <ul>
        <li><a href="#数据转发性能">数据转发性能</a></li>
        <li><a href="#元数据访问性能">元数据访问性能</a></li>
        <li><a href="#数据访问性能">数据访问性能</a></li>
        <li><a href="#数据迁移性能">数据迁移性能</a></li>
        <li><a href="#io干扰">I/O干扰</a></li>
      </ul>
    </li>
    <li><a href="#0x04-conclusion">0x04 Conclusion</a></li>
  </ul>
</nav></div>
      </div><div class="content" id="content"><p>HadaFS，一个为超算提供本地和共享Burst Buffer的文件系统</p>
<h1 id="0x00-intro">0x00 Intro</h1>
<p>现代的超算通过SSD来实现Burst Buffer（BB）layer。</p>
<p>根据部署位置，BB可以分为两种：</p>
<ul>
<li>Local BB，作为本地硬盘部署在每个计算节点上，有高伸缩性和性能</li>
<li>Shared BB，部署在专用节点上，可以被多个计算节点访问，可以共享数据，部署成本低</li>
</ul>
<p>HadaFS已经部署在了神威新一代超算（Sunway New- generation Supercomputer，SNS）中。支持最大600000用户，最大I/O带宽3.1TB/s。</p>
<p>Burst Buffer作为数据加速层，一般使用SSD。自2016年起，越来越多的超算开始使用Burst Buffer。</p>
<p>对于local BB，有一些局限性：</p>
<ol>
<li>由于难以进行数据共享，Local BB不适用于所有场景，例如N-1 I/O mode，所有进程共享一个文件、workflow</li>
<li>由于超算程序之间的I/O负载差异较大，而数据密集型应用的比例较低，造成了大量的资源浪费</li>
<li>随着超算规模的扩大，local BB的部署成本未来会急剧升高</li>
</ol>
<p>相比于Local BB，Share BB便于数据共享，部署成本低，但是在超算上部署也面临许多问题。LPCC将SSD集成到Lustre FS Client，提高read/write性能的一种缓存技术，LPCC存储在Lustre client SSD中的数据必须先刷新到Lustre server才能进行共享。BeeOND类似于LPCC，继承了BeeGFS的可伸缩性和缓存共享限制。</p>
<p>超算的发展使得并行I/O需求增加，BB架构相较于传统GFS有着同样的高性能，但是容量较小，因此BB要与GFS进行整合。目前的BB架构数据迁移的效率很低，浪费了很多计算资源，因此高伸缩性的BB数据管理和迁移也是目前要解决的问题。</p>
<p>为了解决这个问题，作者提出了BB File System&ndash;HadaFS。</p>
<p>基于share BB，结合了local BB的伸缩性、性能优势和share BB的数据共享、部署成本低的优点。</p>
<ol>
<li>HadaFS提供Localized Triage Architecture（LTA）局部分类架构，解决了shared BB伸缩性不足的问题，实现了超大规模的扩展和数据共享，LTA将所有HadaFS server构建为一个共享存储池，可以在client和server之间灵活的控制并发问题，来保证数据共享。</li>
<li>HadaFS提出了一个运行时的user-level接口，来保证来自client的I/O请求可以被最近的server处理，类似local BB。</li>
<li>为了解决由POSIX接口强一致性导致的性能问题，HadaFS提出了一种包含三种元数据同步机制的全路径索引方法，来解决传统文件系统在复杂元数据的管理上的问题，以及文件系统和应用I/O行为不匹配的问题。使用KV的方法来代替传统的目录树结构。</li>
<li>HadaFS集成了数据管理工具，帮助用户管理BB中的数据，完成BB和GFS之间的高效数据迁移。</li>
<li>提出Hadash，在BB中提供高效的数据查询，加速BB和传统超算存储的数据迁移。</li>
</ol>
<h1 id="0x01-motivation--bg">0x01 Motivation &amp;&amp; Bg</h1>
<h2 id="motivation">Motivation</h2>
<h3 id="bb可伸缩性和应用行为的矛盾">BB可伸缩性和应用行为的矛盾</h3>
<p>随着超算百亿亿次计算记录的打破，尖端超算中的I/O并行可以达到数十万，加大了BB在伸缩性上的压力。</p>
<p>目前的一些顶尖超算：</p>
<ul>
<li>Frontier使用独立的硬件来分别构造local BB和shared BB，需要使用大量的SSD和高昂的建设维护成本。</li>
<li>Fugaku使用shared BB，使用软件来提供存储服务，local BB和shared BB使用不同的name space。这种方式是静态的，很难控制在高并发情况下的I/O竞态问题。</li>
<li>Summit部署local BB，支持数据在应用之间的共享，基于GFS，效率较低。</li>
</ul>
<p>由于shared BB既可以用于计算节点，也可以用于数据转发节点，作者相信shared BB更适合超级计算机。</p>
<h3 id="复杂元数据管理与应用行为的不匹配">复杂元数据管理与应用行为的不匹配</h3>
<p>传统的文件系统需要考虑兼容性，因此严格遵循POSIX协议。超算中，计算节点普遍使用read/write，执行目录树访问的次数较少。</p>
<p>因此减轻对POSIX的实现成为很多文件系统的优化方向。由于应用程序的种类很多，如何减少POSIX接口面临巨大挑战。</p>
<p>Wang等人分析了一些HPC应用的行为，整理了几种一致性语义，如下表Table 1</p>
<p><img loading="lazy" src="/img/image-20230322160638470.png" srcset="/img/image-20230322160638470.png, /img/image-20230322160638470.png 1.5x, /img/image-20230322160638470.png 2x" sizes="auto" data-title="image-20230322160638470" data-alt="image-20230322160638470" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<ul>
<li>Strong consistency</li>
<li>Commit consistency</li>
<li>Session consistency</li>
<li>Eventual consistency</li>
</ul>
<p>系统支持的一致性等级越高，系统的适应性越强。也就是说，当一个系统能够保证数据在不同节点之间保持一致，那么它就能更好地适应不同的应用场景和需求。</p>
<p>需要灵活地选择合适的一致性语义来平衡需求和BB系统的性能。</p>
<h3 id="低效的数据管理">低效的数据管理</h3>
<p>虽然使用BB加速了I/O，但是BB的利用率很低。</p>
<p>BB仅用于I/O的加速，并不永久的存储数据，同时BB的容量相较于GFS很小，因此要考虑BB和GFS之间高效的数据传输。</p>
<p>BB和GFS之间的数据迁移/传输有两种：</p>
<ul>
<li>透明迁移，软件自动以blocks或者file的形式将BB中的数据迁移到GFS，造成了大量不必要的数据传输</li>
<li>非透明迁移，计算节点来实现数据迁移，导致计算资源在数据迁移时产生空闲。</li>
</ul>
<p>这两种数据传输方式都会异步地提前将数据从GFS加载到BB，以达到预取的目的。</p>
<p>然而他们都不能支持用户在程序运行时动态的管理BB数据迁移，不利于提高BB的利用率。</p>
<h2 id="bg-神威超算架构">Bg-神威超算架构</h2>
<p>SNS神威超算的架构图如下</p>
<p><img loading="lazy" src="/img/image-20230322164156234.png" srcset="/img/image-20230322164156234.png, /img/image-20230322164156234.png 1.5x, /img/image-20230322164156234.png 2x" sizes="auto" data-title="image-20230322164156234" data-alt="image-20230322164156234" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>每个计算节点包含一个神威多核处理器SW26010P（自研），采用多种架构，有6个Core Groups，390个计算核心。通过环网相连接。</p>
<p>整个系统有超过100000个SW26010P处理器，通过一种Fat-tree 网络 SWnet连接。</p>
<p>计算节点与I/O转发节点连接，I/O转发节点提供I/O请求的转发或存储介质。</p>
<p>SNS使用类似太湖之光的软件架构（LWFS+Lustre），通过独立的存储网络来链接存储节点，以提供I/O请求转发。</p>
<p>当提供存储服务时，SNS使用HadaFS，I/O转发节点作为HadaFS的server，使用NVMe SSD来处理用户的I/O。</p>
<p><strong>我个人感觉，Burst Buffer就类似于I/O栈中的Page Cache，HadaFS处理的就是Buffer I/O。</strong></p>
<h1 id="0x02-design">0x02 Design</h1>
<h2 id="overview">Overview</h2>
<p>下图为HadaFS的架构，包括HadaFS client，HadaFS server和数据管理工具。</p>
<p><img loading="lazy" src="/img/image-20230322170237986.png" srcset="/img/image-20230322170237986.png, /img/image-20230322170237986.png 1.5x, /img/image-20230322170237986.png 2x" sizes="auto" data-title="image-20230322170237986" data-alt="image-20230322170237986" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>HadaFS作为shared BB文件系统，提供所有client的global view。</p>
<p>HadaFS Client运行于计算节点，并提供静态/动态链接库，用于拦截并转发应用程序的POSIX I/O请求到HadaFS Server，HadaFS client的生命周期取决于应用程序。</p>
<p>HadaFS不支持move，rename，link操作，这些操作很少在并行系统中使用。</p>
<p>HadaFS Server运行于Burst Buffer节点，包含NVMe SSD，提供全局的数据和元数据存储服务。</p>
<p>在HadaFS中，每个文件与两种服务器有关。</p>
<ol>
<li>数据存储服务器：通过NVMe SSD上的基本文件系统存储HadaFS文件数据。</li>
<li>元数据存储服务器：通过高性能的数据库存储HadaFS文件的元数据（使用RocksDB）。</li>
</ol>
<p>Hadash是数据管理工具，运行于用户登录节点，用于管理HadaFS和GFS之间的数据迁移。</p>
<h2 id="lta-localized-triage-architecture">LTA (Localized Triage Architecture)</h2>
<p>kernel在实现完整POSIX接口和处理I/O时有较大的开销，kernel bypass是一种常用手段。</p>
<p>在高并发的情况下，kernel bypass可能会导致服务不稳定。</p>
<p>例如，计算节点有24CPU核心，所有的进程只需要进行一次挂载就可以访问运行于kernel mode的文件系统client。相反，每个进程需要在用户层挂载一个文件系统client。两种方法各有优点和局限性，HadaFS通过LTA将两种优点进行整合。</p>
<p>HadaFS直接挂载Client到应用，实现kernel bypass。</p>
<p>为了防止单个server处理的FS client过多，HadaFS采用每个client只连接一个server的方法。</p>
<p>对于一个HadaFS client，与之相连的HadaFS server被称为bridge server，bridge server负责处理client的所有I/O请求，并根据client I/O request的offset和size写入数据到文件。每个文件对应在bridge server ext4 文件系统中的一个独立文件。当client需要访问其他服务器的数据时，文件必须通过bridge server转发。</p>
<p>如果一个bridge server的空间已满，所有的client将自动切换到其他server。</p>
<p>为了保证大部分I/O请求在bridge server中处理并减少转发的次数，HadaFS提出了<code>mount(mount_point, Seq)</code>接口来允许应用在必要时（<strong>自己选择bridge server有优势时</strong>）控制bridge server的选择。</p>
<ul>
<li>mount_point表示挂载点，在HadaFS中这是一个文件路径的前缀</li>
<li>Seq可以根据<strong>应用数据共享模式</strong>、<strong>网络拓扑</strong>、<strong>适应应用程序数据和系统架构并行性的其他因素</strong>来灵活设置。Seq有三种类型：
<ul>
<li>应用程序<code>MPI_RANK</code>，client将会按照轮询的方式连接server。适用于应用被多次提交到不同的计算节点的情况，来保证每个应用可以准确连接到原先的bridge server，减少数据转发。</li>
<li>计算节点ID，用于匹配计算节点和BB节点的拓扑结构，保证计算节点可以将数据存储到网络中最近的BB节点。</li>
<li>根据应用数据分发和共享需要设置，每个client可以显示指定要连接的server，应用可以通过灵活的控制client到server的映射改善数据访问的效率</li>
</ul>
</li>
</ul>
<p>LTA通过bridge server作为local BB，还实现了shared BB的功能（数据共享）。</p>
<p>mount_point，Seq可以通过环境变量设置，因此，HadaFS可以通过在应用程序开始之前加载HadaFS lib以提前读取环境变量来支持用户的透明挂载。</p>
<p>为了充分利用HadaFS的高性能，尤其是read性能，建议用户执行实现client-to-server的映射关系，减少数据转发。在挂载HadaFS之后，应用可以直接调用POSIX文件接口来实现I/O。</p>
<h2 id="namespace--metadata-handing">Namespace &amp;&amp; metadata handing</h2>
<p>为了改善伸缩性和性能，HadaFS不使用目录树的索引机制，使用类似CHFS和Vesta的full-path索引。</p>
<p>对一个HadaFS文件，其数据保存在client中的bridge server，元数据存储位置由路径的hash决定。</p>
<p>文件的元数据以KV的方式存储，每个文件路径都有全局唯一的ID作为key。</p>
<p>HadaFS client直接通过文件绝对路径的前缀来检查文件是否符合要求。</p>
<p>当多个文件需要访问，负载可以分发到多个服务器，改善元数据访问的性能。</p>
<p>HadaFS的元数据兼容Linux的权限结构，包括name，ino，owner，mode，timestamp等。HadaFS将这些信息分成四类：</p>
<ol>
<li>维护文件的创建信息，name，owner，mode等</li>
<li>维护文件的访问信息，file size，modification time，access time等</li>
<li>❌因为使用全局唯一ID，HadaFS不需要维护，ino，stdev等信息</li>
<li>文件分段的位置信息，是一个有序链表，链表通过offset排序，每个元素包括server name，fragment offset，size，writing time等信息</li>
</ol>
<p>HadaFS server维护两种元数据数据库，数据结构如下图：</p>
<p><img loading="lazy" src="/img/image-20230322200851411.png" srcset="/img/image-20230322200851411.png, /img/image-20230322200851411.png 1.5x, /img/image-20230322200851411.png 2x" sizes="auto" data-title="image-20230322200851411" data-alt="image-20230322200851411" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>一个数据库为Local Metadata Database LMDB，保存第一和第四种元数据类别，文件的local id（LIB）是文件的本地路径。</p>
<p>另一种为Global Metadata Database，保存第一、二、四种元数据（第三种不需要维护），HadaFS文件的元数据存储在唯一的GMDB，通过文件的全路径hash索引。</p>
<p>两种数据库基于RocksDB，该数据库不支持多线程写，但这并不是性能瓶颈。</p>
<p>两种元数据库的Key构造包含：用户的UID、GID、PATH，GID和UID用于前缀字符串检索。</p>
<p>对于多对多N-N I/O模式，每个client写入到独立的file，并且存储在LMDB的元数据和存储在GMDB的第一、四类元数据匹配。</p>
<p>对于多对一N-1I/O模式，多个client需要共享一个文件，可能使用不同的HadaFS bridge server，这时，GMDB负责从多个LMDB合并文件的元数据。</p>
<p>在文件read/write时，LMDB记录文件元数据的改变，维护一个包含本地数据段位置信息的有序链表，并将数据发送到相应的GMDB。GMDB负责维护全局的文件数据段链表，来保证全局的数据共享。</p>
<h2 id="hadafs-io-control--data-flow">HadaFS I/O Control &amp;&amp; Data Flow</h2>
<p>介绍HadaFS种的控制流和数据流。下图展示了3个HadaFS Client和3个server的关系。</p>
<p><img loading="lazy" src="/img/image-20230322204336470.png" srcset="/img/image-20230322204336470.png, /img/image-20230322204336470.png 1.5x, /img/image-20230322204336470.png 2x" sizes="auto" data-title="image-20230322204336470" data-alt="image-20230322204336470" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<ul>
<li>Client A发起I/O请求，创建文件F1并写入100MB数据。数据将会直接写入Client A的Bridge server：X</li>
<li>Server X写入F1文件的元数据信息和位置信息到LMDB</li>
<li>基于F1的文件路径，处理好F1的元数据信息。Server X写入F1文件的元数据信息和位置信息到Server Y上的GMDB。</li>
<li>Client C发起读取文件F1的I/O请求</li>
<li>Client C的Bridge Server Z接受I/O请求，从Server Y根据F1的路径获取F1的元数据和位置信息</li>
<li>Server Z从Server X读取数据，并转发到Client C</li>
</ul>
<p>对于局部写和全局读是有利的，尤其是对于需要频繁输出检查点的应用。</p>
<p>对于读敏感的应用可以自行维护client到bridge server的映射表，减少数据转发，通过mount接口实现高性能。</p>
<p>HadaFS除了限制了每个server连接的client数量，减少了性能抖动，还为存储系统充分支持应用程序的并行性奠定了基础。</p>
<h2 id="data-management-tool">Data Management Tool</h2>
<p>现有的BB方案，例如LPCC，可能会导致迁移大量的临时数据。Datawarp要求应用程序在其源代码或脚本中指定BB和GFS之间的迁移，这通常是一种静态迁移方法，并要求计算节点参与迁移。</p>
<p>HadaFS中，用户使用Hadash以目录树的视图来获取和管理文件，视图根据功能分为两类，元数据信息查询和数据迁移。</p>
<p>元数据信息查询提供如下指令：ls，du，find，grep等。ls和find可以在目录树视图查询文件信息。Hadash从metadata-数据库获取信息，并以Linux shell中常用的命令的形式展示这些信息。</p>
<p>其他触发数据迁移的指令，例如rm、get、put等，Hadash通过Redis pipeline发送指令到HadaFS server中的数据管理模块，然后每个HadaFS server的数据管理模块使用LMDB处理本地数据请求，并行地执行这些指令。</p>
<blockquote>
<p>Redis Pipeline就是一组Redis命令的组装，避免频繁的执行命令的Request/Response，类似事务的概念，还可以使用Lua脚本实现类似的功能。</p>
</blockquote>
<p>下图是从HadaFS到GFS进行数据迁移的控制流。</p>
<p><img loading="lazy" src="/img/image-20230323103315198.png" srcset="/img/image-20230323103315198.png, /img/image-20230323103315198.png 1.5x, /img/image-20230323103315198.png 2x" sizes="auto" data-title="image-20230323103315198" data-alt="image-20230323103315198" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<ol>
<li>用户通过UI发起数据管理指令到Hadash server</li>
<li>Hadash Server接收并转发指令到BB节点的所有Hadash代理</li>
<li>Hadash代理解析指令，通过LMDB获取文件相应的链表信息，在本地SSD读取文件</li>
<li>最终，Hadash代理写入这些文件到GFS</li>
</ol>
<p>当所有的文件写入完成时，Hadash代理通过另一个Redis Pipeline返回success，Hadash将通知用户迁移已经完成。</p>
<p>如果将要被迁移文件正持续追加写入，Hadash将持续拷贝新写入的数据，类似于Linux默认的数据拷贝机制cp。</p>
<p>Hadash使用前缀匹配方法来展示目录树，可以直接通过LMDB本地执行，减少了对GMDB的影响。</p>
<p>Hadash使用分布式管理方法来实现数据的本地化管理。该方式主要的瓶颈在GFS，性能根据BB节点的数量增长。</p>
<h2 id="hadafs优化">HadaFS优化</h2>
<h3 id="持久化语义和元数据优化">持久化语义和元数据优化</h3>
<p>HadaFS采用宽松的持久化语义，不支持在client和server中缓存数据，而是基于ext4文件系统缓存机制，持久化语义取决于元数据的同步。</p>
<p>HadaFS为不同的应用场景提出了三种元数据的同步机制，避免出现传统文件系统复杂的设计。</p>
<ol>
<li>mode 1:异步地更新所有元数据（eventual consistency），在文件的打开、删除、读写期间，所有的操作都先在bridge server本地执行，然后元数据将被异步从LMDB更新到GMDB。该模式的性能最高，相当于为计算节点提供本地存储，适用于没有数据依赖性的场景</li>
<li>mode 2:同步地更新部分元数据，异步地更新另一部分元数据（session/commit consistency semantics）。第一类元数据（name，owner）将在文件被创建时同步地更新。第二类元数据（file size，modify time）将在文件读写时被异步地进行更新，或通过flush操作同步地更新。该模式为默认方式，可以平衡读写文件读写的性能</li>
<li>mode 3:在所有的open、read、write操作时同步元数据（strong consistency semantics，HadaFS不支持覆盖写）。所有的server要先获取文件位置来保证第一类元数据的同步，诸如open、write、read、flush的操作需要同步第二类元数据</li>
</ol>
<p>HadaFS使用全路径索引和bridge server，不需要分布式锁，对于使用N-N I/O的应用，不会产生数据冲突，然而对于N-1写模式，HadaFS需要先将数据写入到每个Bridge Server，因此不支持覆盖写，原子写只在mode 3中支持。</p>
<h3 id="优化共享文件">优化共享文件</h3>
<p>LTA架构适合N-N I/O模型，对于N-1 I/O模型，HadaFS使用类似ADIOS BP的文件布局。先将数据写入到独立的bridge server，再由GMDB维护文件的元数据（BP group index）。一个共享的文件可以存储在多个服务器中，read/write可以被转换成并发的read/write。</p>
<p>HadaFS以文件的形式存储数据，因此可能会产生碎片。例如，100000个进程并发地写同一个文件，每个进程写入6次，在完全随机的情况下可能产生600000个文件碎片。HadaFS使用一个根据offset排序的链表，合并相同bridge server相邻的段位置信息。读写时的段插入和获取操作时间复杂度为LogN，N为文件段的数量。</p>
<p>所有的元数据同步机制支持N-1模式，元数据只存储在GMDB中。</p>
<h3 id="避免干扰">避免干扰</h3>
<p>超算中不同的任务之间存在资源竞争，造成I/O干扰。HadaFS中主要是由于不同的client共享一个server，可以通过用户自行决定连接的server，改善该问题。</p>
<p>HadaFS还提供了自动调节工具，通过监控系统来优化I/O，自动指定连接的BB资源，设置环境变量，选择合适的元数据同步机制，达到隔离BB资源的目的。</p>
<h2 id="超算中的hadafs">超算中的HadaFS</h2>
<p>HadaFS已经在SNS中部署了一年多，下图为HadaFS的部署架构图。</p>
<p><img loading="lazy" src="/img/image-20230323151800866.png" srcset="/img/image-20230323151800866.png, /img/image-20230323151800866.png 1.5x, /img/image-20230323151800866.png 2x" sizes="auto" data-title="image-20230323151800866" data-alt="image-20230323151800866" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>每个I/O转发节点有两个HadaFS server，每个HadaFS server使用一个NVMe SSD来支持文件数据的存储和元数据（LMDB、GMDB）。</p>
<p>容错的代价是很高的，应用会周期性写入检查点来减少数据恢复的开销，如果一个BB节点失效，只要SSD没有损坏，HadaFS就可以恢复，为了减少数据恢复的成本，HadaFS周期性地备份关键数据到GFS，在HadaFS部署的一年多时间里，总共产生了15次BB节点的失效，其中没有SSD的故障。</p>
<h1 id="0x03-evaluation">0x03 Evaluation</h1>
<h2 id="数据转发性能">数据转发性能</h2>
<p><img loading="lazy" src="/img/image-20230323223311503.png" srcset="/img/image-20230323223311503.png, /img/image-20230323223311503.png 1.5x, /img/image-20230323223311503.png 2x" sizes="auto" data-title="image-20230323223311503" data-alt="image-20230323223311503" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>对于大气科学研究模型NEMO，HadaFS性能如下，说明了对于需要共享文件的程序，HadaFS可以提升其吞吐量。</p>
<p><img loading="lazy" src="/img/image-20230323223349489.png" srcset="/img/image-20230323223349489.png, /img/image-20230323223349489.png 1.5x, /img/image-20230323223349489.png 2x" sizes="auto" data-title="image-20230323223349489" data-alt="image-20230323223349489" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<h2 id="元数据访问性能">元数据访问性能</h2>
<p>MDTest</p>
<p>Client-Server比例为256:1</p>
<p>竞品为BeeGFS，配置与Hada相同，GFS使用132 OSS和4 MDS</p>
<p>测试了Create/Stat/Remove操作的OPS</p>
<p>BeeGFS由于集群管理服务的限制不能达到65536进程</p>
<p><img loading="lazy" src="/img/image-20230323224828257.png" srcset="/img/image-20230323224828257.png, /img/image-20230323224828257.png 1.5x, /img/image-20230323224828257.png 2x" sizes="auto" data-title="image-20230323224828257" data-alt="image-20230323224828257" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<h2 id="数据访问性能">数据访问性能</h2>
<p>IOR测试I/O带宽</p>
<p>竞品为BeeGFS和GFS，配置同metadata测试</p>
<p>BeeGFS和mode1、mode2性能相当，但是不能达到65536进程数</p>
<p><img loading="lazy" src="/img/image-20230323225137305.png" srcset="/img/image-20230323225137305.png, /img/image-20230323225137305.png 1.5x, /img/image-20230323225137305.png 2x" sizes="auto" data-title="image-20230323225137305" data-alt="image-20230323225137305" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<p>使用VPIC-I/O和BD-CATS-I/O测试共享文件的读写访问性能</p>
<p>HadaFS和BeeGFS使用16个服务器，可以看出低进程情况下二者性能相当，但是BeeGFS的伸缩性较差，HadaFS通过LTA来避免I/O冲突。</p>
<p><img loading="lazy" src="/img/image-20230323225545079.png" srcset="/img/image-20230323225545079.png, /img/image-20230323225545079.png 1.5x, /img/image-20230323225545079.png 2x" sizes="auto" data-title="image-20230323225545079" data-alt="image-20230323225545079" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<h2 id="数据迁移性能">数据迁移性能</h2>
<p>HadaFS使用256台服务器</p>
<p>Datawarp使用4096进程</p>
<p>随着文件大小和数量的增加，HadaFS的性能逐渐优于Datawarp</p>
<p><img loading="lazy" src="/img/image-20230323230150281.png" srcset="/img/image-20230323230150281.png, /img/image-20230323230150281.png 1.5x, /img/image-20230323230150281.png 2x" sizes="auto" data-title="image-20230323230150281" data-alt="image-20230323230150281" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<h2 id="io干扰">I/O干扰</h2>
<p>使用五种程序进行测试：</p>
<ul>
<li>DNDC：农业生态系统的生物地球化学程序</li>
<li>CAM：气候模拟、全球大气模型</li>
<li>Shentu：高伸缩性图引擎</li>
<li>WRF：天气预测系统</li>
<li>APT：动态粒子仿真程序</li>
</ul>
<p>下图深色色块代表程序速度降低的指数，每一行代表左侧的应用受到下放程序的影响</p>
<p>由于可以灵活的选择与client连接的server，可以避免一定的I/O干扰</p>
<p><img loading="lazy" src="/img/image-20230323230453622.png" srcset="/img/image-20230323230453622.png, /img/image-20230323230453622.png 1.5x, /img/image-20230323230453622.png 2x" sizes="auto" data-title="image-20230323230453622" data-alt="image-20230323230453622" style="background: url(/svg/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['style','data-title','data-alt','onerror','onload']){this.removeAttribute(a);}"/></p>
<h1 id="0x04-conclusion">0x04 Conclusion</h1>
<p>HadaFS已经用于新一代的神威超算中，基于Shared Burst Buffer，使应用既可以单点访问BB，也可以通过HadaFS实现对文件同时进行读写，并实现了高性能。</p>
</div><div class="post-footer" id="post-footer">
  <div class="post-info">
    <div class="post-info-line">
      <div class="post-info-mod">
        <span title="Updated on 2023-03-17 23:30:48">Updated on 2023-03-17&nbsp;</span>
      </div><div class="post-info-license">
          <span><a rel="license external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span>
        </div></div>
    <div class="post-info-line">
      <div class="post-info-md"></div>
      <div class="post-info-share">
        <span><a href="javascript:void(0);" title="Share on Twitter" data-sharer="twitter" data-url="https://zhiwayzhang.github.io/posts/hadafs/" data-title="[FAST&#39;23] HadaFS: A File System Bridging the Local and Shared Burst Buffer for Exascale Supercomputers" data-hashtags="Paper,FAST,GFS,SNS,Burst Buffer,Supercomputer"><i class="fa-brands fa-twitter fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="Share on Facebook" data-sharer="facebook" data-url="https://zhiwayzhang.github.io/posts/hadafs/" data-hashtag="Paper"><i class="fa-brands fa-facebook-square fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="Share on 微博" data-sharer="weibo" data-url="https://zhiwayzhang.github.io/posts/hadafs/" data-title="[FAST&#39;23] HadaFS: A File System Bridging the Local and Shared Burst Buffer for Exascale Supercomputers"><i class="fa-brands fa-weibo fa-fw" aria-hidden="true"></i></a>
  </span>
      </div>
    </div>
  </div>

  <div class="post-info-more">
    <section class="post-tags"><i class="fa-solid fa-tags fa-fw me-1" aria-hidden="true"></i><a href='/tags/paper/' class="post-tag">Paper</a><a href='/tags/fast/' class="post-tag">FAST</a><a href='/tags/gfs/' class="post-tag">GFS</a><a href='/tags/sns/' class="post-tag">SNS</a><a href='/tags/burst-buffer/' class="post-tag">Burst Buffer</a><a href='/tags/supercomputer/' class="post-tag">Supercomputer</a></section>
    <section>
      <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
    </section>
  </div>

  <div class="post-nav"><a href="/posts/femu-bbssd/" class="post-nav-item" rel="prev" title="[FEMU] FEMU Blackbox SSD源码阅读"><i class="fa-solid fa-angle-left fa-fw" aria-hidden="true"></i>[FEMU] FEMU Blackbox SSD源码阅读</a>
      <a href="/posts/cgroups/" class="post-nav-item" rel="next" title="Using Cgroups v2 to limit system I/O resources">Using Cgroups v2 to limit system I/O resources<i class="fa-solid fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article></main><footer class="footer">
    <div class="footer-container"><div class="footer-line powered">Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow noopener noreferrer" title="Hugo 0.119.0">Hugo</a> | Theme - <a href="https://github.com/hugo-fixit/FixIt" target="_blank" rel="external" title="FixIt %!v(MISSING)">FixIt</a>
        </div><div class="footer-line copyright" itemscope itemtype="http://schema.org/CreativeWork"><i class="fa-regular fa-copyright fa-fw" aria-hidden="true"></i>
            <span itemprop="copyrightYear">2019 - 2023</span><span class="author" itemprop="copyrightHolder">
              <a href="https://github.com/zhiwayzhang"target="_blank" rel="external nofollow noopener noreferrer">Zhiwei Zhang</a></span></div><div class="footer-line statistics"></div></div>
  </footer></div><div class="widgets"><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role="button" aria-label="Back to Top"><i class="fa-solid fa-arrow-up fa-fw" aria-hidden="true"></i><span class="variant-numeric d-none">0%</span>
        </div></div><div id="mask"></div><noscript>
    <div class="noscript-warning">Theme FixIt works best with JavaScript enabled.</div>
  </noscript>
</div><link rel="stylesheet" href="/lib/katex/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/styles/github-dark.min.css"><script src="/lib/sharer/sharer.min.js" async defer></script><script src="/lib/katex/katex.min.js" defer></script><script src="/lib/katex/auto-render.min.js" defer></script><script src="/lib/katex/mhchem.min.js" defer></script><script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/highlight.min.js" defer></script><script>window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":100},"comment":{"enable":false},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false}};</script><script src="/js/theme.min.js" defer></script></body>
</html>
