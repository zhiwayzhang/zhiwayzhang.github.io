<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Note on Coding_Panda&#39;s Blog</title>
        <link>https://blog.ipandai.club/categories/note/</link>
        <description>Recent content in Note on Coding_Panda&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Sat, 05 Mar 2022 10:32:46 +0000</lastBuildDate><atom:link href="https://blog.ipandai.club/categories/note/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>计算机网络自顶向下</title>
        <link>https://blog.ipandai.club/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/</link>
        <pubDate>Sat, 05 Mar 2022 10:32:46 +0000</pubDate>
        
        <guid>https://blog.ipandai.club/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/</guid>
        <description>&lt;h1 id=&#34;dns&#34;&gt;DNS&lt;/h1&gt;
&lt;p&gt;使用UDP 53端口&lt;/p&gt;
&lt;h2 id=&#34;多路复用和多路分解&#34;&gt;多路复用和多路分解&lt;/h2&gt;
&lt;h2 id=&#34;无连接运输udp&#34;&gt;无连接运输UDP&lt;/h2&gt;
&lt;p&gt;UDP无需建立连接，速度快&lt;/p&gt;
&lt;p&gt;无连接状态，不需要维护序列号，可以支持更多用户活跃（游戏服务器）&lt;/p&gt;
&lt;p&gt;首部只有8个字节，源端口号和目的端口号，长度和check sum&lt;/p&gt;
&lt;p&gt;为什么需要checksum校验和：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在路由器内存中可能有bit差错&lt;/li&gt;
&lt;li&gt;链路传输不可靠&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;checksum最终为1111111&amp;hellip;则可能无差错&lt;/p&gt;
&lt;p&gt;端到端原则：某种功能应该在较高级别提供，在较低级别上设置该功能可能会冗余&lt;/p&gt;
&lt;p&gt;UDP只能检查错误，不能纠错&lt;/p&gt;
&lt;p&gt;DNS服务采用UDP&lt;/p&gt;
&lt;p&gt;何时UDP，何时TCP？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不希望延迟报文的发送，TCP有拥塞控制机制，并容忍数据的丢失&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;可靠数据传输&#34;&gt;可靠数据传输&lt;/h2&gt;
&lt;p&gt;差错检测&lt;/p&gt;
&lt;p&gt;接收方反馈：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ACK肯定确认&lt;/li&gt;
&lt;li&gt;NAK否定确认&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ACK 0接收成功，ACK 1接收失败&lt;/p&gt;
&lt;p&gt;重传，收方发现差错，发送方重传&lt;/p&gt;
&lt;p&gt;序号，检测哪个数据包出错进行重传&lt;/p&gt;
&lt;p&gt;数据包可靠传输：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在没有ack的情况下，等待一定的时间后进行重传&lt;/li&gt;
&lt;li&gt;序号可以保证传输不冗余（接收方检测是否冗余）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;发送方需要实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没发送或者重传一个分组，启动定时器countdown timer&lt;/li&gt;
&lt;li&gt;定时器过期后响应&lt;/li&gt;
&lt;li&gt;终止定时器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;流水线可靠传输协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;采用极小的数据包，接收方收到最后一bit立即ack&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;gbn协议回退n步滑动窗口协议&#34;&gt;GBN协议（回退N步），滑动窗口协议&lt;/h2&gt;
&lt;p&gt;限制数据包的序号，直到相应序号ack之后再发送后续的序号，用长度为N的窗口控制。&lt;/p&gt;
&lt;p&gt;GBN发送方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送数据包时，检查发送窗口，未满则返回未发送的分组&lt;/li&gt;
&lt;li&gt;收到ack后，对分组中的序号累积确认，表明接收方，正确接收到序号为n的分组以及以前的所有分组，&lt;code&gt;[0, N]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;超时，发送方重传所有未被确认的分组&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接收方收到的分组都是有序的，如果出现无序，会丢弃后面的数据包，等待重传&lt;/p&gt;
&lt;h2 id=&#34;选择重传&#34;&gt;选择重传&lt;/h2&gt;
&lt;p&gt;避免不必要的重传&lt;/p&gt;
&lt;p&gt;发送方接收方都维护一个窗口&lt;/p&gt;
&lt;p&gt;发送方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;收到send base后窗口右移到第一个没确认的分组处&lt;/li&gt;
&lt;li&gt;接收ack将窗口内分组标记为ack&lt;/li&gt;
&lt;li&gt;定时器防止分组丢失&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接收方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接收的分组落在窗口内，返回ack&lt;/li&gt;
&lt;li&gt;如果序号不连续，直接缓存&lt;/li&gt;
&lt;li&gt;如果分组序号等于&lt;code&gt;rcv_base&lt;/code&gt;将从rcv base开始的已缓存分组交付给上层，窗口移动&lt;/li&gt;
&lt;li&gt;序号落在窗口之外，&lt;code&gt;[rcv_base-N, rcv_base-1]&lt;/code&gt;上一个窗口中，返回ack&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;窗口长度不能太大&lt;/p&gt;
&lt;h2 id=&#34;tcp&#34;&gt;TCP&lt;/h2&gt;
&lt;p&gt;运行与端系统中，路由器等视角下看到的是数据报&lt;/p&gt;
&lt;p&gt;全双工&lt;/p&gt;
&lt;p&gt;socket是对tcp协议的封装&lt;/p&gt;
&lt;h3 id=&#34;流量控制&#34;&gt;流量控制&lt;/h3&gt;
&lt;p&gt;每一方都设置接收缓存，数据先放在缓存中，应用程序从缓存中读取数据。&lt;/p&gt;
&lt;p&gt;目的是消除发送方使接收方缓存溢出的可能。匹配发送方和接收方的读写速率。&lt;/p&gt;
&lt;p&gt;收发各自维护接收窗口。保存接收方还有多少缓存空间rwnd。&lt;/p&gt;
&lt;p&gt;发送方维持为确认的数据量在rwnd之内。&lt;/p&gt;
&lt;p&gt;如果剩余空间为0，发送方发送只有一个字节的报文。&lt;/p&gt;
&lt;p&gt;UDP没有流量控制，因此可能会出现缓冲区溢出。&lt;/p&gt;
&lt;h3 id=&#34;三次握手&#34;&gt;三次握手&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;客户端发送SYN=1，随机选择一个序列号seq=x&lt;/li&gt;
&lt;li&gt;服务器读取该报文，为tcp连接分配资源，对客户端发送SYN=1，ack=x+1，seq=y（随机选取）&lt;/li&gt;
&lt;li&gt;客户端为该连接分配资源（缓存和变量），发送SYN=0，ack=y+1，seq=x+1&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么三次？
确保双方的收发能力都是正常的最小次数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;握手能不能携带数据？
第一二次握手不能携带数据，第三次握手可以携带数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;四次挥手&#34;&gt;四次挥手&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;客户端发送FIN=1&lt;/li&gt;
&lt;li&gt;服务器响应ACK&lt;/li&gt;
&lt;li&gt;服务器发送FIN=1&lt;/li&gt;
&lt;li&gt;客户端发挥ACK&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;拥塞控制&#34;&gt;拥塞控制&lt;/h3&gt;
&lt;p&gt;丢包的原因？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网络堵塞后，路由器缓存溢出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;慢启动&lt;/li&gt;
&lt;li&gt;快速重传&lt;/li&gt;
&lt;li&gt;拥塞避免&lt;/li&gt;
&lt;li&gt;快速恢复&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Go语言学习笔记</title>
        <link>https://blog.ipandai.club/p/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Tue, 25 Jan 2022 20:14:16 +0000</pubDate>
        
        <guid>https://blog.ipandai.club/p/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
        <description>&lt;p&gt;Go语言源码阅读与原理分析&lt;/p&gt;
&lt;h1 id=&#34;go的编译&#34;&gt;Go的编译&lt;/h1&gt;
&lt;h1 id=&#34;数据结构&#34;&gt;数据结构&lt;/h1&gt;
&lt;h2 id=&#34;数组&#34;&gt;数组&lt;/h2&gt;
&lt;p&gt;声明&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;语法糖&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;第二种编译器会进行转换成第一种&lt;/p&gt;
&lt;p&gt;上限推导&lt;/p&gt;
&lt;p&gt;语句转换&lt;/p&gt;
&lt;p&gt;由字面量（具体整数，浮点数，字符串）组成的数组，根据长度进行优化&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;元素数量&lt;code&gt;&amp;lt;=&lt;/code&gt;4，元素放在栈上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;4时，元素保存在静态区，运行时取出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;元素数量&lt;code&gt;&amp;lt;=&lt;/code&gt;4时，简化为赋值表达式&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;arr&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;review&#34;&gt;review&lt;/h3&gt;
&lt;p&gt;编译之后的二进制文件包含：栈，堆，数据段，代码段&lt;/p&gt;
&lt;p&gt;堆栈为动态区域，数据段和代码段为静态区域&lt;/p&gt;
&lt;p&gt;栈：编译器自动分配释放，存放参数值，局部变量等&lt;/p&gt;
&lt;p&gt;堆：程序动态申请的内存，malloc，用链表实现&lt;/p&gt;
&lt;p&gt;代码区：函数体的二进制代码&lt;/p&gt;
&lt;p&gt;数据段：包含&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;只读数据段 const&lt;/li&gt;
&lt;li&gt;已初始化的读写数据段 初始化的全局变量，初始化的静态局部变量static&lt;/li&gt;
&lt;li&gt;未初始化段 未初始化的全局变量和静态变量&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当数组元素个数大于四个时&lt;/p&gt;
&lt;p&gt;获取一个唯一的staticname，在静态存储区进行初始化，之后再拷贝到栈上&lt;/p&gt;
&lt;p&gt;访问和赋值&lt;/p&gt;
&lt;p&gt;编译器的静态类型检查时检测数组越界，索引是否为非负整数，索引越界&lt;/p&gt;
&lt;p&gt;使用变量作为索引时，无法编译检查，需要&lt;strong&gt;运行时&lt;/strong&gt;阻止，出发panic&lt;/p&gt;
&lt;p&gt;发现数组切片字符串越界时通过运行时的&lt;code&gt;runtime.panicIndex&lt;/code&gt;和&lt;code&gt;runtime.goPanicIndex&lt;/code&gt;触发panic&lt;/p&gt;
&lt;p&gt;下标没有越界时，编译器获取数组的内存地址和访问下标，计算出目标地址，使用Load将元素加载到内存中&lt;/p&gt;
&lt;p&gt;编译时插入运行时越界检查函数&lt;/p&gt;
&lt;p&gt;赋值时先确定目标元素地址，使用Store指令将数据存入地址，在编译阶段而不是运行时&lt;/p&gt;
&lt;h1 id=&#34;切片&#34;&gt;切片&lt;/h1&gt;
&lt;p&gt;编译时确定类型，存储在Extra字段&lt;/p&gt;
&lt;p&gt;数据结构&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;nx&#34;&gt;Data&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;Len&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;Cap&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;切片只在运行时确定内容&lt;/p&gt;
&lt;h2 id=&#34;初始化&#34;&gt;初始化&lt;/h2&gt;
&lt;h3 id=&#34;切片slicelr&#34;&gt;切片&lt;code&gt;slice[l:r]&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;调用SliceMake函数，参数为 元素类型，数组指针，切片大小和容量&lt;/p&gt;
&lt;p&gt;这样初始化的切片创建了指向原切片的结构体&lt;/p&gt;
&lt;h3 id=&#34;字面量&#34;&gt;字面量&lt;/h3&gt;
&lt;p&gt;编译时：&lt;/p&gt;
&lt;p&gt;对字面量数组做大小推断，初始化为数组&lt;/p&gt;
&lt;p&gt;创建一个数组指针，指向静态数组&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;[:]&lt;/code&gt;通过指针创建切片&lt;/p&gt;
&lt;h3 id=&#34;make&#34;&gt;make&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;make([]int, len, cap)&lt;/code&gt;
会做参数校验，&lt;code&gt;cap &amp;gt;= len&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;判断切片大小和容量是否足够&lt;/li&gt;
&lt;li&gt;切片是否发生了逃逸，最终在堆上初始化&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;切片太大时也会在堆上初始化，使用运行时makeslice&lt;/p&gt;
&lt;p&gt;makeslice会在堆上申请连续的内存&lt;/p&gt;
&lt;p&gt;可能的运行时错误：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;内存空间大小发生了溢出&lt;/li&gt;
&lt;li&gt;申请内存大于最大可分配内存&lt;/li&gt;
&lt;li&gt;传入的&lt;code&gt;len&amp;lt;0 or len &amp;gt; cap&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;访问&#34;&gt;访问&lt;/h3&gt;
&lt;p&gt;对len和cap的访问会在编译时替换为常量&lt;/p&gt;
&lt;p&gt;使用index获取元素会直接转换为对地址的访问&lt;/p&gt;
&lt;h3 id=&#34;append和扩容&#34;&gt;append和扩容&lt;/h3&gt;
&lt;p&gt;如果append之后&lt;strong&gt;不需要&lt;/strong&gt;赋值给原有变量：&lt;/p&gt;
&lt;p&gt;判断append之后的大小和容量触发扩容&lt;/p&gt;
&lt;p&gt;如果append之后&lt;strong&gt;需要&lt;/strong&gt;赋值给原有变量：&lt;/p&gt;
&lt;p&gt;append后的切片覆盖原切片，编译器优化为不发生拷贝，直接操作原切片&lt;/p&gt;
&lt;h4 id=&#34;growslice&#34;&gt;growslice&lt;/h4&gt;
&lt;p&gt;先确定新切片容量，扩容策略：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果期望容量大于当前的两倍，就会使用期望容量&lt;/li&gt;
&lt;li&gt;当前切片长度小于1024会将容量翻倍&lt;/li&gt;
&lt;li&gt;如果当前的切片长度大于1024每次增加25%的容量，直到新容量大于期望容量&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;扩容之后进行内存对齐，提高内存分配效率，减少碎片&lt;/p&gt;
&lt;p&gt;使用预制的内存大小数组向上取整，然后通过该内存大小重新计算cap&lt;/p&gt;
&lt;p&gt;对于非指针切片，将原数组内容拷贝至新内存&lt;/p&gt;
&lt;p&gt;growslice返回的是一个新的切片，都是新的 slice(p, len, newcap)&lt;/p&gt;
&lt;h2 id=&#34;copy&#34;&gt;copy&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;copy(a,b)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;编译时会直接使用memmove拷贝到内存&lt;/p&gt;
&lt;p&gt;运行时会直接进行合法性检查&lt;/p&gt;
&lt;p&gt;大切片性能开销比较大&lt;/p&gt;
&lt;h1 id=&#34;哈希&#34;&gt;哈希&lt;/h1&gt;
&lt;h2 id=&#34;解决冲突&#34;&gt;解决冲突&lt;/h2&gt;
&lt;h3 id=&#34;开放寻址&#34;&gt;开放寻址&lt;/h3&gt;
&lt;p&gt;从index处向后寻找空闲位置，读取会从index处向后匹配相等元素&lt;/p&gt;
&lt;p&gt;&lt;code&gt;装载因子=元素数量/数组大小&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;装载因子增大，线性探测法的平均用时增加，最坏到On&lt;/p&gt;
&lt;h3 id=&#34;拉链法&#34;&gt;拉链法&lt;/h3&gt;
&lt;p&gt;使用链表数组，每个数组是一个桶，通过index访问&lt;/p&gt;
&lt;p&gt;&lt;code&gt;装载因子=元素数量/桶数量&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;一般情况下不超过1，装载因子太大会触发扩容&lt;/p&gt;
&lt;h2 id=&#34;struct&#34;&gt;struct&lt;/h2&gt;
&lt;p&gt;runtime hmap&lt;/p&gt;
&lt;p&gt;保存对数，桶的数量都是2的倍数&lt;/p&gt;
&lt;p&gt;包含runtime bmap，能存储8个键值对，超过8个时会使用extra.nextOverflow中的溢出桶存&lt;/p&gt;
&lt;p&gt;bmap中存储key哈希的高八位tophash uint8&lt;/p&gt;
&lt;h2 id=&#34;初始化-1&#34;&gt;初始化&lt;/h2&gt;
&lt;h3 id=&#34;字面量-1&#34;&gt;字面量&lt;/h3&gt;
&lt;p&gt;当哈希表的元素&lt;code&gt;&amp;lt;=25&lt;/code&gt;个时，将初始化转化为&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;nx&#34;&gt;hash&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;s&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;s&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;to&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;hash&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;hash&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;hash&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;超过时会转换为两个切片循环加入hash&lt;/p&gt;
&lt;h3 id=&#34;运行时&#34;&gt;运行时&lt;/h3&gt;
&lt;p&gt;当桶的数量小于$2^4$，不创建溢出桶&lt;/p&gt;
&lt;p&gt;否则创建$2^{B-4}$个溢出桶&lt;/p&gt;
&lt;h2 id=&#34;读写&#34;&gt;读写&lt;/h2&gt;
&lt;p&gt;遍历使用for range&lt;/p&gt;
&lt;p&gt;删除&lt;code&gt;delete(hash, key)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;bmap的实际存储是tophash为一个连续的空间，keys，values 。。。&lt;/p&gt;
&lt;p&gt;访问时限获取哈希值，再获取哈希的高8位&lt;/p&gt;
&lt;p&gt;通过哈希的最低几位获取桶序号&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里因为哈希计算出来并不在桶范围内，在二进制中体现出来是取高几位和低几位，低几位就是取模之后的值，因此可以有效避免桶中有大量重复tophash&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在bmap中先比较哈希高8位，加速访问&lt;/p&gt;
&lt;p&gt;匹配成功会根据指针和偏移量获取key进行比较，匹配成功再获取value&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;尽量使用双值接收结果，防止实际的value是nil&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;写入时会遍历正常桶和溢出桶，溢出桶也包含tophash&lt;/p&gt;
&lt;p&gt;如果桶满，创建新的桶护着在溢出桶中保存&lt;/p&gt;
&lt;p&gt;获取存储地址后，将值拷贝到内存&lt;/p&gt;
&lt;h3 id=&#34;扩容&#34;&gt;扩容&lt;/h3&gt;
&lt;p&gt;在写入时，触发扩容&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;装载因子超过6.5&lt;/li&gt;
&lt;li&gt;哈希使用了太多溢出桶，容易产生内存泄露&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;扩容非原子过程，扩容前判断是否正在扩容&lt;/p&gt;
&lt;p&gt;溢出桶太多触发等量扩容，新桶保存数据，回收旧桶（大量的写入删除操作）&lt;/p&gt;
&lt;p&gt;翻倍扩容，随着写操作增量进行，不会产生性能的巨大抖动，创建一组新桶和溢出桶，将原来的桶组设置到oldbuckets，溢出桶也设置到oldoverflow上&lt;/p&gt;
&lt;p&gt;数据迁移发生在运行时 evacuate，对传入桶的元素再分配，每个旧桶元素分流到两个新桶&lt;/p&gt;
&lt;p&gt;分流逻辑：原来通过取模得到的桶掩码为&lt;code&gt;0b11&lt;/code&gt;，扩容翻倍之后将变为&lt;code&gt;0b111&lt;/code&gt;，因此该数据被分流到3号和7号桶&lt;/p&gt;
&lt;p&gt;当旧桶完全被分流后清除oldbuckets和oldoverflow，通过计数器控制&lt;/p&gt;
&lt;p&gt;扩容期间访问时，若oldbuckets存在，并且旧桶没有被分流时会先去旧桶寻找&lt;/p&gt;
&lt;p&gt;扩容期间写入赋值时，会触发增量拷贝，向新桶分流&lt;/p&gt;
&lt;h2 id=&#34;删除&#34;&gt;删除&lt;/h2&gt;
&lt;p&gt;扩容期间删除，会分流桶中的元素，然后找到桶中的目标键值对删除&lt;/p&gt;
&lt;p&gt;与写入类似&lt;/p&gt;
&lt;p&gt;访问，写入删除都是运行时处理&lt;/p&gt;
&lt;h1 id=&#34;字符串&#34;&gt;字符串&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;只读&lt;/strong&gt;的字节数组，使用连续空间&lt;/p&gt;
&lt;p&gt;data和len&lt;/p&gt;
&lt;p&gt;分配在只读的内存空间，修改需要和&lt;code&gt;[]byte&lt;/code&gt;相互转换&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;拷贝内存到栈或者堆&lt;/li&gt;
&lt;li&gt;将变量修改为&lt;code&gt;[]byte&lt;/code&gt;然后修改字节数据&lt;/li&gt;
&lt;li&gt;修改字节数组转回&lt;code&gt;string&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;nx&#34;&gt;str&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;hello\&amp;#34;&amp;#34;&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;str&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;`
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;{
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;    &amp;#34;name&amp;#34; : &amp;#34;panda&amp;#34;,
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;    &amp;#34;tags&amp;#34; : [&amp;#34;panda&amp;#34;]
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;}
&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;`&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;赋值时使用scanner解析字符串成token流&lt;/p&gt;
&lt;p&gt;&lt;code&gt;strconv.Unquote&lt;/code&gt;去除引号&lt;/p&gt;
&lt;p&gt;使用+拼接，拼接字符串的数量小于等于五个时，使用concatstring{2,3,4,5}，否则使用runtime.concatstrings，传入数组切片，最终通过运行时过滤空字符串计算拼接后长度，如果非空字符串数量为1，并且不在栈上，则直接返回&lt;/p&gt;
&lt;p&gt;拷贝到目标地址空间&lt;/p&gt;
&lt;p&gt;类型转换有性能损失，需要拷贝数据&lt;/p&gt;
&lt;h1 id=&#34;函数调用&#34;&gt;函数调用&lt;/h1&gt;
&lt;p&gt;c语言使用寄存器传参数，小于等于六个时使用寄存器，大于6个的参数使用栈传递，使用寄存器传递返回值，并且只使用一个寄存器，因此只能有一个返回值。&lt;/p&gt;
&lt;p&gt;go语言使用栈传递参数和返回值，因此存在性能损失，但是可以支持多返回值，便于维护编译器，不需要考虑寄存器数量和命名。&lt;/p&gt;
&lt;h2 id=&#34;参数传递方式&#34;&gt;参数传递方式&lt;/h2&gt;
&lt;p&gt;传值，基本类型，结构体，指针，对参数进行拷贝&lt;/p&gt;</description>
        </item>
        <item>
        <title>Mysql学习笔记</title>
        <link>https://blog.ipandai.club/p/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Mon, 17 Jan 2022 23:16:08 +0000</pubDate>
        
        <guid>https://blog.ipandai.club/p/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
        <description>&lt;h1 id=&#34;基础知识&#34;&gt;基础知识&lt;/h1&gt;
&lt;p&gt;单进程多线程，线程之间共享内存&lt;/p&gt;
&lt;p&gt;OLTP Online Transaction Processing 在线事务处理&lt;/p&gt;
&lt;h1 id=&#34;innodb&#34;&gt;InnoDB&lt;/h1&gt;
&lt;h2 id=&#34;overview&#34;&gt;overview&lt;/h2&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;行级锁&lt;/li&gt;
&lt;li&gt;支持外键&lt;/li&gt;
&lt;li&gt;支持事务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MVCC并发控制，插入缓冲，二次写，自适应哈希索引，预读&lt;/p&gt;
&lt;p&gt;四种隔离级别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;REPEATABLE 默认&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;聚集方式保存数据，按主键顺序存放，没有主键则生成6字节的ROWID&lt;/p&gt;
&lt;h2 id=&#34;后台线程&#34;&gt;后台线程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Master Thread 缓冲区数据异步更新到磁盘&lt;/li&gt;
&lt;li&gt;IO Thread innodb使用异步IO，提高数据库性能，负责接受回调&lt;/li&gt;
&lt;li&gt;Purge Thread 事务提交后回收undolog页&lt;/li&gt;
&lt;li&gt;Page Cleaner Thread 脏页刷新&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;主要都是为了减轻Master的负担，提高性能，减少对用户查询线程的阻塞&lt;/p&gt;
&lt;h2 id=&#34;内存&#34;&gt;内存&lt;/h2&gt;
&lt;p&gt;用页管理记录&lt;/p&gt;
&lt;p&gt;缓冲池：通过内存来弥补低速硬盘的影响，数据库读取页，从磁盘获取页放入缓冲池&lt;code&gt;fix&lt;/code&gt;，读取时先判断缓冲区，命中后直接读取；修改时先修改缓冲池的页，然后通过checkpoint机制刷新到磁盘上。基本上和虚拟内存一样。&lt;/p&gt;
&lt;p&gt;配置参数&lt;code&gt;innodb_buffer_pool_size&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;数据页分类：索引页，数据页，undo页，插入缓冲，自适应哈希索引，innodb锁信息，数据字典信息等&lt;/p&gt;
&lt;p&gt;允许有多个缓冲池&lt;/p&gt;
&lt;h3 id=&#34;内存管理&#34;&gt;内存管理&lt;/h3&gt;
&lt;h4 id=&#34;lru-list&#34;&gt;LRU List&lt;/h4&gt;
&lt;p&gt;频繁使用的在列表前，不频繁的在列表后，先释放尾部的页&lt;/p&gt;
&lt;p&gt;页默认大小16KB&lt;/p&gt;
&lt;p&gt;innodb会把新读取的页放入midpoint位置，为列表长度的$$\frac{5}{8}$$，midpoint之后为old，之前为new，如果放在首部会导致某些sql导致缓冲池页被刷新，如全表扫描遍历全表。防止一条指令拖慢其他指令效率。&lt;/p&gt;
&lt;p&gt;Free列表保存空闲页&lt;/p&gt;
&lt;h1 id=&#34;myisam&#34;&gt;MyISAM&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;表锁&lt;/li&gt;
&lt;li&gt;全文索引&lt;/li&gt;
&lt;li&gt;不支持事务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缓冲区只缓存索引文件，不缓冲数据&lt;/p&gt;
&lt;p&gt;MYD保存数据，MYI保存索引文件&lt;/p&gt;
&lt;p&gt;myisampack使用Huffman编码压缩MYD，压缩后只读&lt;/p&gt;
</description>
        </item>
        <item>
        <title>图解HTTP读书笔记</title>
        <link>https://blog.ipandai.club/p/%E5%9B%BE%E8%A7%A3http%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Sun, 16 Jan 2022 22:25:00 +0000</pubDate>
        
        <guid>https://blog.ipandai.club/p/%E5%9B%BE%E8%A7%A3http%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
        <description>&lt;p&gt;图解HTTP读书笔记&lt;/p&gt;
&lt;h1 id=&#34;web及网络基础&#34;&gt;Web及网络基础&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;HTTP/0.9&lt;/code&gt; 不是http的正式标准，临时版本&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HTTP/1.0&lt;/code&gt; RFC1945&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HTTP/1.1&lt;/code&gt; 目前应用较广 RFC2616&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HTTP/2.0&lt;/code&gt; 大幅提高了web性能&lt;/p&gt;
&lt;h2 id=&#34;tcpip&#34;&gt;TCP/IP&lt;/h2&gt;
&lt;p&gt;互联网运行与TCP IP协议族之上，HTTP包含于其中&lt;/p&gt;
&lt;p&gt;ip，dns，udp，ftp，http，tcp。。。&lt;/p&gt;
&lt;p&gt;TCP/IP的分层管理&lt;/p&gt;
&lt;p&gt;应用层：决定了向用户提供服务时通信的活动，ftp，dns，http&lt;/p&gt;
&lt;p&gt;传输层：对应用层提供连接的两台计算机的数据传输，TCP Transmission Control Protocol传输控制协议和UDP User Data Protocol用户数据报协议&lt;/p&gt;
&lt;p&gt;网络层：处理网络上的数据包，数据包是网络传输的最小数据单位，规定如何传输路线，传输数据包&lt;/p&gt;
&lt;p&gt;数据链路层：处理连接网络的硬件，网络适配器NIC网卡&lt;/p&gt;
&lt;p&gt;物理层&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;层次化好处：1.设计好接口，每个层次内部的设计可以自由改动 2.使设计变得更简单，应用层上的应用不需要考虑接收方的地理位置等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;iptcpdns&#34;&gt;IP、TCP、DNS&lt;/h2&gt;
&lt;h3 id=&#34;ip&#34;&gt;IP&lt;/h3&gt;
&lt;p&gt;IP协议位于网络层&lt;/p&gt;
&lt;p&gt;mac地址为网卡的固定地址，使用ARP协议（address resolution Protocol地址解析协议）凭借mac地址进行通信，解析ip到mac地址&lt;/p&gt;
&lt;p&gt;选择传输路线叫做路由选择&lt;/p&gt;
&lt;h3 id=&#34;tcp协议的可靠性&#34;&gt;TCP协议的可靠性&lt;/h3&gt;
&lt;p&gt;位于传输层&lt;/p&gt;
&lt;p&gt;将大数据块分割为报文段segment确保传输准确可靠&lt;/p&gt;
&lt;p&gt;将请求报文按照序号分为多个报文段，将每个报文段可靠的传输，收到后再根据序列号重组报文&lt;/p&gt;
&lt;p&gt;确保数据可到达：&lt;/p&gt;
&lt;p&gt;三次握手three way handshaking&lt;/p&gt;
&lt;p&gt;TCP标志 SYN synchronize和ACK acknowledgement&lt;/p&gt;
&lt;p&gt;具体过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送端发送一个带有SYN标志的数据包&lt;/li&gt;
&lt;li&gt;接收端收到后回传带有SYN/ACK标志的数据包&lt;/li&gt;
&lt;li&gt;发送端传回带有ACK标志的数据包，握手结束&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果握手中的某个阶段中断，TCP协议会再次发送相同的数据包&lt;/p&gt;
&lt;h3 id=&#34;dns&#34;&gt;DNS&lt;/h3&gt;
&lt;p&gt;域名解析&lt;/p&gt;
&lt;h2 id=&#34;uri和url&#34;&gt;URI和URL&lt;/h2&gt;
&lt;p&gt;URL是URI的子集&lt;/p&gt;
&lt;h1 id=&#34;http协议&#34;&gt;HTTP协议&lt;/h1&gt;
&lt;p&gt;http是无状态协议&lt;/p&gt;
&lt;p&gt;使用cookie管理状态&lt;/p&gt;
&lt;p&gt;使用URI定位资源&lt;/p&gt;
&lt;p&gt;持久连接：任意一端未提出断开，则保持tcp连接状态，减少tcp连接重复建立和断开的开销&lt;/p&gt;
&lt;p&gt;HTTP 1.1中，所有连接默认为持久连接&lt;/p&gt;
&lt;p&gt;pipeline技术：连续发送请求，不必等待上一个请求返回&lt;/p&gt;
&lt;h2 id=&#34;cookie&#34;&gt;Cookie&lt;/h2&gt;
&lt;p&gt;服务器响应报文中Set-Cookie header字段，告知客户端保存&lt;/p&gt;
&lt;p&gt;客户端再次请求时自动在header中加入cookie&lt;/p&gt;
&lt;h1 id=&#34;http报文&#34;&gt;HTTP报文&lt;/h1&gt;
&lt;p&gt;换行符CR+LF，CR回车符&lt;code&gt;0x0d&lt;/code&gt;，LF换行符&lt;code&gt;0x0a&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;header + CR+LF + Body&lt;/p&gt;
&lt;p&gt;报文message是通信基本单位，8位组字节流&lt;/p&gt;
&lt;p&gt;实体entity 请求或响应的在和，包含实体header和实体body&lt;/p&gt;
&lt;p&gt;传输过程中可以对实体进行压缩&lt;/p&gt;
&lt;p&gt;实体可以分割传输&lt;/p&gt;
&lt;h2 id=&#34;获取部分内容的请求&#34;&gt;获取部分内容的请求&lt;/h2&gt;
&lt;p&gt;传输中断的恢复机制&lt;/p&gt;
&lt;p&gt;在header中加Range&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Range: bytes= 1-5000&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;断点续传&lt;/p&gt;
&lt;h1 id=&#34;http状态码&#34;&gt;HTTP状态码&lt;/h1&gt;
&lt;p&gt;1XX，正在处理 信息性状态
2XX，处理完毕 成功
3XX，重定向状态码
4XX，客户端错误状态码
5XX，服务器错误状态码&lt;/p&gt;
&lt;p&gt;200 OK&lt;/p&gt;
&lt;p&gt;HEAD方法不会返回body&lt;/p&gt;
&lt;p&gt;204 No Content 处理成功，但是response中不包含实体&lt;/p&gt;
&lt;p&gt;206 Partial Content 客户端进行了范围请求&lt;/p&gt;
&lt;p&gt;301 Moved Permanently 永久重定向，资源分配了新的URI&lt;/p&gt;
&lt;p&gt;302 Found 临时重定向&lt;/p&gt;
&lt;p&gt;303 See Other 客户端用GET，临时重定向（比如POST访问时返回303，需要改GET方法重定向到另一个URI）&lt;/p&gt;
&lt;p&gt;304 Not modified 我有你要的资源但是不让你访问&lt;/p&gt;
&lt;p&gt;307 Temporary Redirect 临时重定向&lt;/p&gt;
&lt;p&gt;400 Bad request&lt;/p&gt;
&lt;p&gt;401 Unauthorized&lt;/p&gt;
&lt;p&gt;403 Forbidden 不允许访问&lt;/p&gt;
&lt;p&gt;404 Not Found 找不到资源&lt;/p&gt;
&lt;p&gt;500 Internal Server Error 内部错误&lt;/p&gt;
&lt;p&gt;503 Service Unavailable 服务器超负荷&lt;/p&gt;
&lt;h1 id=&#34;web服务器&#34;&gt;Web服务器&lt;/h1&gt;
&lt;h2 id=&#34;虚拟主机&#34;&gt;虚拟主机&lt;/h2&gt;
&lt;p&gt;一台服务器可以绑定多个域名&lt;/p&gt;
&lt;p&gt;通过dns解析&lt;/p&gt;
&lt;h2 id=&#34;代理-网关-隧道&#34;&gt;代理 网关 隧道&lt;/h2&gt;
&lt;h3 id=&#34;代理&#34;&gt;代理&lt;/h3&gt;
&lt;p&gt;转发中间人&lt;/p&gt;
&lt;p&gt;每次转发会追加写入via首部&lt;/p&gt;
&lt;p&gt;代理服务功能：缓存技术，访问控制，获取日志&lt;/p&gt;
&lt;p&gt;缓存代理：将资源缓存在代理服务器上，不从原服务器获取（有点像redis&lt;/p&gt;
&lt;p&gt;透明代理：转发请求和响应，不添加其他内容&lt;/p&gt;
&lt;h3 id=&#34;网关&#34;&gt;网关&lt;/h3&gt;
&lt;p&gt;转发客户端请求到实际程序&lt;/p&gt;
&lt;p&gt;网关与服务器使用非http通信&lt;/p&gt;
&lt;h3 id=&#34;隧道&#34;&gt;隧道&lt;/h3&gt;
&lt;p&gt;在客户端和服务器直接中转，保持双方的通信连接&lt;/p&gt;
&lt;p&gt;本身不解析http请求，只传输&lt;/p&gt;
&lt;h2 id=&#34;缓存&#34;&gt;缓存&lt;/h2&gt;
&lt;p&gt;客户端缓存和服务器缓存&lt;/p&gt;
&lt;p&gt;客户端缓存存储在浏览器&lt;/p&gt;
&lt;p&gt;各种header的作用&lt;/p&gt;
&lt;h2 id=&#34;cookie相关header&#34;&gt;Cookie相关header&lt;/h2&gt;
&lt;p&gt;Set-Cookie: 后跟name=value的序列&lt;/p&gt;
&lt;p&gt;Cookie: 发送cookie&lt;/p&gt;
&lt;h1 id=&#34;https&#34;&gt;HTTPS&lt;/h1&gt;
&lt;p&gt;http缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;明文被窃听&lt;/li&gt;
&lt;li&gt;不验证双方身份，可伪装&lt;/li&gt;
&lt;li&gt;无法验证完整性，可以篡改&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用SSL secure socket layer或TLS transport layer security安全层传输协议&lt;/p&gt;
&lt;p&gt;SSL使用证书确定身份&lt;/p&gt;
&lt;p&gt;防止篡改：使用md5或sha-1等校验方法校验报文完整性&lt;/p&gt;
&lt;p&gt;HTTP+通信加密+证书+完整性保护&lt;/p&gt;
&lt;p&gt;通信接口部分用ssl和tls协议代替&lt;/p&gt;
&lt;p&gt;http先和ssl通信，ssl再和tcp通信&lt;/p&gt;
&lt;p&gt;非对称加密 公钥进行加密，私钥进行解密&lt;/p&gt;
&lt;h2 id=&#34;通信步骤&#34;&gt;通信步骤&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;客户端发送client hello开始ssl通信&lt;/li&gt;
&lt;li&gt;服务器响应server hello&lt;/li&gt;
&lt;li&gt;服务器发送certificate报文，包含公钥证书&lt;/li&gt;
&lt;li&gt;服务器发送server hello done&lt;/li&gt;
&lt;li&gt;客户端发送client key exchange报文响应，ssl握手部分结束&lt;/li&gt;
&lt;li&gt;客户端发送change cipher spec&lt;/li&gt;
&lt;li&gt;客户端发送finished&lt;/li&gt;
&lt;li&gt;服务器发送change cipher spec&lt;/li&gt;
&lt;li&gt;ssl连接建立成功，开始进行http请求&lt;/li&gt;
&lt;/ol&gt;</description>
        </item>
        <item>
        <title>redis实战读书笔记</title>
        <link>https://blog.ipandai.club/p/redis%E5%AE%9E%E6%88%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Mon, 03 Jan 2022 16:22:27 +0000</pubDate>
        
        <guid>https://blog.ipandai.club/p/redis%E5%AE%9E%E6%88%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
        <description>&lt;p&gt;redis基础知识以及一些应用场景总结&lt;/p&gt;
&lt;h1 id=&#34;基础&#34;&gt;基础&lt;/h1&gt;
&lt;p&gt;内存数据库&lt;/p&gt;
&lt;p&gt;优于memcached，速度上功能上&lt;/p&gt;
&lt;p&gt;基础数据结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;String，List，Set，Hash，ZSet&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://redis.io/commands&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;redis命令手册&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;string&#34;&gt;String&lt;/h2&gt;
&lt;p&gt;key-value&lt;/p&gt;
&lt;p&gt;指令GET，SET，DEL&lt;/p&gt;
&lt;h2 id=&#34;list&#34;&gt;LIST&lt;/h2&gt;
&lt;p&gt;key-list&lt;/p&gt;
&lt;p&gt;指令&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LPUSH，RPUSH 推入列表的左端和右端
LPUSH listname item
返回值为列表长度&lt;/li&gt;
&lt;li&gt;LPOP，RPOP，从左端和右端删除元素&lt;/li&gt;
&lt;li&gt;LINDEX，获取列表指定位置的元素
LINDEX listname 1&lt;/li&gt;
&lt;li&gt;LRANGE，获取给定范围内的所有元素
LRANGE listname 0 -1
0为开始索引，-1位结束索引&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;set&#34;&gt;SET&lt;/h2&gt;
&lt;p&gt;key-set&lt;/p&gt;
&lt;p&gt;SADD, SMEMBERS, SISMEMBER, SREM&lt;/p&gt;
&lt;h2 id=&#34;hash&#34;&gt;HASH&lt;/h2&gt;
&lt;p&gt;key-hash table&lt;/p&gt;
&lt;p&gt;内部也是key-value&lt;/p&gt;
&lt;p&gt;HSET, HGET, HGETALL, HDEL&lt;/p&gt;
&lt;h2 id=&#34;zset&#34;&gt;ZSET&lt;/h2&gt;
&lt;p&gt;key-zset&lt;/p&gt;
&lt;p&gt;ZADD, ZRANGE, ZRANGEBYSCORE, ZREM&lt;/p&gt;
&lt;h2 id=&#34;一个文章投票系统的设计&#34;&gt;一个文章投票系统的设计&lt;/h2&gt;
&lt;h3 id=&#34;基础功能设计&#34;&gt;基础功能设计&lt;/h3&gt;
&lt;p&gt;根据文章的发布时间和投票数量计算一个评分，根据该评分来排序和展示文章&lt;/p&gt;
&lt;p&gt;要求：如果有一篇文章符合有趣文章的要求（支持票至少200张），放在排行榜前100位至少一天&lt;/p&gt;
&lt;p&gt;构造分数&lt;/p&gt;
&lt;p&gt;$
score = up\ vote\ *C + post\ time
$&lt;/p&gt;
&lt;p&gt;常量C可以选择432&lt;/p&gt;
&lt;p&gt;分析：一天的秒数为86400，文章达到有趣需要200票，可以利用86400/200=432来作为每个投票对得分的贡献&lt;/p&gt;
&lt;p&gt;保存评分以及存储文章信息&lt;/p&gt;
&lt;p&gt;使用hash结构存储文章的标题，文章的url，发布文章的用户，发布时间，得票数量等信息&lt;/p&gt;
&lt;p&gt;关于key的设置，可以使用任意字符作为分隔符，如&lt;code&gt;article:ID&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用两个zset，其中一个成员为文章id，分值为文章的发布时间，另一个成员为文章id，分值为文章的评分，使得网站可以按照发布时间和评分两种方式展示文章&lt;/p&gt;
&lt;p&gt;防止用户重复投票，建立已投票用户名单，使用set结构，key为&lt;code&gt;voted:article_id&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;需要用到的一些指令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ZSCORE 获取文章发布时间的有序集合，判断发布时间是否在一周内&lt;/li&gt;
&lt;li&gt;SADD 若可投票，将用户添加到已投票的set中，操作成功则说明用户未向该文章投过票&lt;/li&gt;
&lt;li&gt;ZINCRBY 将文章的评分增加432&lt;/li&gt;
&lt;li&gt;HINCRBY 对hash结构中的文章投票数量进行更新&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;发布获取文章&#34;&gt;发布获取文章&lt;/h3&gt;
&lt;p&gt;发布文章需要新增id，使用计数器，执行incr指令&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;incr keyname
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;可以得到计数器++之后的值&lt;/p&gt;
&lt;p&gt;使用sadd将发布者id添加到文章投票的用户集合中（避免自己给自己投票）&lt;/p&gt;
&lt;p&gt;集合的过期时间为一周，一周后自动释放expire&lt;/p&gt;
&lt;p&gt;HMSET存储文章相关信息&lt;/p&gt;
&lt;p&gt;执行zadd添加文章初始评分到保存评分的zset&lt;/p&gt;
&lt;p&gt;执行zadd添加文章发布时间到保存时间的zset&lt;/p&gt;
&lt;p&gt;使用HGETALL获取存储在hash中的文章结构&lt;/p&gt;
&lt;p&gt;使用ZREVRANGE取出评分最高的文章和最新发布的文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用ZREVRANGE获取文章的id&lt;/li&gt;
&lt;li&gt;使用HGETALL获取详细内容&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;文章分组&#34;&gt;文章分组&lt;/h3&gt;
&lt;p&gt;TODO&lt;/p&gt;</description>
        </item>
        <item>
        <title>【操作系统】网络编程</title>
        <link>https://blog.ipandai.club/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link>
        <pubDate>Mon, 03 Jan 2022 13:37:02 +0000</pubDate>
        
        <guid>https://blog.ipandai.club/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid>
        <description>&lt;p&gt;承接Unix I/O这一章节，了解网络如何构建以及客户端和服务器如何通信，socket函数相关内容的学习&lt;/p&gt;
&lt;p&gt;CSAPP Ch-11 笔记&lt;/p&gt;
&lt;h2 id=&#34;cs编程模型&#34;&gt;CS编程模型&lt;/h2&gt;
&lt;p&gt;客户端服务器模型&lt;/p&gt;
&lt;p&gt;一个服务器进程，多个客户端进程&lt;/p&gt;
&lt;p&gt;基本操作是事务transaction&lt;/p&gt;
&lt;p&gt;有四步&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端向服务器发送请求，发起一个事务&lt;/li&gt;
&lt;li&gt;服务器解释请求，用响应的方式操作资源&lt;/li&gt;
&lt;li&gt;服务器返回响应，等待下一个请求&lt;/li&gt;
&lt;li&gt;客户端接受响应并处理&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;网络&#34;&gt;网络&lt;/h2&gt;
&lt;p&gt;网络是一种IO设备，是数据源和数据接收方&lt;/p&gt;
&lt;p&gt;网络数据接收后经IO和内存总线复制到内存，双向传输&lt;/p&gt;
&lt;p&gt;以太网Ethernet是局域网技术&lt;/p&gt;
&lt;p&gt;电缆链接主机和集线器，集线器广播每个端口的信息到所有主机&lt;/p&gt;
&lt;p&gt;主机发送帧frame开头的信息，包括header，随后是有效载荷，payload，网内每个主机都可以见，只有目的主机读取&lt;/p&gt;
&lt;p&gt;桥接以太网，主机&amp;hellip;-集线器-桥-桥-集线器-&amp;hellip;主机，网桥会根据通信需要来选择是否转发帧到其他网桥&lt;/p&gt;
&lt;p&gt;连接多个局域网使用路由器&lt;/p&gt;
&lt;p&gt;协议解决网络传输中的差异，提供命名机制（网络地址）和传输机制（包头+有效载荷）&lt;/p&gt;
&lt;p&gt;数据发送过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主机A通过系统调用从虚存加载数据到内核缓冲区&lt;/li&gt;
&lt;li&gt;主机A上的协议软件添加互联网包头和接口帧头，互联网包头指向主机B，接口帧头指向主机LAN1。是封装关系。
帧头的包数据为互联网包头以及数据，帧头为其自己的互联网包头&lt;/li&gt;
&lt;li&gt;LAN1适配器复制数据到网络&lt;/li&gt;
&lt;li&gt;路由器读取数据猴传送到协议软件&lt;/li&gt;
&lt;li&gt;协议软件读取目标互联网地址，作为路由表的索引转发到对应的LAN2适配器&lt;/li&gt;
&lt;li&gt;LAN2适配器复制帧到网络&lt;/li&gt;
&lt;li&gt;到达主机B，从适配器读取帧，传输到协议软件&lt;/li&gt;
&lt;li&gt;协议软件去除包头和帧头，读取数据，主机B通过系统调用拷贝数据到虚拟地址空间&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;全球ip&#34;&gt;全球IP&lt;/h2&gt;
&lt;p&gt;客户端（用户）-【socket接口系统调用】-TCP/IP（内核）-【硬件接口，中断】-网络适配器（硬件）-全局IP因特网&lt;/p&gt;
&lt;p&gt;使用socket接口函数和Unix IO函数通信，socket函数为系统调用，调用内核的TCP/IP函数&lt;/p&gt;
&lt;p&gt;TCP/IP是一个协议族，IP协议提供命名方法和传递机制，数据报&lt;/p&gt;
&lt;p&gt;IP机制不可靠，数据报丢失不会自动恢复&lt;/p&gt;
&lt;p&gt;UDP UNreliable datagram protocol，不可靠数据报协议对其进行了扩展，包可以在进程之间传递，而不是主机之间&lt;/p&gt;
&lt;p&gt;TCP是基于IP的协议，进程间可靠的全双工连接&lt;/p&gt;
&lt;p&gt;因特网的特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主机集合映射到32位ip地址&lt;/li&gt;
&lt;li&gt;ip地址映射为一组域名&lt;/li&gt;
&lt;li&gt;主机上的进程能够通过连接其他主机的进程通信&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ipv4和ipv6：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;version 4：32位地址&lt;/li&gt;
&lt;li&gt;version 6：128位地址&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ip地址&#34;&gt;ip地址&lt;/h3&gt;
&lt;p&gt;32位无符号整数，8*4&lt;/p&gt;
&lt;p&gt;TCP/IP统一了字节顺序，大端法&lt;/p&gt;
&lt;p&gt;使用点分十进制表示，Linux查看主机地址&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;hostname -i
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;域名&#34;&gt;域名&lt;/h3&gt;
&lt;p&gt;一级域名mil，edu，gov，com，cn&lt;/p&gt;
&lt;p&gt;二级域名whut.edu&lt;/p&gt;
&lt;p&gt;hosts文件手工维护ip和域名的映射&lt;/p&gt;
&lt;p&gt;DNS，domain name system&lt;/p&gt;
&lt;p&gt;Linux使用nslookup查看域名ip&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;nslookup baidu.com
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;通常域名和ip一一对应，多个域名也可以对应同一ip，泛域名cs.whut.edu, ee.whut.edu&lt;/p&gt;
&lt;p&gt;多个域名可以映射到同一组的多个ip，如www.twitter.com和twitter.com映射到199.16.156.*&lt;/p&gt;
&lt;h3 id=&#34;因特网连接&#34;&gt;因特网连接&lt;/h3&gt;
&lt;p&gt;客户端和服务器在连接上发送和接收字节流来通信，点对点，全双工，可以同时双向流动&lt;/p&gt;
&lt;p&gt;socket是连接的端点，每个socket都有socket地址，由&lt;code&gt;地址:端口&lt;/code&gt;构成，十六位端口号0-65535&lt;/p&gt;
&lt;p&gt;客户端发起请求时，客户端socket地址端口由内核自动分配，临时端口；服务器的为默认端口&lt;/p&gt;
&lt;p&gt;web使用80（http），电子邮件地址使用25（SMTP）&lt;/p&gt;
&lt;p&gt;可以通过&lt;code&gt;/etc/services&lt;/code&gt;看查&lt;strong&gt;知名&lt;/strong&gt;服务默认端口&lt;/p&gt;
&lt;p&gt;一个连接两端的socket地址是唯一确定的，socket pair，格式&lt;code&gt;(cliaddr:cliport, servaddr:servport)&lt;/code&gt;，即&lt;code&gt;(客户端IP:客户端端口,服务器IP:服务器端口)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;socket接口&#34;&gt;socket接口&lt;/h2&gt;
&lt;p&gt;一组函数实现，和Unix IO配合创建网络应用&lt;/p&gt;
&lt;p&gt;流程：&lt;/p&gt;
&lt;p&gt;客户端getaddrinfo-&amp;gt;socket-&amp;gt;connect发送连接请求-&amp;gt;rio_writen-&amp;gt;rio_readlineb-&amp;gt;close发送EOF&lt;/p&gt;
&lt;p&gt;服务器getaddrinfo-&amp;gt;socket-&amp;gt;bind-&amp;gt;listen-&amp;gt;accept接受请求-&amp;gt;rio_readlineb读客户端的write-&amp;gt;rio_writen写入response-&amp;gt;rio_readlineb读取EOF-close&lt;/p&gt;
&lt;h3 id=&#34;socket地址结构&#34;&gt;socket地址结构&lt;/h3&gt;
&lt;p&gt;对于Linux内核，socket就是一个有描述符的打开文件&lt;/p&gt;
&lt;p&gt;socket地址存放与&lt;code&gt;sockaddr_in&lt;/code&gt;，包含&lt;code&gt;AF_INET&lt;/code&gt;，&lt;code&gt;sin_port&lt;/code&gt;为16位端口号，&lt;code&gt;sin_addr&lt;/code&gt;为32位ip地址，都是以大端法存放&lt;/p&gt;
&lt;h3 id=&#34;socket函数&#34;&gt;socket函数&lt;/h3&gt;
&lt;p&gt;客户端和服务器使用socket函数创建socket描述符&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;n&#34;&gt;clientfd&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Socket&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;AF_INET&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SOCK_STREAM&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;AF_INET&lt;/code&gt;表示使用32位IP地址，&lt;code&gt;SOCK_STREAM&lt;/code&gt;表示该socket为连接端点&lt;/p&gt;
&lt;p&gt;该函数返回的描述符为部分打开的，不能读写，将有客户端完成打开socket的工作&lt;/p&gt;
&lt;h3 id=&#34;connect函数&#34;&gt;connect函数&lt;/h3&gt;
&lt;p&gt;客户端调用connect函数建立和服务器连接&lt;/p&gt;
&lt;p&gt;connect函数会阻塞一直到连接成功建立或者错误，成功后clientfd为可读写状态&lt;/p&gt;
&lt;p&gt;由getaddrinfo函数获取connect的参数&lt;/p&gt;
&lt;h3 id=&#34;bind函数&#34;&gt;bind函数&lt;/h3&gt;
&lt;p&gt;bind函数通知内核将addr中的服务器socket地址和socket描述符socketfd联系到一起&lt;/p&gt;
&lt;p&gt;由getaddrinfo函数获取bind的参数&lt;/p&gt;
&lt;h3 id=&#34;listen函数&#34;&gt;listen函数&lt;/h3&gt;
&lt;p&gt;客户端是发起请求的主动实体，服务器是被动实体&lt;/p&gt;
&lt;p&gt;默认，内核认为socket函数创建的描述符为主动socket，服务器通过listen函数通知内核描述符是被服务器使用而不是客户端&lt;/p&gt;
&lt;p&gt;将socketfd从主动socket转化为监听socket，监听socket可以接受客户端的连接请求&lt;/p&gt;
&lt;p&gt;参数backlog为队列中未完成的请求数量，一般设置较大的数&lt;/p&gt;
&lt;h3 id=&#34;accept函数&#34;&gt;accept函数&lt;/h3&gt;
&lt;p&gt;服务器使用accept函数等待客户端的连接请求&lt;/p&gt;
&lt;p&gt;已经获得监听描述符connfd，listenfd，返回一个已连接描述符，该描述符可以被Unix IO读写，可以和客户端通信，将connfd返回给客户端&lt;/p&gt;
&lt;p&gt;与监听描述符不太，监听描述符是客户端连接请求的端点，只创建一次，存在于服务器的整个生命周期&lt;/p&gt;
&lt;p&gt;已连接描述符为客户端和服务器直接已经建立连接的端点，服务器每次接受请求都会创建&lt;/p&gt;
&lt;p&gt;可以理解为后端程序当前已经监听系统的某个端口，此时客户端请求后后端在该基础上创建一个线程去处理该请求&lt;/p&gt;
&lt;h3 id=&#34;主机和服务的转换&#34;&gt;主机和服务的转换&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;getaddrinfo&lt;/code&gt;
将主机名、主机地址、服务名端口号转为socket地址结构
返回result为一个addrinfo链表，每个结构对应一个host和service的socket地址结构
客户端调用之后，遍历链表，尝试每个地址，直到socket和connect成功，建立连接
服务器会遍历每个地址，直到socket和bind成功
避免内存泄露，最后调用freeaddrinfo释放链表
参数讲解跳了&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getnameinfo&lt;/code&gt;
将socket地址转换为主机和服务名字符串&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;socket接口辅助函数&#34;&gt;socket接口辅助函数&lt;/h3&gt;
&lt;p&gt;以上接口的整合封装&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;open_clientfd
&lt;code&gt;int open_clientfd(char *hostname, char *port)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;open_clientfd建立和服务器的连接，返回描述符，可以直接用于Unix IO函数读写&lt;/p&gt;
&lt;p&gt;流程：getaddrinfo，返回addrinfo链表，遍历链表尝试建立连接，失败则关闭描述符，成功后释放链表将描述符（connfd）返回给客户端&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;open_listenfd
服务器创建监听描述符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;int open_listenfd(char *port)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;遍历链表直到调用socket和bind成功&lt;/p&gt;
&lt;h3 id=&#34;echo实例&#34;&gt;echo实例&lt;/h3&gt;
&lt;p&gt;简单的单线程处理服务器&lt;/p&gt;
&lt;p&gt;EOF概念，并不是字符，而是内核检测的一个条件，read函数返回0时，程序检测到EOF条件。磁盘文件读写，文件位置超出长度，判断EOF。网络连接，进程关闭连接其中一端，触发EOF。尝试读取通信中字节流的最后一个字节之后的字节，触发EOF。&lt;/p&gt;
&lt;h2 id=&#34;web服务器&#34;&gt;Web服务器&lt;/h2&gt;
&lt;h3 id=&#34;web基础&#34;&gt;Web基础&lt;/h3&gt;
&lt;p&gt;HTTP协议，Hypertext Transfer Protocol超文本传输协议&lt;/p&gt;
&lt;h3 id=&#34;web内容&#34;&gt;Web内容&lt;/h3&gt;
&lt;p&gt;内容是MIME，多用途的网际邮件扩充协议，类型相关的字节序列&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读取一个磁盘文件，将内容返回给客户端，磁盘文件为静态内容&lt;/li&gt;
&lt;li&gt;运行可执行文件，将输出返回&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用URL标识每个文件&lt;/p&gt;
&lt;p&gt;根据目录指定返回规则&lt;/p&gt;
&lt;p&gt;根目录为网页静态内容的根目录&lt;/p&gt;
&lt;p&gt;后缀为&lt;code&gt;/&lt;/code&gt;时服务器自动补全默认文件名&lt;/p&gt;
&lt;h3 id=&#34;http事务&#34;&gt;HTTP事务&lt;/h3&gt;
&lt;p&gt;使用Linux的Telnet和任何web服务器执行事务&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;telnet url port
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;HTTP请求&lt;/p&gt;
&lt;p&gt;请求行&lt;code&gt;method URI version&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;0个或多个请求报头&lt;/p&gt;
&lt;p&gt;一个空的文本行终止报头列表&lt;/p&gt;
&lt;p&gt;body&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;GET / HTTP/1.1  
Host: www.baidu.com

&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;请求方法GET、POST、OPTIONS、HEAD、PUT、DELETE、TRACE&lt;/p&gt;
&lt;p&gt;URI是相应URL的后缀，包括文件名和参数&lt;/p&gt;
&lt;p&gt;version为http版本&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://developer.mozilla.org/zh-CN/docs/Glossary/Request_header&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Mozilla文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;header可以存放多种信息，比如cookie等&lt;/p&gt;
&lt;p&gt;host请求头在HTTP 1.1位必须，1.0中不必须。代理缓存proxy cache会使用host报头，理解为反向代理？&lt;/p&gt;
&lt;p&gt;客户端和服务器直接可以由代理，&lt;code&gt;代理链&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;HTTP响应组成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;响应行
0个或多个响应头
终止报头的空行
响应主体body
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;响应行格式&lt;/p&gt;
&lt;p&gt;&lt;code&gt;version status-code status-message&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;version对于HTTP版本，code为&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;1**
200
301 
400
403
404
501
505
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;更多状态码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;响应头中应有Content-Type，告知客户端主体内容的MIME类型，Content-Length，告知主体的字节大小&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;传递参数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;URI或者请求主体
2. 服务器传递参数给子进程&lt;/p&gt;
&lt;p&gt;fork一个子进程，调用execve在子进程上下文中执行对应的程序，通过环境变量，如QUERY_STRING, REQUEST_METHOD等信息，程序做出对应的处理&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;子进程的输出到哪里？
CGI程序（通用网关接口Common Gateway Interface），将内容发送到标准输出，在子进程调用CGI程序之前，使用Linux dup2函数将标准输出重定向到和客户端相连的已连接描述符，CGI程序写入到标准输出的内容都会直接到达客户端&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;实现一个web服务器&#34;&gt;实现一个Web服务器&lt;/h1&gt;
&lt;p&gt;使用c配合CSAPP提供的封装搭建一个简易的web服务器&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;本章主要了解了Unix如何建立一个网络连接，以及数据传输的具体过程，socket的设计巧妙之处，以及Linux一切皆文件的进一步理解。&lt;/p&gt;</description>
        </item>
        <item>
        <title>【操作系统】系统级IO</title>
        <link>https://blog.ipandai.club/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B3%BB%E7%BB%9F%E7%BA%A7io/</link>
        <pubDate>Mon, 03 Jan 2022 10:31:33 +0000</pubDate>
        
        <guid>https://blog.ipandai.club/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B3%BB%E7%BB%9F%E7%BA%A7io/</guid>
        <description>&lt;p&gt;高级别的IO程序，如c中的printf和scanf，c++中的&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;，都依赖Unix 系统级IO&lt;/p&gt;
&lt;p&gt;CSAPP Ch-10 笔记&lt;/p&gt;
&lt;h2 id=&#34;unix-io&#34;&gt;Unix IO&lt;/h2&gt;
&lt;p&gt;Linux文件即是m个字节的序列$B_0, B_1, &amp;hellip;, B_k, &amp;hellip;, B_{m-1}$&lt;/p&gt;
&lt;p&gt;所有的IO设备（网络，磁盘，终端）被抽象为文件，输入和输出被作为相应文件的读和写进行，Linux内核只需要暴露一个简单低级的应用接口&lt;/p&gt;
&lt;p&gt;输入和输出的统一方式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打开文件：应用程序请求IO设备，内核返回描述符&lt;/li&gt;
&lt;li&gt;Linux Shell创建的进程开始时有三个文件：标准输入0，标准输出1，标准错误2&lt;/li&gt;
&lt;li&gt;改变当前的文件位置：内核存储文件位置k，初始为0，通过seek改变这个偏移量&lt;/li&gt;
&lt;li&gt;读写文件：读为复制字节到内存，当k&amp;gt;=m时，会触发EOF条件；写为复制字节到一个文件中，从当前位置k开始，然后更新k&lt;/li&gt;
&lt;li&gt;关闭文件：通知内核，内核释放文件打开时创建的数据结构，释放描述符，进程终止时内核会释放打开的文件以及内存&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;文件&#34;&gt;文件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;普通文件：文本文件：ASCII或Unicode字符文件，其他的都是二进制文件，对内核而言无区别，换行符&lt;code&gt;\n&lt;/code&gt;对应ASCII LF&lt;/li&gt;
&lt;li&gt;目录：包含一组链接的文件，链接将文件名映射到一个文件&lt;/li&gt;
&lt;li&gt;套接字socket：与另一个进程进行跨网络通信的文件&lt;/li&gt;
&lt;li&gt;命名通道named pipe，符号链接，字符和块设备&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;绝对路径：以斜杠开始&lt;code&gt;/home/test&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;相对路径：以文件名开始,&lt;code&gt;../test&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;打开和关闭文件&#34;&gt;打开和关闭文件&lt;/h2&gt;
&lt;p&gt;open函数打开或创建文件&lt;/p&gt;
&lt;p&gt;返回一个文件描述符，在进程中没有打开的最小描述符
几种控制参数flags&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;n&#34;&gt;O_RDONLY&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;只读&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;O_WRONLY&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;只写&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;O_RDWR&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;可读可写&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;O_CREAT&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;文件不存在则创建空文件&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;O_TRUNC&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;存在则截断，清空&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;O_APPEND&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;追加写入&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;mode参数控制读写权限&lt;/p&gt;
&lt;p&gt;每个进程都有umask&lt;/p&gt;
&lt;p&gt;访问权限为&lt;code&gt;mode &amp;amp; ~umask&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;close(int fd)关闭文件，成功返回0，失败-1&lt;/p&gt;
&lt;h2 id=&#34;读写文件&#34;&gt;读写文件&lt;/h2&gt;
&lt;p&gt;read和write&lt;/p&gt;
&lt;p&gt;输入的size为unsigned long类型，ssize_t为long类型，因为read和write函数需要返回-1&lt;/p&gt;
&lt;p&gt;read和write读写遇到不足的情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读取时遇到EOF&lt;/li&gt;
&lt;li&gt;从终端读文本行&lt;/li&gt;
&lt;li&gt;读写socket：网络延迟导致read和write返回值不足&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;rio包-robust-io&#34;&gt;RIO包 Robust IO&lt;/h2&gt;
&lt;h2 id=&#34;读取文件元数据&#34;&gt;读取文件元数据&lt;/h2&gt;
&lt;p&gt;stat和fstat函数，读取文件信息&lt;/p&gt;
&lt;h2 id=&#34;读取目录内容&#34;&gt;读取目录内容&lt;/h2&gt;
&lt;p&gt;opendir函数&lt;/p&gt;
&lt;h2 id=&#34;共享文件&#34;&gt;共享文件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;描述符表，每个进程之间独立&lt;/li&gt;
&lt;li&gt;文件表，打开文件的集合，所有进程共享，包含文件位置，引用计数，指向vnode表的指针，当引用计数为0时，操作系统删除表项&lt;/li&gt;
&lt;li&gt;v-node，进程间共享，包含stat中的信息，st mode，st size&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;io重定向&#34;&gt;IO重定向&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;标准输出&lt;/strong&gt;重定向到磁盘文件&lt;/p&gt;
&lt;p&gt;覆盖写入文件之前的内容&lt;/p&gt;
&lt;p&gt;使用dup2函数，将终端的输出关闭，改为磁盘文件，磁盘文件引用次数+1&lt;/p&gt;
&lt;h2 id=&#34;标准io&#34;&gt;标准IO&lt;/h2&gt;
&lt;p&gt;标准IO将打开的文件模型化为一个流，减少系统级IO操作的调用&lt;/p&gt;
&lt;p&gt;第一次getc调用IO read函数读取到缓冲区，之后调用将缓冲区第一个字节返回给应用程序&lt;/p&gt;
&lt;h2 id=&#34;选取io函数问题&#34;&gt;选取IO函数问题&lt;/h2&gt;
&lt;p&gt;socket中不要使用标准IO，可能会导致崩溃，使用RIO函数/Unix IO&lt;/p&gt;</description>
        </item>
        <item>
        <title>Git学习笔记</title>
        <link>https://blog.ipandai.club/p/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Fri, 02 Apr 2021 22:33:25 +0000</pubDate>
        
        <guid>https://blog.ipandai.club/p/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
        <description>&lt;p&gt;对于git，很早很早就在用了，但是还没有系统整理过，并且有些命令使用时需要注意的事项，在此也一并标出。&lt;/p&gt;
&lt;h1 id=&#34;about-git&#34;&gt;About Git&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;git&lt;/code&gt;是一个分布式版本控制工具，如果你是一个程序猿，那你必须要学会如何使用&lt;code&gt;git&lt;/code&gt;来管理你的代码或者项目。
可能更多人所熟知的是GitHub，顾名思义，按照英语的命名特点，GitHub就是所有git上传的枢纽，汇聚到一起，你可以开源你的代码，指定一款开源协议共享给所有需要的人，也可以将仓库设为私有，只有自己或者受到邀请的人可见或者进行编辑。
除了GitHub，世界上还有很多这种代码托管平台，比如国内的gitee,coding等，国外还有gitlab等平台提供代码托管服务。&lt;/p&gt;
&lt;h1 id=&#34;setup&#34;&gt;Setup&lt;/h1&gt;
&lt;p&gt;在一个目录中，你可以使用&lt;code&gt;git init&lt;/code&gt;来初始化这个目录，git会把这个文件夹变为一个git目录，&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&amp;gt; GitTest git init
Initialized empty Git repository in /Users/username/GitTest/.git/
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;使用&lt;code&gt;git remote add origin {your repo url}&lt;/code&gt;
即可添加远程的仓库地址。&lt;/p&gt;
&lt;h1 id=&#34;commit--push&#34;&gt;Commit &amp;amp;&amp;amp; Push&lt;/h1&gt;
&lt;p&gt;对于一个采用迭代式开发或者其他开发模式的项目来说，都避免不了后续对代码进行修改或者添加一些新的文件，对于每一次这样的操作，都要对添加或者修改的文件指定一个commit。
例如：修改了项目功能中的bug，文件名字为&lt;code&gt;a.cpp&lt;/code&gt;
可以使用&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;git add a.cpp
git commit -m &amp;#34;fix: the bug in xxx&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这样就可以将此次更改添加到提交的队列中
如果使用&lt;code&gt;git add .&lt;/code&gt;，git将添加所有监控的文件到缓冲区
再使用&lt;code&gt;git push&lt;/code&gt;就可以将修改添加到远程仓库中&lt;/p&gt;
&lt;p&gt;对与一个团队而言，有标准规范的commit格式是很重要的，例如以下格式&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;feat: 新功能feature
fix: 解决bug
add: 添加模块
update: 更新模块
... 等等
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id=&#34;dangerous-pull-ing&#34;&gt;Dangerous Pull ing&lt;/h1&gt;
&lt;p&gt;如果是多人协作开发，那么必然会导致本地文件之间存在着不一致，为了解决这个问题，可以使用&lt;code&gt;git pull&lt;/code&gt;，执行该命令后将同步仓库中存在并且与本地不同的文件。
这个操作看似简单，但是有时候如果使用了&amp;ndash;force强制执行的话，会覆盖掉本地的文件，属于非常危险的操作，所以无论在什么时候使用&amp;ndash;force之前都要思考清楚自己在干什么。&lt;/p&gt;
&lt;h1 id=&#34;branch&#34;&gt;Branch&lt;/h1&gt;
&lt;p&gt;我觉得git很强大的一个功能就是对分支的管理，在不同分支中切换可以让项目的代码得到更有效的管理，例如在main主分支中保存可以稳定运行的版本，在另一个dev分支中保存正在开发的非稳定版，后续改进之后可以将dev分支合并到main分支中去。
如果更新过后的主分支依然出现问题，也是可以通过回滚的方式回到之前某个稳定的版本。
分支的创建也非常简单&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;git branch name
git checkout name
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;切换后git所有的操作将在新的分支进行&lt;/p&gt;
&lt;h1 id=&#34;gitignore&#34;&gt;.gitignore&lt;/h1&gt;
&lt;p&gt;顾名思义，肯定是让git去忽略某些项目，比如文件夹，或者是单个文件，添加到gitignore之后git将不在追踪这些文件的变化，因此我们可以将例如npm庞大的node_modules这种文件夹添加到其中，或者是编译器调试产生的临时文件，优化仓库的存储结构。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;git status
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;使用该命令看查目前项目的改动&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;On branch dev
Untracked files:
  (use &amp;#34;git add &amp;lt;file&amp;gt;...&amp;#34; to include in what will be committed)
	b.cpp

nothing added to commit but untracked files present (use &amp;#34;git add&amp;#34; to track)
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;git监控到了文件b.cpp的产生，我们将b.cpp添加到.gitignore中&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;On branch dev
nothing to commit, working tree clean
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;再次使用git status看查，发现b.cpp已经不再被监控了，在.gitignore中还可以使用文件夹名忽略整个文件夹的项目，或者使用通配忽略包含特定后缀名的文件等。&lt;/p&gt;
&lt;h1 id=&#34;end&#34;&gt;End&lt;/h1&gt;
&lt;p&gt;随着开发工具的现代化，很多时候我们已经用不到这些git命令了，很多繁琐的命令早已被图形化的界面取代，但不乏还有git爱好者们做出的努力，如&lt;a class=&#34;link&#34; href=&#34;https://github.com/jesseduffield/lazygit&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;lazygit&lt;/a&gt;等工具。
当你接收一台崭新的服务器时，这些命令又显得格为重要了。因此，在简便的工具的包裹下，他们背后的原理才是最值得我们去了解的，就如同学习汇编语言一样，给力我们另一种看待程序的方式。
很早就像总结一下git了，拖了这么久终于写完了，后续还想再添加一些更具体的内容，希望能给初入git的同学一些启发。&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
